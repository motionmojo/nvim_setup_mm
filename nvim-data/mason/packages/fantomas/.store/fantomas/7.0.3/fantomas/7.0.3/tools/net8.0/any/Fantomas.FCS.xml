<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Fantomas.FCS</name></assembly>
<members>
<member name="M:FSComp.SR.yieldUsedInsteadOfYieldBang">
<summary>
 Consider using &apos;yield!&apos; instead of &apos;yield&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:38)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocUnresolvedCrossReference(System.String)">
<summary>
 This XML comment is invalid: unresolved cross-reference &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1674)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocMissingParameterName">
<summary>
 This XML comment is invalid: missing &apos;name&apos; attribute for parameter or parameter reference
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1670)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocMissingParameter(System.String)">
<summary>
 This XML comment is incomplete: no documentation for parameter &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1675)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocMissingCrossReference">
<summary>
 This XML comment is invalid: missing &apos;cref&apos; attribute for cross-reference
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1671)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocInvalidParameterName(System.String)">
<summary>
 This XML comment is invalid: unknown parameter &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1672)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocDuplicateParameter(System.String)">
<summary>
 This XML comment is invalid: multiple documentation entries for parameter &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1673)
</summary>
</member>
<member name="M:FSComp.SR.xmlDocBadlyFormed(System.String)">
<summary>
 This XML comment is invalid: &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1669)
</summary>
</member>
<member name="M:FSComp.SR.writeToReadOnlyByref">
<summary>
 The byref pointer is readonly, so this write is not permitted.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1503)
</summary>
</member>
<member name="M:FSComp.SR.valueIsNotAccessible(System.String)">
<summary>
 The value &apos;%s&apos; is not accessible from this code location
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:976)
</summary>
</member>
<member name="M:FSComp.SR.useSdkRefs">
<summary>
 Use reference assemblies for .NET framework references when available (Enabled by default).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1557)
</summary>
</member>
<member name="M:FSComp.SR.unsupportedAttribute">
<summary>
 This attribute is currently unsupported by the F# compiler. Applying it will not achieve its intended effect.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:42)
</summary>
</member>
<member name="M:FSComp.SR.unnecessaryParentheses">
<summary>
 Parentheses can be removed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1760)
</summary>
</member>
<member name="M:FSComp.SR.unionCasesAreNotAccessible(System.String)">
<summary>
 The union cases or fields of the type &apos;%s&apos; are not accessible from this code location
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:975)
</summary>
</member>
<member name="M:FSComp.SR.unionCaseIsNotAccessible(System.String)">
<summary>
 The union case &apos;%s&apos; is not accessible from this code location
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:977)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueOfConstructor(System.String)">
<summary>
 The value or constructor &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:10)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueNamespaceTypeOrModule(System.String)">
<summary>
 The value, namespace, type or module &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:11)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameValueConstructorNamespaceOrType(System.String)">
<summary>
 The value, constructor, namespace or type &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:9)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameTypeParameter(System.String)">
<summary>
 The type parameter %s is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:18)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameTypeIn(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is not defined in &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:14)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameType(System.String)">
<summary>
 The type &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:13)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameSuggestionsIntro">
<summary>
 Maybe you want one of the following:
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:17)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameRecordLabelOrNamespace(System.String)">
<summary>
 The record label or namespace &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:15)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameRecordLabel(System.String)">
<summary>
 The record label &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:16)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNamePatternDiscriminator(System.String)">
<summary>
 The pattern discriminator &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:19)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameNamespaceOrModule(System.String)">
<summary>
 The namespace or module &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:6)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameNamespace(System.String)">
<summary>
 The namespace &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:5)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameFieldConstructorOrMemberWhenTypeIsKnown(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not define the field, constructor or member &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:8)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameFieldConstructorOrMember(System.String)">
<summary>
 The field, constructor or member &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:7)
</summary>
</member>
<member name="M:FSComp.SR.undefinedNameConstructorModuleOrNamespace(System.String)">
<summary>
 The constructor, module or namespace &apos;%s&apos; is not defined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:12)
</summary>
</member>
<member name="M:FSComp.SR.typrelTypeImplementsIComparableShouldOverrideObjectEquals(System.String)">
<summary>
 The type &apos;%s&apos; implements &apos;System.IComparable&apos;. Consider also adding an explicit override for &apos;Object.Equals&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:179)
</summary>
</member>
<member name="M:FSComp.SR.typrelTypeImplementsIComparableDefaultObjectEqualsProvided(System.String)">
<summary>
 The type &apos;%s&apos; implements &apos;System.IComparable&apos; explicitly but provides no corresponding override for &apos;Object.Equals&apos;. An implementation of &apos;Object.Equals&apos; has been automatically provided, implemented via &apos;System.IComparable&apos;. Consider implementing the override &apos;Object.Equals&apos; explicitly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:180)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleParamCountsDiffer">
<summary>
 The signature and implementation are not compatible because the respective type parameter counts differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:175)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleConstraintsDifferRemove(System.String,System.String)">
<summary>
 The signature and implementation are not compatible because the type parameter &apos;%s&apos; has a constraint of the form %s but the implementation does not. Either remove this constraint from the signature or add it to the implementation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:178)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleConstraintsDiffer(System.String,System.String)">
<summary>
 The signature and implementation are not compatible because the declaration of the type parameter &apos;%s&apos; requires a constraint of the form %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:177)
</summary>
</member>
<member name="M:FSComp.SR.typrelSigImplNotCompatibleCompileTimeRequirementsDiffer">
<summary>
 The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:176)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverrideWasAmbiguous(System.String)">
<summary>
 The override for &apos;%s&apos; was ambiguous
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:195)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverrideImplementsMoreThenOneSlot(System.String,System.String,System.String)">
<summary>
 The override &apos;%s&apos; implements more than one abstract slot, e.g. &apos;%s&apos; and &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:198)
</summary>
</member>
<member name="M:FSComp.SR.typrelOverloadNotFound(System.String,System.String)">
<summary>
 No implementations of &apos;%s&apos; had the correct number of arguments and type parameters. The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:194)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenWithSuggestion(System.String)">
<summary>
 No implementation was given for &apos;%s&apos;. Note that all interface members must be implemented and listed under an appropriate &apos;interface&apos; declaration, e.g. &apos;interface ... with member ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:205)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenSeveralWithSuggestion(System.String)">
<summary>
 No implementation was given for those members: %sNote that all interface members must be implemented and listed under an appropriate &apos;interface&apos; declaration, e.g. &apos;interface ... with member ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:206)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenSeveralTruncatedWithSuggestion(System.String)">
<summary>
 No implementation was given for those members (some results omitted): %sNote that all interface members must be implemented and listed under an appropriate &apos;interface&apos; declaration, e.g. &apos;interface ... with member ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:207)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenSeveralTruncated(System.String)">
<summary>
 No implementation was given for those members (some results omitted): %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:204)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGivenSeveral(System.String)">
<summary>
 No implementation was given for those members: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:203)
</summary>
</member>
<member name="M:FSComp.SR.typrelNoImplementationGiven(System.String)">
<summary>
 No implementation was given for &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:202)
</summary>
</member>
<member name="M:FSComp.SR.typrelNeverRefinedAwayFromTop">
<summary>
 A type has been implicitly inferred as &apos;obj&apos;, which may be unintended. Consider adding explicit type annotations. You can disable this warning by using &apos;#nowarn \&quot;3559\&quot;&apos; or &apos;--nowarn:3559&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1735)
</summary>
</member>
<member name="M:FSComp.SR.typrelNeedExplicitImplementation(System.String)">
<summary>
 The interface &apos;%s&apos; is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:200)
</summary>
</member>
<member name="M:FSComp.SR.typrelNamedArgumentHasBeenAssignedMoreThenOnce(System.String)">
<summary>
 The named argument &apos;%s&apos; has been assigned more than one value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:201)
</summary>
</member>
<member name="M:FSComp.SR.typrelMoreThenOneOverride(System.String)">
<summary>
 More than one override implements &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:196)
</summary>
</member>
<member name="M:FSComp.SR.typrelModuleNamespaceAttributesDifferInSigAndImpl">
<summary>
 The namespace or module attributes differ between signature and implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:192)
</summary>
</member>
<member name="M:FSComp.SR.typrelMethodIsSealed(System.String)">
<summary>
 The method &apos;%s&apos; is sealed and cannot be overridden
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:197)
</summary>
</member>
<member name="M:FSComp.SR.typrelMethodIsOverconstrained">
<summary>
 This method is over-constrained in its type parameters
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:193)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberHasMultiplePossibleDispatchSlots(System.String,System.String)">
<summary>
 The member &apos;%s&apos; matches multiple overloads of the same method.\nPlease restrict it to one of the following:%s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1396)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectNumberOfTypeParameters(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct number of method type parameters. The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:209)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectNumberOfArguments(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct number of arguments. The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:208)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberDoesNotHaveCorrectKindsOfGenericParameters(System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not have the correct kinds of generic parameters. The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:210)
</summary>
</member>
<member name="M:FSComp.SR.typrelMemberCannotImplement(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; cannot be used to implement &apos;%s&apos;. The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:211)
</summary>
</member>
<member name="M:FSComp.SR.typrelInvalidValue">
<summary>
 Invalid value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:174)
</summary>
</member>
<member name="M:FSComp.SR.typrelInterfaceWithConcreteAndVariableObjectExpression(System.String,System.String,System.String)">
<summary>
 You cannot implement the interface &apos;%s&apos; with the two instantiations &apos;%s&apos; and &apos;%s&apos; because they may unify.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1628)
</summary>
</member>
<member name="M:FSComp.SR.typrelInterfaceWithConcreteAndVariable(System.String,System.String,System.String,System.String)">
<summary>
 &apos;%s&apos; cannot implement the interface &apos;%s&apos; with the two instantiations &apos;%s&apos; and &apos;%s&apos; because they may unify.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1627)
</summary>
</member>
<member name="M:FSComp.SR.typrelInterfaceMemberNoMostSpecificImplementation(System.String)">
<summary>
 Interface member &apos;%s&apos; does not have a most specific implementation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1555)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfGetHashCodeOrEquals(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.GetHashCode&apos; or &apos;Object.Equals&apos;. You must apply the &apos;CustomEquality&apos; attribute to the type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:181)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfGetHashCode(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.GetHashCode&apos;. Consider implementing a matching override for &apos;Object.Equals(obj)&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:182)
</summary>
</member>
<member name="M:FSComp.SR.typrelExplicitImplementationOfEquals(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has an explicit implementation of &apos;Object.Equals&apos;. Consider implementing a matching override for &apos;Object.GetHashCode()&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:183)
</summary>
</member>
<member name="M:FSComp.SR.typrelDuplicateInterface">
<summary>
 Duplicate or redundant interface
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:199)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveImplicitGenericInstantiation(System.String,System.String)">
<summary>
 The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. &apos;%s&apos; and &apos;%s&apos;. Consider using type annotations to resolve the ambiguity
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:170)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInUnmanaged">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with an &apos;unmanaged&apos; constraint at or near this position
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1088)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInPrintf">
<summary>
 Could not resolve the ambiguity inherent in the use of a &apos;printf&apos;-style format string
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:171)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInEnum">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with an &apos;enum&apos; constraint at or near this position
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:172)
</summary>
</member>
<member name="M:FSComp.SR.typrelCannotResolveAmbiguityInDelegate">
<summary>
 Could not resolve the ambiguity in the use of a generic construct with a &apos;delegate&apos; constraint at or near this position
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:173)
</summary>
</member>
<member name="M:FSComp.SR.typeIsNotAccessible(System.String)">
<summary>
 The type &apos;%s&apos; is not accessible from this code location
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:974)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoUnionCase">
<summary>
 union case
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:952)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoProperty">
<summary>
 property
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:957)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoPatternVariable">
<summary>
 patvar
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:962)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoOtherOverloads(System.Int32)">
<summary>
 and %d other overloads
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:951)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoNamespaceOrModule">
<summary>
 namespace/module
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:965)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoNamespace">
<summary>
 namespace
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:963)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoModule">
<summary>
 module
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:964)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoGeneratedType">
<summary>
 generated type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:969)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoGeneratedProperty">
<summary>
 generated property
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:968)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFullName">
<summary>
 Full name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:947)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFromNext(System.String)">
<summary>
 also from %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:967)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoFromFirst(System.String)">
<summary>
 from %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:966)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoField">
<summary>
 field
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:955)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoExtension">
<summary>
 extension
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:958)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoEvent">
<summary>
 event
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:956)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoCustomOperation">
<summary>
 custom operation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:959)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoCallsWord">
<summary>
 Calls
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1300)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoArgument">
<summary>
 argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:960)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoAnonRecdField">
<summary>
 anonymous record field
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:961)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoActiveRecognizer">
<summary>
 active recognizer
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:954)
</summary>
</member>
<member name="M:FSComp.SR.typeInfoActivePatternResult">
<summary>
 active pattern result
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:953)
</summary>
</member>
<member name="M:FSComp.SR.tupleRequiredInAbstractMethod">
<summary>
 \nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:39)
</summary>
</member>
<member name="M:FSComp.SR.toolLocationHelperUnsupportedFrameworkVersion(System.String)">
<summary>
 The specified .NET Framework version &apos;%s&apos; is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1138)
</summary>
</member>
<member name="M:FSComp.SR.tooManyMethodsInDotNetTypeWritingAssembly(System.String,System.Int32,System.Int32)">
<summary>
 The type &apos;%s&apos; has too many methods. Found: &apos;%d&apos;, maximum: &apos;%d&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1770)
</summary>
</member>
<member name="M:FSComp.SR.tlrUnexpectedTExpr">
<summary>
 Unexpected Expr.TyChoose
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:984)
</summary>
</member>
<member name="M:FSComp.SR.tlrLambdaLiftingOptimizationsNotApplied">
<summary>
 Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:985)
</summary>
</member>
<member name="M:FSComp.SR.tcVolatileOnlyOnClassLetBindings">
<summary>
 The &apos;VolatileField&apos; attribute may only be used on &apos;let&apos; bindings in classes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:678)
</summary>
</member>
<member name="M:FSComp.SR.tcVolatileFieldsMustBeMutable">
<summary>
 Volatile fields must be marked &apos;mutable&apos; and cannot be thread-static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:733)
</summary>
</member>
<member name="M:FSComp.SR.tcValueInSignatureRequiresLiteralAttribute">
<summary>
 A declaration may only be given a value in a signature if the declaration has the [&lt;Literal&gt;] attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:731)
</summary>
</member>
<member name="M:FSComp.SR.tcUsingInterfacesWithStaticAbstractMethods">
<summary>
 Declaring \&quot;interfaces with static abstract methods\&quot; is an advanced feature. See https://aka.ms/fsharp-iwsams for guidance. You can disable this warning by using &apos;#nowarn \&quot;3535\&quot;&apos; or &apos;--nowarn:3535&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1717)
</summary>
</member>
<member name="M:FSComp.SR.tcUsingInterfaceWithStaticAbstractMethodAsType(System.String)">
<summary>
 &apos;%s&apos; is normally used as a type constraint in generic code, e.g. \&quot;&apos;T when ISomeInterface&lt;&apos;T&gt;\&quot; or \&quot;let f (x: #ISomeInterface&lt;_&gt;)\&quot;. See https://aka.ms/fsharp-iwsams for guidance. You can disable this warning by using &apos;#nowarn \&quot;3536\&quot;&apos; or &apos;--nowarn:3536&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1718)
</summary>
</member>
<member name="M:FSComp.SR.tcUseYieldBangForMultipleResults">
<summary>
 In sequence expressions, multiple results are generated using &apos;yield!&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:653)
</summary>
</member>
<member name="M:FSComp.SR.tcUseMayNotBeUsedInQueries">
<summary>
 &apos;use&apos; expressions may not be used in queries
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1317)
</summary>
</member>
<member name="M:FSComp.SR.tcUseForInSequenceExpression">
<summary>
 The use of &apos;let! x = coll&apos; in sequence expressions is not permitted. Use &apos;for x in coll&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:651)
</summary>
</member>
<member name="M:FSComp.SR.tcUnsupportedMutRecDecl">
<summary>
 This declaration is not supported in recursive declaration groups
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1386)
</summary>
</member>
<member name="M:FSComp.SR.tcUnsupportedAttribute">
<summary>
 This attribute cannot be used in this version of F#
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:705)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedQueryOperator">
<summary>
 This is not a known query operator. Query operators are identifiers such as &apos;select&apos;, &apos;where&apos;, &apos;sortBy&apos;, &apos;thenBy&apos;, &apos;groupBy&apos;, &apos;groupValBy&apos;, &apos;join&apos;, &apos;groupJoin&apos;, &apos;sumBy&apos; and &apos;averageBy&apos;, defined using corresponding methods on the &apos;QueryBuilder&apos; type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1320)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedQueryBinaryOperator">
<summary>
 Arguments to query operators may require parentheses, e.g. &apos;where (x &gt; y)&apos; or &apos;groupBy (x.Length / 10)&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1328)
</summary>
</member>
<member name="M:FSComp.SR.tcUnrecognizedAttributeTarget">
<summary>
 Unrecognized attribute target. Valid attribute targets are &apos;assembly&apos;, &apos;module&apos;, &apos;type&apos;, &apos;method&apos;, &apos;property&apos;, &apos;return&apos;, &apos;param&apos;, &apos;field&apos;, &apos;event&apos;, &apos;constructor&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:695)
</summary>
</member>
<member name="M:FSComp.SR.tcUnnamedArgumentsDoNotFormPrefix">
<summary>
 The unnamed arguments do not form a prefix of the arguments of the method called
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:672)
</summary>
</member>
<member name="M:FSComp.SR.tcUnknownUnion">
<summary>
 Unknown union case
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:525)
</summary>
</member>
<member name="M:FSComp.SR.tcUnitsOfMeasureInvalidInTypeConstructor">
<summary>
 Unit-of-measure cannot be used in type constructor application
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:562)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseRequiresOneArgument">
<summary>
 This union case takes one argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:581)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseNameConflictsWithGeneratedType(System.String,System.String)">
<summary>
 The union case named &apos;%s&apos; conflicts with the generated type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1112)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseFieldCannotBeUsedMoreThanOnce(System.String)">
<summary>
 Union case/exception field &apos;%s&apos; cannot be used more than once.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1355)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseExpectsTupledArguments(System.Int32,System.Int32,System.String)">
<summary>
 This union case expects %d arguments in tupled form, but was given %d. The missing field arguments may be any of:%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:582)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseDoesNotTakeArguments">
<summary>
 This union case does not take arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:580)
</summary>
</member>
<member name="M:FSComp.SR.tcUnionCaseConstructorDoesNotHaveFieldWithGivenName(System.String,System.String)">
<summary>
 The union case &apos;%s&apos; does not have a field named &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1351)
</summary>
</member>
<member name="M:FSComp.SR.tcUninitializedValFieldsMustBeMutable">
<summary>
 Uninitialized &apos;val&apos; fields must be mutable and marked with the &apos;[&lt;DefaultValue&gt;]&apos; attribute. Consider using a &apos;let&apos; binding instead of a &apos;val&apos; field.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:734)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedTypeArguments">
<summary>
 Unexpected type arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:572)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedSymbolInTypeExpression(System.String)">
<summary>
 Unexpected %s in type expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:566)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedSlashInType">
<summary>
 Unexpected / in type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:571)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedPropertySpec">
<summary>
 Unexpected source-level property specification
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:536)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedPropertyInSyntaxTree">
<summary>
 Unexpected source-level property specification in syntax tree
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:530)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedMeasureAnon">
<summary>
 Unexpected SynMeasure.Anon
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:487)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedFunTypeInUnionCaseField">
<summary>
 Unexpected function type in union case field definition. If you intend the field to be a function, consider wrapping the function signature with parens, e.g. | Case of a -&gt; b into | Case of (a -&gt; b).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1757)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedExprAtRecInfPoint">
<summary>
 Unexpected expression at recursive inference point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:515)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstUint16Array">
<summary>
 Unexpected Const_uint16array
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:492)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConstByteArray">
<summary>
 Unexpected Const_bytearray
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:493)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedConditionInImportedAssembly">
<summary>
 Unexpected condition in imported assembly: failed to decode AttributeUsage attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:694)
</summary>
</member>
<member name="M:FSComp.SR.tcUnexpectedBigRationalConstant">
<summary>
 Unexpected big rational constant
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:490)
</summary>
</member>
<member name="M:FSComp.SR.tcUndefinedField(System.String,System.String)">
<summary>
 The field &apos;%s&apos; has been given a value, but is not present in the type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:618)
</summary>
</member>
<member name="M:FSComp.SR.tcUnableToParseInterpolatedString(System.String)">
<summary>
 Invalid interpolated string. %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1654)
</summary>
</member>
<member name="M:FSComp.SR.tcUnableToParseFormatString(System.String)">
<summary>
 Unable to parse format string &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:596)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesCannotInheritFromMultipleConcreteTypes">
<summary>
 Types cannot inherit from multiple concrete types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:783)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesCannotContainNestedTypes">
<summary>
 Types cannot contain nested type definitions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:764)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedStruct">
<summary>
 Struct types are always sealed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:795)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedRecord">
<summary>
 Record types are always sealed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:793)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedEnum">
<summary>
 Enum types are always sealed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:797)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedDelegate">
<summary>
 Delegate types are always sealed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:796)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedDU">
<summary>
 Discriminated union types are always sealed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:792)
</summary>
</member>
<member name="M:FSComp.SR.tcTypesAreAlwaysSealedAssemblyCode">
<summary>
 Assembly code types are always sealed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:794)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; is used in an invalid way. A value prior to &apos;%s&apos; has an inferred type involving &apos;%s&apos;, which is an invalid forward reference.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:819)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeTestLossy(System.String,System.String)">
<summary>
 This type test or downcast will erase the provided type &apos;%s&apos; to the type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1228)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeTestLosesMeasures(System.String)">
<summary>
 This type test or downcast will ignore the unit-of-measure &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1123)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeTestErased(System.String,System.String)">
<summary>
 This type test with a provided type &apos;%s&apos; is not allowed because this provided type will be erased to &apos;%s&apos; at runtime.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1230)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeRequiresDefinition">
<summary>
 This type requires a definition
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:780)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParametersInferredAreNotStable">
<summary>
 The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt&lt;&apos;a&gt; = int or\n\ttype swap&lt;&apos;a,&apos;b&gt; = &apos;b * &apos;a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f&lt;&apos;a,&apos;b&gt; ((x,y) : swap&lt;&apos;b,&apos;a&gt;) : swap&lt;&apos;a,&apos;b&gt; = (y,x).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:520)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterInvalidAsTypeConstructor">
<summary>
 Type parameter cannot be used as type constructor
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:567)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterHasBeenConstrained(System.String)">
<summary>
 This type parameter has been used in a way that constrains it to always be &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:519)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeParameterArityMismatch(System.Int32,System.Int32)">
<summary>
 This value, type or method expects %d type parameter(s) but was given %d
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:542)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeOrModule">
<summary>
 type or module
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:766)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotInterfaceType1(System.String)">
<summary>
 The type &apos;%s&apos; is not an interface type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:741)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotInterfaceType0">
<summary>
 This type is not an interface type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:759)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotARecordTypeNeedConstructor">
<summary>
 This type is not a record type. Values of class and struct types must be created using calls to object constructors.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:646)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsNotARecordType">
<summary>
 This type is not a record type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:647)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeIsInaccessible">
<summary>
 This type is not accessible from this code location
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:693)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeHasNoNestedTypes">
<summary>
 This type has no nested types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:565)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeHasNoAccessibleConstructor">
<summary>
 This type has no accessible object constructors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:656)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeExceptionOrModule">
<summary>
 type, exception or module
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:765)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDoesNotInheritAttribute">
<summary>
 This type does not inherit Attribute, it will not work correctly with other .NET languages.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1519)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDoesNotHaveAnyNull(System.String)">
<summary>
 The type &apos;%s&apos; does not support a nullness qualification.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1528)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit">
<summary>
 Type definitions may only have one &apos;inherit&apos; specification and it must be the first declaration
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:812)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers">
<summary>
 &apos;let&apos; and &apos;do&apos; bindings must come before member and interface definitions in type definitions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:813)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionIsCyclicThroughInheritance">
<summary>
 This type definition involves an immediate cyclic reference through a struct field or inheritance relation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:808)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeDefinitionIsCyclic">
<summary>
 This type definition involves an immediate cyclic reference through an abbreviation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:807)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeCastErased(System.String,System.String)">
<summary>
 This downcast will erase the provided type &apos;%s&apos; to the type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1229)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeCannotBeEnumerated(System.String)">
<summary>
 The type &apos;%s&apos; is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq&lt;_&gt;, IEnumerable&lt;_&gt; or IEnumerable and does not have a GetEnumerator method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:549)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsMayNotHaveMembers">
<summary>
 Type abbreviations cannot have members
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:748)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCheckedAtCompileTime">
<summary>
 As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:749)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCannotHaveInterfaceDeclaration">
<summary>
 Type abbreviations cannot have interface declarations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:757)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationsCannotHaveAugmentations">
<summary>
 Type abbreviations cannot have augmentations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:817)
</summary>
</member>
<member name="M:FSComp.SR.tcTypeAbbreviationHasTypeParametersMissingOnType">
<summary>
 This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as &apos;type C&lt;&apos;a&gt; = C of ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:781)
</summary>
</member>
<member name="M:FSComp.SR.tcTupleStructMismatch">
<summary>
 One tuple type is a struct tuple, the other is a reference tuple
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1379)
</summary>
</member>
<member name="M:FSComp.SR.tcTupleMemberNotNormallyUsed">
<summary>
 This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1499)
</summary>
</member>
<member name="M:FSComp.SR.tcTryWithMayNotBeUsedInQueries">
<summary>
 &apos;try/with&apos; expressions may not be used in queries
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1321)
</summary>
</member>
<member name="M:FSComp.SR.tcTryIllegalInSequenceExpression">
<summary>
 &apos;try&apos;/&apos;with&apos; cannot be used within sequence expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:652)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitMayNotUseComplexThings">
<summary>
 A trait may not specify optional, in, out, ParamArray, CallerInfo or Quote arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1714)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitIsStatic(System.String)">
<summary>
 Trait &apos;%s&apos; is static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1712)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitIsNotStatic(System.String)">
<summary>
 Trait &apos;%s&apos; is not static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1713)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitInvocationShouldUseTick">
<summary>
 Invocation of a static constraint should use \&quot;&apos;T.Ident\&quot; and not \&quot;^T.Ident\&quot;, even for statically resolved type parameters.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1716)
</summary>
</member>
<member name="M:FSComp.SR.tcTraitHasMultipleSupportTypes(System.String)">
<summary>
 The trait &apos;%s&apos; invoked by this call has multiple support types. This invocation syntax is not permitted for such traits. See https://aka.ms/fsharp-srtp for guidance.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1719)
</summary>
</member>
<member name="M:FSComp.SR.tcThreadStaticAndContextStaticMustBeStatic">
<summary>
 Thread-static and context-static variables must be static and given the [&lt;DefaultValue&gt;] attribute to indicate that the value is initialized to the default value on each new thread
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:732)
</summary>
</member>
<member name="M:FSComp.SR.tcThisValueMayNotBeInlined">
<summary>
 This member, function or value declaration may not be declared &apos;inline&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1326)
</summary>
</member>
<member name="M:FSComp.SR.tcThisTypeMayNotHaveACLIMutableAttribute">
<summary>
 This type definition may not have the &apos;CLIMutable&apos; attribute. Only record types may have this attribute.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1308)
</summary>
</member>
<member name="M:FSComp.SR.tcTPFieldMustBeLiteral">
<summary>
 Invalid provided field. Provided fields of erased provided types must be literals.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1337)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields">
<summary>
 The syntax &apos;expr.id&apos; may only be used with record labels, properties and fields
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:667)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxErrorUnexpectedQMark">
<summary>
 Syntax error - unexpected &apos;?&apos; symbol
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:588)
</summary>
</member>
<member name="M:FSComp.SR.tcSyntaxCanOnlyBeUsedToCreateObjectTypes(System.String)">
<summary>
 &apos;%s&apos; may only be used to construct object types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:616)
</summary>
</member>
<member name="M:FSComp.SR.tcSynTypeOrInvalidInDeclaration">
<summary>
 SynType.Or is not permitted in this declaration
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1724)
</summary>
</member>
<member name="M:FSComp.SR.tcSubsumptionImplicitConversionUsed(System.String,System.String)">
<summary>
 This expression implicitly converts type &apos;%s&apos; to type &apos;%s&apos;. See https://aka.ms/fsharp-implicit-convs.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1667)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralEqualityNotSatisfied2(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralEquality&apos; attribute but the component type &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1068)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralEqualityNotSatisfied1(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralEquality&apos; attribute but the type parameter &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;equality&apos; constraint to the type parameter
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1067)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralComparisonNotSatisfied2(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralComparison&apos; attribute but the component type &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1062)
</summary>
</member>
<member name="M:FSComp.SR.tcStructuralComparisonNotSatisfied1(System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; has the &apos;StructuralComparison&apos; attribute but the type parameter &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;comparison&apos; constraint to the type parameter
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1061)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly">
<summary>
 Each argument of the primary constructor for a struct must be given a type, for example &apos;type S(x1:int, x2: int) = ...&apos;. These arguments determine the fields of the struct.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1069)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMayNotContainLetBindings">
<summary>
 Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:753)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsMayNotContainDoBindings">
<summary>
 Structs cannot contain &apos;do&apos; bindings because the default constructor for structs would not execute these bindings
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:752)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes">
<summary>
 Structs, interfaces, enums and delegates cannot inherit from other types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:782)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsCannotHaveConstructorWithNoArguments">
<summary>
 Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:724)
</summary>
</member>
<member name="M:FSComp.SR.tcStructsCanOnlyBindThisAtMemberDeclaration">
<summary>
 Structs may only bind a &apos;this&apos; parameter at member declarations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:514)
</summary>
</member>
<member name="M:FSComp.SR.tcStructUnionMultiCaseFieldsSameType">
<summary>
 If a multicase union type is a struct, then all fields with the same name must be of the same type. This rule applies also to the generated &apos;Item&apos; name in case of unnamed fields.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1762)
</summary>
</member>
<member name="M:FSComp.SR.tcStructUnionMultiCaseDistinctFields">
<summary>
 If a multicase union type is a struct, then all union cases must have unique names. For example: &apos;type A = B of b: int | C of c: int&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1388)
</summary>
</member>
<member name="M:FSComp.SR.tcStructTypesCannotContainAbstractMembers">
<summary>
 Struct types cannot contain abstract members
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:802)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticValFieldsMustBeMutableAndPrivate">
<summary>
 Static &apos;val&apos; fields in types must be mutable, private and marked with the &apos;[&lt;DefaultValue&gt;]&apos; attribute. They are initialized to the &apos;null&apos; or &apos;zero&apos; value for their type. Consider also using a &apos;static let mutable&apos; binding in a class type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:735)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticOptimizationConditionalsOnlyForFSharpLibrary">
<summary>
 Static optimization conditionals are only for use within the F# library
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:673)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticMemberShouldNotHaveThis">
<summary>
 This static member should not have a &apos;this&apos; parameter. Consider using the notation &apos;member Member(args) = ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:533)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticLetBindingsRequireClassesWithImplicitConstructors">
<summary>
 For F#7 and lower, static &apos;let&apos;,&apos;do&apos; and &apos;member val&apos; definitions may only be used in types with a primary constructor (&apos;type X(args) = ...&apos;). To enable them in all other types, use language version &apos;8&apos; or higher.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:754)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticInitializersIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of static initializers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:719)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticInitializerRequiresArgument">
<summary>
 A static initializer requires an argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:531)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticFieldUsedWhenInstanceFieldExpected">
<summary>
 A static field was used where an instance field is expected
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:484)
</summary>
</member>
<member name="M:FSComp.SR.tcStaticBindingInExtrinsicAugmentation">
<summary>
 Static bindings cannot be added to extrinsic augmentations. Consider using a &apos;static member&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1751)
</summary>
</member>
<member name="M:FSComp.SR.tcSimpleMethodNameRequired">
<summary>
 A simple method name is required here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:626)
</summary>
</member>
<member name="M:FSComp.SR.tcSetterForInitOnlyPropertyCannotBeCalled1(System.String)">
<summary>
 Cannot call &apos;%s&apos; - a setter for init-only property, please use object initialization instead. See https://aka.ms/fsharp-assigning-values-to-properties-at-initialization
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:665)
</summary>
</member>
<member name="M:FSComp.SR.tcSeqResultsUseYield">
<summary>
 In sequence expressions, results are generated using &apos;yield&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:489)
</summary>
</member>
<member name="M:FSComp.SR.tcRuntimeSuppliedMethodCannotBeUsedInUserCode(System.String)">
<summary>
 Array method &apos;%s&apos; is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1350)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnValuesCannotHaveNames">
<summary>
 Return values cannot have names
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:495)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnTypesForUnionMustBeSameAsType">
<summary>
 Return types of union cases must be identical to the type being defined, up to abbreviations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:739)
</summary>
</member>
<member name="M:FSComp.SR.tcReturnMayNotBeUsedInQueries">
<summary>
 &apos;return&apos; and &apos;return!&apos; may not be used in queries
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1319)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeNotSupported">
<summary>
 Using resumable code or resumable state machines requires /langversion:preview
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1688)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeInvocation">
<summary>
 Resumable code invocation. Suppress this warning if you are defining new low-level resumable code in terms of existing resumable code.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1692)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeFunctionMustBeInline">
<summary>
 Invalid resumable code. Any method of function accepting or returning resumable code must be marked &apos;inline&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1684)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeContainsLetRec">
<summary>
 Invalid resumable code. A &apos;let rec&apos; occurred in the resumable code specification
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1687)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeArgMustHaveRightName">
<summary>
 Invalid resumable code. Resumable code parameter must have name beginning with &apos;__expand&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1685)
</summary>
</member>
<member name="M:FSComp.SR.tcResumableCodeArgMustHaveRightKind">
<summary>
 Invalid resumable code. A resumable code parameter must be of delegate or function type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1686)
</summary>
</member>
<member name="M:FSComp.SR.tcReservedSyntaxForAugmentation">
<summary>
 The syntax &apos;type X with ...&apos; is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using &apos;type X = ...&apos;. You may also need to add the &apos;[&lt;Sealed&gt;] attribute to the type definition in the signature
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:809)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireVarConstRecogOrLiteral">
<summary>
 This is not a variable, constant, active recognizer or literal
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:585)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireMergeSourcesOrBindN(System.String)">
<summary>
 The &apos;let! ... and! ...&apos; construct may only be used if the computation expression builder defines either a &apos;%s&apos; method or appropriate &apos;MergeSources&apos; and &apos;Bind&apos; methods
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1549)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireBuilderMethod(System.String)">
<summary>
 This control construct may only be used if the computation expression builder defines a &apos;%s&apos; method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:563)
</summary>
</member>
<member name="M:FSComp.SR.tcRequireActivePatternWithOneResult">
<summary>
 Only active patterns returning exactly one result may accept arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:577)
</summary>
</member>
<member name="M:FSComp.SR.tcRepresentationOfTypeHiddenBySignature">
<summary>
 The representation of this type is hidden by the signature. It must be given an attribute such as [&lt;Sealed&gt;], [&lt;Class&gt;] or [&lt;Interface&gt;] to indicate the characteristics of the type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:788)
</summary>
</member>
<member name="M:FSComp.SR.tcRecursiveBindingsWithMembersMustBeDirectAugmentation">
<summary>
 Recursive bindings that include member specifications can only occur as a direct augmentation of a type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:726)
</summary>
</member>
<member name="M:FSComp.SR.tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute">
<summary>
 Records, union, abbreviations and struct types cannot have the &apos;AllowNullLiteral&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:784)
</summary>
</member>
<member name="M:FSComp.SR.tcRecordFieldInconsistentTypes">
<summary>
 This record contains fields from inconsistent types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:512)
</summary>
</member>
<member name="M:FSComp.SR.tcRecImplied">
<summary>
 The &apos;rec&apos; on this module is implied by an outer &apos;rec&apos; declaration and is being ignored
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1383)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyRequiresExplicitTypeParameters">
<summary>
 A property cannot have explicit type parameters. Consider using a method instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:527)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyOrFieldNotFoundInAttribute">
<summary>
 This property or field was not found on this custom attribute type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:700)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsStatic(System.String)">
<summary>
 Property &apos;%s&apos; is static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:662)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsNotStatic(System.String)">
<summary>
 Property &apos;%s&apos; is not static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:659)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyIsNotReadable(System.String)">
<summary>
 Property &apos;%s&apos; is not readable
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:660)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyCannotBeSet1(System.String)">
<summary>
 Property &apos;%s&apos; cannot be set
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:663)
</summary>
</member>
<member name="M:FSComp.SR.tcPropertyCannotBeSet0">
<summary>
 This property cannot be set
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:699)
</summary>
</member>
<member name="M:FSComp.SR.tcPredefinedTypeCannotBeUsedAsSuperType">
<summary>
 The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:627)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullTononNullFunction">
<summary>
 You can remove this `nonNull` assertion.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1538)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToValueOptionOfObj">
<summary>
 You can create &apos;ValueSome value&apos; directly instead of &apos;ofObj&apos;, or consider not using a voption for this value.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1535)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToOptionOfObj">
<summary>
 You can create &apos;Some value&apos; directly instead of &apos;ofObj&apos;, or consider not using an option for this value.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1534)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToNonNullQuickAP">
<summary>
 You can remove this |NonNullQuick| pattern usage.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1537)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToNonNullAP">
<summary>
 You can remove this |Null|NonNull| pattern usage.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1536)
</summary>
</member>
<member name="M:FSComp.SR.tcPassingWithoutNullToANullableExpectingFunc(System.String)">
<summary>
 Value known to be without null passed to a function meant for nullables: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1533)
</summary>
</member>
<member name="M:FSComp.SR.tcPartialActivePattern">
<summary>
 Multi-case partial active patterns are not supported. Consider using a single-case partial active pattern or a full active pattern.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1786)
</summary>
</member>
<member name="M:FSComp.SR.tcParenThenAdjacentListArgumentReserved">
<summary>
 The syntax &apos;(expr1)[expr2]&apos; is now reserved for indexing and is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction (expr1) [expr2]&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1636)
</summary>
</member>
<member name="M:FSComp.SR.tcParenThenAdjacentListArgumentNeedsAdjustment">
<summary>
 The syntax &apos;(expr1)[expr2]&apos; is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If you intend indexing or slicing then you must use &apos;(expr1).[expr2]&apos; in argument position. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction (expr1) [expr2]&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1639)
</summary>
</member>
<member name="M:FSComp.SR.tcParameterRequiresName">
<summary>
 A parameter with attributes must also be given a name, e.g. &apos;[&lt;Attribute&gt;] Name : Type&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:494)
</summary>
</member>
<member name="M:FSComp.SR.tcParameterInferredByref(System.String)">
<summary>
 The parameter &apos;%s&apos; was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. &apos;x1: byref&lt;int&gt;&apos;. When used, a byref parameter is implicitly dereferenced.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1084)
</summary>
</member>
<member name="M:FSComp.SR.tcOverridingMethodRequiresAllOrNoTypeParameters">
<summary>
 You must explicitly declare either all or no type parameters when overriding a generic abstract method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:522)
</summary>
</member>
<member name="M:FSComp.SR.tcOverridesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on overrides or interface implementations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:791)
</summary>
</member>
<member name="M:FSComp.SR.tcOverrideUsesMultipleArgumentsInsteadOfTuple">
<summary>
 This override takes a tuple instead of multiple arguments. Try to add an additional layer of parentheses at the method definition (e.g. &apos;member _.Foo((x, y))&apos;), or remove parentheses at the abstract method declaration (e.g. &apos;abstract member Foo: &apos;a * &apos;b -&gt; &apos;c&apos;).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1753)
</summary>
</member>
<member name="M:FSComp.SR.tcOverrideArityMismatch(System.String)">
<summary>
 This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:711)
</summary>
</member>
<member name="M:FSComp.SR.tcOverloadsCannotHaveCurriedArguments">
<summary>
 One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:671)
</summary>
</member>
<member name="M:FSComp.SR.tcOtherThenAdjacentListArgumentReserved">
<summary>
 The syntax &apos;expr1[expr2]&apos; is now reserved for indexing and is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction expr1 [expr2]&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1638)
</summary>
</member>
<member name="M:FSComp.SR.tcOtherThenAdjacentListArgumentNeedsAdjustment">
<summary>
 The syntax &apos;expr1[expr2]&apos; is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If you intend indexing or slicing then you must use &apos;expr1.[expr2]&apos; in argument position. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction expr1 [expr2]&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1641)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgumentsCannotBeUsedInCustomAttribute">
<summary>
 Optional arguments cannot be used in custom attributes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:698)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgsOnlyOnMembers">
<summary>
 Optional arguments are only permitted on type members
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:573)
</summary>
</member>
<member name="M:FSComp.SR.tcOptionalArgsMustComeAfterNonOptionalArgs">
<summary>
 Optional arguments must come at the end of the argument list, after any non-optional arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1109)
</summary>
</member>
<member name="M:FSComp.SR.tcOperatorRequiresIn(System.String,System.String)">
<summary>
 &apos;%s&apos; must be followed by &apos;in&apos;. Usage: %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1344)
</summary>
</member>
<member name="M:FSComp.SR.tcOperatorIncorrectSyntax(System.String,System.String)">
<summary>
 Incorrect syntax for &apos;%s&apos;. Usage: %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1272)
</summary>
</member>
<member name="M:FSComp.SR.tcOperatorDoesntAcceptInto(System.String)">
<summary>
 The operator &apos;%s&apos; does not accept the use of &apos;into&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1306)
</summary>
</member>
<member name="M:FSComp.SR.tcOpenUsedWithPartiallyQualifiedPath(System.String)">
<summary>
 This declaration opens the namespace or module &apos;%s&apos; through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:746)
</summary>
</member>
<member name="M:FSComp.SR.tcOpenFirstInMutRec">
<summary>
 In a recursive declaration group, &apos;open&apos; declarations must come first in each module
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1384)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure">
<summary>
 Only types representing units-of-measure may be given the &apos;Measure&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:790)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyStructsCanHaveStructLayout">
<summary>
 Only structs and classes without primary constructors may be given the &apos;StructLayout&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:787)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlySimplePatternsInLetRec">
<summary>
 Only simple variable patterns can be bound in &apos;let rec&apos; constructs
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:727)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlySimpleBindingsCanBeUsedInConstructionExpressions">
<summary>
 Only simple bindings of the form &apos;id = expr&apos; can be used in construction expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:633)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyRecordFieldsAndSimpleLetCanBeMutable">
<summary>
 Mutable &apos;let&apos; bindings can&apos;t be recursive or defined in recursive modules or namespaces
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:728)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyFunctionsCanBeInline">
<summary>
 Only functions may be marked &apos;inline&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:687)
</summary>
</member>
<member name="M:FSComp.SR.tcOnlyClassesCanHaveAbstract">
<summary>
 Only classes may be given the &apos;AbstractClass&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:789)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectsMustBeInitializedWithObjectExpression">
<summary>
 Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:634)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectOfIndeterminateTypeUsedRequireTypeConstraint">
<summary>
 The operator &apos;expr.[idx]&apos; has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:607)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual">
<summary>
 Only overrides of abstract and virtual members may be specified in object expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:621)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectExpressionFormDeprecated">
<summary>
 This form of object expression is not used in F#. Use &apos;member this.MemberName ... = ...&apos; to define member implementations in object expressions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:537)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorsOnTypeParametersCannotTakeArguments">
<summary>
 Calls to object constructors on type parameters cannot be given arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:609)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorsIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of object constructors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:720)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructorRequiresArgument">
<summary>
 An object constructor requires an argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:532)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes">
<summary>
 Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use &apos;new ObjectType(args)&apos; to construct instances of object model types outside of constructors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:644)
</summary>
</member>
<member name="M:FSComp.SR.tcObjectConstructionCanOnlyBeUsedInClassTypes">
<summary>
 Object construction expressions may only be used to implement constructors in class types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:632)
</summary>
</member>
<member name="M:FSComp.SR.tcNumericLiteralRequiresModule(System.String)">
<summary>
 This numeric literal requires that a module &apos;%s&apos; defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:640)
</summary>
</member>
<member name="M:FSComp.SR.tcNullnessCheckingNotEnabled">
<summary>
 The &apos;nullness checking&apos; language feature is not enabled. This use of a nullness checking construct will be ignored.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1541)
</summary>
</member>
<member name="M:FSComp.SR.tcNullableToStringOverride">
<summary>
 With nullness checking enabled, overrides of .ToString() method must return a non-nullable string. You can handle potential nulls via the built-in string function.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1539)
</summary>
</member>
<member name="M:FSComp.SR.tcNotValidEnumCaseName">
<summary>
 This is not a valid name for an enumeration case
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:600)
</summary>
</member>
<member name="M:FSComp.SR.tcNotSufficientlyGenericBecauseOfScope(System.String)">
<summary>
 This code is not sufficiently generic. The type variable %s could not be generalized because it would escape its scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:526)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAnIndexerNamedIndexingNotYetEnabled(System.String)">
<summary>
 The value &apos;%s&apos; is not a function and does not support index notation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1625)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAnIndexerIndexingNotYetEnabled">
<summary>
 This expression is not a function and does not support index notation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1626)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAnException">
<summary>
 Not an exception
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:774)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAFunctionButIndexerNamedIndexingNotYetEnabled(System.String,System.String)">
<summary>
 This value supports indexing, e.g. &apos;%s.[index]&apos;. The syntax &apos;%s[index]&apos; requires /langversion:preview. See https://aka.ms/fsharp-index-notation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1623)
</summary>
</member>
<member name="M:FSComp.SR.tcNotAFunctionButIndexerIndexingNotYetEnabled">
<summary>
 This expression supports indexing, e.g. &apos;expr.[index]&apos;. The syntax &apos;expr[index]&apos; requires /langversion:preview. See https://aka.ms/fsharp-index-notation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1624)
</summary>
</member>
<member name="M:FSComp.SR.tcNonZeroConstantCannotHaveGenericUnit">
<summary>
 Non-zero constants cannot have generic units. For generic zero, write 0.0&lt;_&gt;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:488)
</summary>
</member>
<member name="M:FSComp.SR.tcNonUniformMemberUse(System.String)">
<summary>
 The generic member &apos;%s&apos; has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1085)
</summary>
</member>
<member name="M:FSComp.SR.tcNonSimpleLetBindingInQuery">
<summary>
 This &apos;let&apos; definition may not be used in a query. Only simple value definitions may be used in queries.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1322)
</summary>
</member>
<member name="M:FSComp.SR.tcNonLiteralCannotBeUsedInPattern">
<summary>
 This value is not a literal and cannot be used in a pattern
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:545)
</summary>
</member>
<member name="M:FSComp.SR.tcNoWhileInQuery">
<summary>
 &apos;while&apos; expressions may not be used in queries
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1315)
</summary>
</member>
<member name="M:FSComp.SR.tcNoTryFinallyInQuery">
<summary>
 &apos;try/finally&apos; expressions may not be used in queries
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1316)
</summary>
</member>
<member name="M:FSComp.SR.tcNoStaticPropertyFoundForOverride">
<summary>
 No static abstract property was found that corresponds to this override
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1765)
</summary>
</member>
<member name="M:FSComp.SR.tcNoStaticMemberFoundForOverride">
<summary>
 No static abstract member was found that corresponds to this override
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1764)
</summary>
</member>
<member name="M:FSComp.SR.tcNoPropertyFoundForOverride">
<summary>
 No abstract property was found that corresponds to this override
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:714)
</summary>
</member>
<member name="M:FSComp.SR.tcNoMemberFoundForOverride">
<summary>
 No abstract or interface member was found that corresponds to this override
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:710)
</summary>
</member>
<member name="M:FSComp.SR.tcNoInterfaceImplementationForConstructionExpression">
<summary>
 Interface implementations cannot be given on construction expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:631)
</summary>
</member>
<member name="M:FSComp.SR.tcNoIntegerForLoopInQuery">
<summary>
 In queries, use the form &apos;for x in n .. m do ...&apos; for ranging over integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1314)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEqualityNeeded2(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; does not support structural equality because the type &apos;%s&apos; does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;NoEquality&apos; attribute to the type &apos;%s&apos; to clarify that the type does not support structural equality
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1066)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEqualityNeeded1(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; does not support structural equality because the type parameter %s does not satisfy the &apos;equality&apos; constraint. Consider adding the &apos;NoEquality&apos; attribute to the type &apos;%s&apos; to clarify that the type does not support structural equality
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1065)
</summary>
</member>
<member name="M:FSComp.SR.tcNoEagerConstraintApplicationAttribute">
<summary>
 Using methods with &apos;NoEagerConstraintApplicationAttribute&apos; requires /langversion:6.0 or later
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1689)
</summary>
</member>
<member name="M:FSComp.SR.tcNoComparisonNeeded2(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; is not structurally comparable because the type &apos;%s&apos; does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;NoComparison&apos; attribute to the type &apos;%s&apos; to clarify that the type is not comparable
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1064)
</summary>
</member>
<member name="M:FSComp.SR.tcNoComparisonNeeded1(System.String,System.String,System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; is not structurally comparable because the type parameter %s does not satisfy the &apos;comparison&apos; constraint. Consider adding the &apos;NoComparison&apos; attribute to the type &apos;%s&apos; to clarify that the type is not comparable
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1063)
</summary>
</member>
<member name="M:FSComp.SR.tcNoArgumentsForRecordValue">
<summary>
 No arguments may be given when constructing a record value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:630)
</summary>
</member>
<member name="M:FSComp.SR.tcNoAbstractOrVirtualMemberFound(System.String)">
<summary>
 The member &apos;%s&apos; does not correspond to any abstract or virtual method available to override or implement.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:622)
</summary>
</member>
<member name="M:FSComp.SR.tcNewRequiresObjectConstructor">
<summary>
 &apos;new&apos; may only be used with object constructors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:638)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMustBeUsedWithNamedType">
<summary>
 &apos;new&apos; must be used with a named type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:628)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMemberHidesAbstractMemberWithSuffix(System.String)">
<summary>
 This new member hides the abstract member &apos;%s&apos; once tuples, functions, units of measure and/or provided types are erased. Rename the member or use &apos;override&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:718)
</summary>
</member>
<member name="M:FSComp.SR.tcNewMemberHidesAbstractMember(System.String)">
<summary>
 This new member hides the abstract member &apos;%s&apos;. Rename the member or use &apos;override&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:717)
</summary>
</member>
<member name="M:FSComp.SR.tcNewCannotBeUsedOnInterfaceType">
<summary>
 &apos;new&apos; cannot be used on interface types. Consider using an object expression &apos;{ new ... with ... }&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:613)
</summary>
</member>
<member name="M:FSComp.SR.tcNamespaceCannotContainValues">
<summary>
 Namespaces cannot contain values. Consider using a module to hold your value declarations.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:41)
</summary>
</member>
<member name="M:FSComp.SR.tcNamespaceCannotContainExtensionMembers">
<summary>
 Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:497)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedTypeRequired(System.String)">
<summary>
 &apos;%s&apos; may only be used with named types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:611)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedArgumentsCannotBeUsedInMemberTraits">
<summary>
 Named arguments cannot be given to member trait calls
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:599)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedArgumentDidNotMatch(System.String)">
<summary>
 The named argument &apos;%s&apos; did not match any argument or mutable property
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:670)
</summary>
</member>
<member name="M:FSComp.SR.tcNamedActivePattern(System.String)">
<summary>
 %s is an active pattern and cannot be treated as a discriminated union case with named fields.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1393)
</summary>
</member>
<member name="M:FSComp.SR.tcNameNotBoundInPattern(System.String)">
<summary>
 Name &apos;%s&apos; not bound in pattern context
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:574)
</summary>
</member>
<member name="M:FSComp.SR.tcNameArgumentsMustAppearLast">
<summary>
 Named arguments must appear after all other arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:547)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesSyntax">
<summary>
 Mutable function values should be written &apos;let mutable f = (fun args -&gt; ...)&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:686)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesMayNotHaveGenericParameters">
<summary>
 Mutable values cannot have generic parameters
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:685)
</summary>
</member>
<member name="M:FSComp.SR.tcMutableValuesCannotBeInline">
<summary>
 Mutable values cannot be marked &apos;inline&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:684)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleVisibilityAttributesWithLet">
<summary>
 Multiple visibility attributes have been specified for this identifier. &apos;let&apos; bindings in classes are always private, as are any &apos;let&apos; bindings inside expressions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:499)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleVisibilityAttributes">
<summary>
 Multiple visibility attributes have been specified for this identifier
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:498)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleRecdTypeChoice(System.String,System.String,System.String)">
<summary>
 Multiple type matches were found:\n%s\nThe type &apos;%s&apos; was used. Due to the overlapping field names\n%s\nconsider using type annotations or change the order of open statements.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1744)
</summary>
</member>
<member name="M:FSComp.SR.tcMultipleFieldsInRecord(System.String)">
<summary>
 The field &apos;%s&apos; appears multiple times in this record expression or pattern
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:524)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleRequiresQualifiedAccess(System.String)">
<summary>
 This declaration opens the module &apos;%s&apos;, which is marked as &apos;RequireQualifiedAccess&apos;. Adjust your code to use qualified references to the elements of the module instead, e.g. &apos;List.map&apos; instead of &apos;map&apos;. This change will ensure that your code is robust as new constructs are added to libraries.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:745)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleAbbreviationForNamespace(System.String)">
<summary>
 The path &apos;%s&apos; is a namespace. A module abbreviation may not abbreviate a namespace.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:818)
</summary>
</member>
<member name="M:FSComp.SR.tcModuleAbbrevFirstInMutRec">
<summary>
 In a recursive declaration group, module abbreviations must come after all &apos;open&apos; declarations and before other declarations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1385)
</summary>
</member>
<member name="M:FSComp.SR.tcMissingRequiredMembers(System.String)">
<summary>
 The following required properties have to be initialized:%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1720)
</summary>
</member>
<member name="M:FSComp.SR.tcMissingCustomOperation(System.String)">
<summary>
 A custom query operation for &apos;%s&apos; is required but not specified
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1242)
</summary>
</member>
<member name="M:FSComp.SR.tcMethodOverridesIllegalHere">
<summary>
 Method overrides and interface implementations are not permitted here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:709)
</summary>
</member>
<member name="M:FSComp.SR.tcMethodNotAccessible(System.String)">
<summary>
 Method &apos;%s&apos; is not accessible from this code location
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:485)
</summary>
</member>
<member name="M:FSComp.SR.tcMembersThatExtendInterfaceMustBePlacedInSeparateModule">
<summary>
 Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:810)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; is used in an invalid way. A use of &apos;%s&apos; has been inferred prior to the definition of &apos;%s&apos;, which is an invalid forward reference.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:820)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberOverridesIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of member overrides
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:721)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberOperatorDefinitionInExtrinsic">
<summary>
 Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1111)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberNotPermittedInInterfaceImplementation">
<summary>
 This member is not permitted in an interface implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:762)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberKindPropertyGetSetNotExpected">
<summary>
 SynMemberKind.PropertyGetSet only expected in parse trees
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:496)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberIsNotSufficientlyGeneric">
<summary>
 This member is not sufficiently generic
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:729)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberFoundIsNotAbstractOrVirtual(System.String,System.String)">
<summary>
 The type %s contains the member &apos;%s&apos; but it is not a virtual or abstract method that is available to override or implement.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:623)
</summary>
</member>
<member name="M:FSComp.SR.tcMemberAndLocalClassBindingHaveSameName(System.String)">
<summary>
 A member and a local class binding both have the name &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:756)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDefinitionsCannotHaveTypeParameters">
<summary>
 Measure definitions cannot have type parameters
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:779)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDeclarationsRequireStaticMembersNotConstructors">
<summary>
 Measure declarations may have only static members: constructors are not available
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:755)
</summary>
</member>
<member name="M:FSComp.SR.tcMeasureDeclarationsRequireStaticMembers">
<summary>
 Measure declarations may have only static members
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:751)
</summary>
</member>
<member name="M:FSComp.SR.tcMatchMayNotBeUsedWithQuery">
<summary>
 &apos;match&apos; expressions may not be used in queries
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1341)
</summary>
</member>
<member name="M:FSComp.SR.tcLookupMayNotBeUsedHere">
<summary>
 This lookup cannot be used here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:661)
</summary>
</member>
<member name="M:FSComp.SR.tcLocalClassBindingsCannotBeInline">
<summary>
 Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:747)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralFieldAssignmentWithArg(System.String)">
<summary>
 Cannot assign &apos;%s&apos; to a value marked literal
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1630)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralFieldAssignmentNoArg">
<summary>
 Cannot assign a value to another value marked literal
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1631)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralDoesNotTakeArguments">
<summary>
 This literal pattern does not take arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1373)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotHaveGenericParameters">
<summary>
 Literal values cannot have generic parameters
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:691)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotBeMutable">
<summary>
 A literal value cannot be marked &apos;mutable&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:689)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralCannotBeInline">
<summary>
 A literal value cannot be marked &apos;inline&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:690)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralAttributeRequiresConstantValue">
<summary>
 A declaration may only be the [&lt;Literal&gt;] attribute if a constant value is also given, e.g. &apos;val x: int = 1&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:730)
</summary>
</member>
<member name="M:FSComp.SR.tcLiteralAttributeCannotUseActivePattern">
<summary>
 A [&lt;Literal&gt;] declaration cannot use an active pattern for its identifier
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1681)
</summary>
</member>
<member name="M:FSComp.SR.tcListThenAdjacentListArgumentReserved">
<summary>
 The syntax &apos;[expr1][expr2]&apos; is now reserved for indexing and is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction [expr1] [expr2]&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1637)
</summary>
</member>
<member name="M:FSComp.SR.tcListThenAdjacentListArgumentNeedsAdjustment">
<summary>
 The syntax &apos;[expr1][expr2]&apos; is ambiguous when used as an argument. See https://aka.ms/fsharp-index-notation. If you intend indexing or slicing then you must use &apos;(expr1).[expr2]&apos; in argument position. If calling a function with multiple curried arguments, add a space between them, e.g. &apos;someFunction [expr1] [expr2]&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1640)
</summary>
</member>
<member name="M:FSComp.SR.tcListLiteralMaxSize">
<summary>
 This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:597)
</summary>
</member>
<member name="M:FSComp.SR.tcLetAndDoRequiresImplicitConstructionSequence">
<summary>
 This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:816)
</summary>
</member>
<member name="M:FSComp.SR.tcLessGenericBecauseOfAnnotation(System.String,System.String)">
<summary>
 This code is less generic than required by its annotations because the explicit type variable &apos;%s&apos; could not be generalized. It was constrained to be &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:516)
</summary>
</member>
<member name="M:FSComp.SR.tcKindOfTypeSpecifiedDoesNotMatchDefinition">
<summary>
 The kind of the type specified by its attributes does not match the kind implied by its definition
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:778)
</summary>
</member>
<member name="M:FSComp.SR.tcJoinMustUseSimplePattern(System.String)">
<summary>
 In queries, &apos;%s&apos; must use a simple pattern
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1241)
</summary>
</member>
<member name="M:FSComp.SR.tcIsReadOnlyNotStruct">
<summary>
 A type annotated with IsReadOnly must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1510)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfTypeName">
<summary>
 Invalid use of a type name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:655)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfReverseIndex">
<summary>
 Invalid use of reverse index in list expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1632)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfInterfaceType">
<summary>
 Invalid use of an interface type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:657)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseOfDelegate">
<summary>
 Invalid use of a delegate constructor. Use the syntax &apos;new Type(args)&apos; or just &apos;Type(args)&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:658)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseNullAsTrueValue">
<summary>
 The &apos;UseNullAsTrueValue&apos; attribute flag may only be used with union types that have one nullary case and at least one non-nullary case
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1083)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseBinding">
<summary>
 &apos;use&apos; bindings must be of the form &apos;use &lt;var&gt; = &lt;expr&gt;&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:707)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseBangBindingNoAndBangs">
<summary>
 use! may not be combined with and!
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1551)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUseBangBinding">
<summary>
 &apos;use!&apos; bindings must be of the form &apos;use! &lt;var&gt; = &lt;expr&gt;&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1118)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidUnitsOfMeasurePrefix">
<summary>
 Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:561)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeForUnitsOfMeasure">
<summary>
 Units-of-measure are only supported on float, float32, decimal, and integer types.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:491)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeForLiteralEnumeration">
<summary>
 Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:806)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeExtension">
<summary>
 Invalid type extension
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:776)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeArgumentUsage">
<summary>
 Type arguments cannot be specified here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:576)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidTypeArgumentCount(System.Int32,System.Int32)">
<summary>
 The number of type arguments did not match: &apos;%d&apos; given, &apos;%d&apos; expected. This may be related to a previously reported error.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1235)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidStructReturn">
<summary>
 The use of &apos;[&lt;Struct&gt;]&apos; on values, functions and methods is only allowed on partial active pattern definitions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1665)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSignatureForSet">
<summary>
 Invalid signature for set member
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:716)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSequenceExpressionSyntaxForm">
<summary>
 Invalid record, sequence or computation expression. Sequence expressions should be of the form &apos;seq { ... }&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:594)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidSelfConstraint">
<summary>
 Invalid constraint. Valid constraint forms include \&quot;&apos;T :&gt; ISomeInterface\&quot; for interface constraints and \&quot;SomeConstrainingType&lt;&apos;T&gt;\&quot; for self-constraints. See https://aka.ms/fsharp-type-constraints.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1715)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidResumableConstruct(System.String)">
<summary>
 The construct &apos;%s&apos; may only be used in valid resumable code.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1683)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidRelationInJoin(System.String)">
<summary>
 Invalid join relation in &apos;%s&apos;. Expected &apos;expr &lt;op&gt; expr&apos;, where &lt;op&gt; is =, =?, ?= or ?=?.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1299)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidRecordConstruction">
<summary>
 Invalid record construction
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:641)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidPropertyType">
<summary>
 This property has an invalid type. Properties taking multiple indexer arguments should have types of the form &apos;ty1 * ty2 -&gt; ty3&apos;. Properties returning functions should have types of the form &apos;(ty1 -&gt; ty2)&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:556)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidPattern">
<summary>
 This is not a valid pattern
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:586)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOptionalAssignmentToPropertyOrField">
<summary>
 Invalid optional assignment to a property or field
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:675)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinitionRelational(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the &apos;System.IComparable&apos; interface in the definition of that type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:504)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinitionEquality(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. To define equality semantics for a type, override the &apos;Object.Equals&apos; member in the definition of that type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:505)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidOperatorDefinition(System.String)">
<summary>
 The &apos;%s&apos; operator should not normally be redefined. Consider using a different operator name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:506)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectSequenceOrRecordExpression">
<summary>
 Invalid object, sequence or record expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:593)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectExpressionSyntaxForm">
<summary>
 Invalid object expression. Objects without overrides or interfaces should use the expression form &apos;new Type(args)&apos; without braces.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:592)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidObjectConstructionExpression">
<summary>
 This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:551)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNonPrimitiveLiteralInPatternMatch">
<summary>
 Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use &apos;when &lt;variable&gt; = &lt;constant&gt;&apos; at the end of the match clause.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:575)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNewConstraint">
<summary>
 &apos;new&apos; constraints must take one argument of type &apos;unit&apos; and return the constructed type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:555)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidNamespaceModuleTypeUnionName">
<summary>
 Invalid namespace, module, type or union case name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:737)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidModuleName">
<summary>
 Invalid module name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:775)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMixtureOfRecursiveForms">
<summary>
 This recursive binding uses an invalid mixture of recursive forms
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:550)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMethodNameForRelationalOperator(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. To define comparison semantics for a type, implement the &apos;System.IComparable&apos; interface. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:500)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMethodNameForEquality(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. To define equality semantics for a type, override the &apos;Object.Equals&apos; member. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:501)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberNameFixedTypes(System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name because it is given a standard definition in the F# library over fixed types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:503)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberNameCtor">
<summary>
 Invalid member name. Members may not have name &apos;.ctor&apos; or &apos;.cctor&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1233)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberName(System.String,System.String)">
<summary>
 The name &apos;(%s)&apos; should not be used as a member name. If defining a static member for use from other CLI languages then use the name &apos;%s&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:502)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidMemberDeclNameMissingOrHasParen">
<summary>
 Invalid member declaration. The name of the member is missing or has parentheses.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1708)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidInlineSpecification">
<summary>
 Invalid inline specification
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:706)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexerExpression">
<summary>
 Incomplete expression or invalid use of indexer syntax
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:606)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexOperatorDefinition(System.String)">
<summary>
 The &apos;%s&apos; operator cannot be redefined. Consider using a different operator name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:507)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidIndexIntoActivePatternArray">
<summary>
 Internal error. Invalid index into active pattern array
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:579)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidEnumerationLiteral">
<summary>
 This is not a valid value for an enumeration literal
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:740)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidEnumConstraint">
<summary>
 An &apos;enum&apos; constraint must be of the form &apos;enum&lt;type&gt;&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:554)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidDelegateSpecification">
<summary>
 Delegate specifications must be of the form &apos;typ -&gt; typ&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:804)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidDeclaration">
<summary>
 Invalid declaration
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:538)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstraintTypeSealed">
<summary>
 Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:553)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstraint">
<summary>
 Invalid constraint
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:552)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidConstantExpression">
<summary>
 This is not a valid constant expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:692)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidAssignment">
<summary>
 Invalid assignment
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:654)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidArgForParameterizedPattern">
<summary>
 Invalid argument to parameterized pattern label
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:578)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidAlignmentInInterpolatedString">
<summary>
 Invalid alignment in interpolated string
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1651)
</summary>
</member>
<member name="M:FSComp.SR.tcInvalidActivePatternName(System.String)">
<summary>
 &apos;%s&apos; is not a valid method name. Use a &apos;let&apos; binding instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:682)
</summary>
</member>
<member name="M:FSComp.SR.tcIntoNeedsRestOfQuery">
<summary>
 A use of &apos;into&apos; must be followed by the remainder of the computation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1305)
</summary>
</member>
<member name="M:FSComp.SR.tcInterpolationMixedWithPercent">
<summary>
 Mismatch in interpolated string. Interpolated strings may not use &apos;%%&apos; format specifiers unless each is given an expression, e.g. &apos;%%d{1+1}&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1650)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfacesShouldUseInheritNotInterface">
<summary>
 Interfaces inherited by other interfaces should be declared using &apos;inherit ...&apos; instead of &apos;interface ...&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1100)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfaceTypesCannotBeSealed">
<summary>
 Interface types cannot be sealed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:803)
</summary>
</member>
<member name="M:FSComp.SR.tcInterfaceTypesAndDelegatesCannotContainFields">
<summary>
 Interface types and delegate types cannot contain fields
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:798)
</summary>
</member>
<member name="M:FSComp.SR.tcInstanceMemberRequiresTarget">
<summary>
 This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation &apos;member x.Member(args) = ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:529)
</summary>
</member>
<member name="M:FSComp.SR.tcInlineIfLambdaUsedOnNonInlineFunctionOrMethod">
<summary>
 The &apos;InlineIfLambda&apos; attribute may only be used on parameters of inlined functions of methods whose type is a function or F# delegate type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1706)
</summary>
</member>
<member name="M:FSComp.SR.tcInitOnlyPropertyCannotBeSet1(System.String)">
<summary>
 Init-only property &apos;%s&apos; cannot be set outside the initialization code. See https://aka.ms/fsharp-assigning-values-to-properties-at-initialization
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:664)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritedTypeIsNotObjectModelType">
<summary>
 The inherited type is not an object model type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:643)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritIllegalHere">
<summary>
 A inheritance declaration is not permitted here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:744)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritDeclarationMissingArguments">
<summary>
 This &apos;inherit&apos; declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. &apos;inherit BaseType(args)&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:814)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritConstructionCallNotPartOfImplicitSequence">
<summary>
 This &apos;inherit&apos; declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:815)
</summary>
</member>
<member name="M:FSComp.SR.tcInheritCannotBeUsedOnInterfaceType">
<summary>
 &apos;inherit&apos; cannot be used on interface types. Consider implementing the interface by using &apos;interface ... with ... end&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:612)
</summary>
</member>
<member name="M:FSComp.SR.tcInfoIfFunctionShadowsUnionCase">
<summary>
 This is a function definition that shadows a union case. If this is what you want, ignore or suppress this warning. If you want it to be a union case deconstruction, add parentheses.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1759)
</summary>
</member>
<member name="M:FSComp.SR.tcInferredGenericTypeGivesRiseToInconsistency(System.String,System.String)">
<summary>
 The function or member &apos;%s&apos; is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1234)
</summary>
</member>
<member name="M:FSComp.SR.tcIndexNotationDeprecated">
<summary>
 The syntax &apos;arr.[idx]&apos; is now revised to &apos;arr[idx]&apos;. Please update your code.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1634)
</summary>
</member>
<member name="M:FSComp.SR.tcImplicitMeasureFollowingSlash">
<summary>
 Implicit product of measures following /
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:486)
</summary>
</member>
<member name="M:FSComp.SR.tcImplicitConversionUsedForNonMethodArg(System.String,System.String,System.String)">
<summary>
 This expression uses the implicit conversion &apos;%s&apos; to convert type &apos;%s&apos; to type &apos;%s&apos;. See https://aka.ms/fsharp-implicit-convs. This warning may be disabled using &apos;#nowarn \&quot;3391\&quot;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1676)
</summary>
</member>
<member name="M:FSComp.SR.tcImplicitConversionUsedForMethodArg(System.String,System.String,System.String)">
<summary>
 This expression uses the implicit conversion &apos;%s&apos; to convert type &apos;%s&apos; to type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1680)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIStructuralEquatableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IStructuralEquatable&apos; explicitly. Apply the &apos;CustomEquality&apos; attribute to the type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:767)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIStructuralComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IStructuralComparable&apos; explicitly. Apply the &apos;CustomComparison&apos; attribute to the type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:511)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIEquatableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IEquatable&lt;_&gt;&apos; explicitly. Apply the &apos;CustomEquality&apos; attribute to the type and provide a consistent implementation of the non-generic override &apos;System.Object.Equals(obj)&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:768)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsIComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IComparable&apos; explicitly. You must apply the &apos;CustomComparison&apos; attribute to the type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:509)
</summary>
</member>
<member name="M:FSComp.SR.tcImplementsGenericIComparableExplicitly(System.String)">
<summary>
 The struct, record or union type &apos;%s&apos; implements the interface &apos;System.IComparable&lt;_&gt;&apos; explicitly. You must apply the &apos;CustomComparison&apos; attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:510)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalSyntaxInTypeExpression">
<summary>
 Illegal syntax in type expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:568)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalStructTypeForConstantExpression">
<summary>
 This is not valid literal expression. The [&lt;Literal&gt;] attribute will be ignored.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1359)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalPattern">
<summary>
 Illegal pattern
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:587)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalFormForExplicitTypeDeclaration">
<summary>
 Explicit type declarations for constructors must be of the form &apos;ty1 * ... * tyN -&gt; resTy&apos;. Parentheses may be required around &apos;resTy&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:738)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalByrefsInOpenTypeDeclaration">
<summary>
 Byref types are not allowed in an open type declaration.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1527)
</summary>
</member>
<member name="M:FSComp.SR.tcIllegalAttributesForLiteral">
<summary>
 A literal value cannot be given the [&lt;ThreadStatic&gt;] or [&lt;ContextStatic&gt;] attributes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:688)
</summary>
</member>
<member name="M:FSComp.SR.tcIfThenElseMayNotBeUsedWithinQueries">
<summary>
 An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1262)
</summary>
</member>
<member name="M:FSComp.SR.tcIDisposableTypeShouldUseNew">
<summary>
 It is recommended that objects supporting the IDisposable interface are created using the syntax &apos;new Type(args)&apos;, rather than &apos;Type(args)&apos; or &apos;Type&apos; as a function value representing the constructor, to indicate that resources may be owned by the generated value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:615)
</summary>
</member>
<member name="M:FSComp.SR.tcHighPrecedenceFunctionApplicationToListReserved">
<summary>
 The syntax &apos;expr1[expr2]&apos; is now reserved for indexing. See https://aka.ms/fsharp-index-notation. If calling a function, add a space between the function and argument, e.g. &apos;someFunction [expr]&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1635)
</summary>
</member>
<member name="M:FSComp.SR.tcHighPrecedenceFunctionApplicationToListDeprecated">
<summary>
 The syntax &apos;expr1[expr2]&apos; is used for indexing. Consider adding a type annotation to enable indexing, or if calling a function add a space, e.g. &apos;expr1 [expr2]&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1633)
</summary>
</member>
<member name="M:FSComp.SR.tcGlobalsSystemTypeNotFound(System.String)">
<summary>
 The system type &apos;%s&apos; was required but no referenced system DLL contained this type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1395)
</summary>
</member>
<member name="M:FSComp.SR.tcGenericTypesCannotHaveStructLayout">
<summary>
 Generic types cannot be given the &apos;StructLayout&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:786)
</summary>
</member>
<member name="M:FSComp.SR.tcGenericParameterHasBeenConstrained(System.String)">
<summary>
 A generic type parameter has been used in a way that constrains it to always be &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:518)
</summary>
</member>
<member name="M:FSComp.SR.tcGeneratedTypesShouldBeInternalOrPrivate">
<summary>
 The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using &apos;type internal TypeName = ...&apos; or &apos;type private TypeName = ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1348)
</summary>
</member>
<member name="M:FSComp.SR.tcFunctionRequiresExplicitTypeArguments(System.String)">
<summary>
 The generic function &apos;%s&apos; must be given explicit type argument(s)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:540)
</summary>
</member>
<member name="M:FSComp.SR.tcFunctionRequiresExplicitLambda(System.Int32)">
<summary>
 This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking %d arguments.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:548)
</summary>
</member>
<member name="M:FSComp.SR.tcFormalArgumentIsNotOptional">
<summary>
 The corresponding formal argument is not optional
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:674)
</summary>
</member>
<member name="M:FSComp.SR.tcFixedNotAllowed">
<summary>
 Invalid use of &apos;fixed&apos;. &apos;fixed&apos; may only be used in a declaration of the form &apos;use x = fixed expr&apos; where the expression is one of the following: an array, the address of an array element, a string, a byref, an inref, or a type implementing GetPinnableReference()
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1390)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldsDoNotDetermineUniqueRecordType">
<summary>
 The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:523)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldValIllegalHere">
<summary>
 A field/val declaration is not permitted here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:743)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldRequiresName">
<summary>
 This field requires a name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:736)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldRequiresAssignment(System.String,System.String)">
<summary>
 No assignment given for field &apos;%s&apos; of type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:619)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNotLiteralCannotBeUsedInPattern">
<summary>
 This field is not a literal and cannot be used in a pattern
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:584)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNameIsUsedModeThanOnce(System.String)">
<summary>
 Named field &apos;%s&apos; is used more than once.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1356)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldNameConflictsWithGeneratedNameForAnonymousField(System.String)">
<summary>
 Named field &apos;%s&apos; conflicts with autogenerated name for anonymous field.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1357)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsReadonly">
<summary>
 This field is readonly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:546)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsNotStatic(System.String)">
<summary>
 Field &apos;%s&apos; is not static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:583)
</summary>
</member>
<member name="M:FSComp.SR.tcFieldIsNotMutable">
<summary>
 This field is not mutable
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:601)
</summary>
</member>
<member name="M:FSComp.SR.tcFSharpCoreRequiresExplicit">
<summary>
 All record, union and struct types in FSharp.Core.dll must be explicitly labelled with &apos;StructuralComparison&apos; or &apos;NoComparison&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1060)
</summary>
</member>
<member name="M:FSComp.SR.tcExtraneousFieldsGivenValues">
<summary>
 Extraneous fields have been given values
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:620)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionWithIfRequiresParenthesis">
<summary>
 This list or array expression includes an element of the form &apos;if ... then ... else&apos;. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:595)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionRequiresSequence">
<summary>
 This expression form may only be used in sequence and computation expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:591)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionFormRequiresRecordTypes">
<summary>
 The expression form { expr with ... } may only be used with record types. To build object types use { new Type(...) with ... }
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:642)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionFormRequiresObjectConstructor">
<summary>
 The expression form &apos;expr then expr&apos; may only be used as part of an explicit object constructor
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:598)
</summary>
</member>
<member name="M:FSComp.SR.tcExpressionCountMisMatch(System.Int32,System.Int32)">
<summary>
 Expected %d expressions, got %d
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:589)
</summary>
</member>
<member name="M:FSComp.SR.tcExprUndelayed">
<summary>
 TcExprUndelayed: delayed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:590)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors">
<summary>
 Explicit type specifications cannot be used for exception constructors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:769)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitTypeParameterInvalid">
<summary>
 Explicit type parameters may only be used on module or member bindings
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:521)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitStaticInitializerSyntax">
<summary>
 An explicit static initializer should use the syntax &apos;static new(args) = expr&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:534)
</summary>
</member>
<member name="M:FSComp.SR.tcExplicitObjectConstructorSyntax">
<summary>
 An explicit object constructor should use the syntax &apos;new(args) = expr&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:535)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedUnitOfMeasureNotType">
<summary>
 Expected unit-of-measure, not type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:560)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedUnitOfMeasureMarkWithAttribute">
<summary>
 Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [&lt;Measure&gt;] attribute.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:557)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedTypeParameter">
<summary>
 Expected type parameter, not unit-of-measure parameter
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:558)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedTypeNotUnitOfMeasure">
<summary>
 Expected type, not unit-of-measure
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:559)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectedInterfaceType">
<summary>
 Expected an interface type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:635)
</summary>
</member>
<member name="M:FSComp.SR.tcExpectModuleOrNamespaceParent(System.String)">
<summary>
 Expected module or namespace parent %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:508)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionConstructorDoesNotHaveFieldWithGivenName(System.String,System.String)">
<summary>
 The exception &apos;%s&apos; does not have a field named &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1352)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionAbbreviationsShouldNotHaveArgumentList">
<summary>
 Exception abbreviations should not have argument lists
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:770)
</summary>
</member>
<member name="M:FSComp.SR.tcExceptionAbbreviationsMustReferToValidExceptions">
<summary>
 Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:772)
</summary>
</member>
<member name="M:FSComp.SR.tcEventIsStatic(System.String)">
<summary>
 Event &apos;%s&apos; is static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:668)
</summary>
</member>
<member name="M:FSComp.SR.tcEventIsNotStatic(System.String)">
<summary>
 Event &apos;%s&apos; is not static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:669)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumerationsMayNotHaveMembers">
<summary>
 Enumerations cannot have members
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:750)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumerationsCannotHaveInterfaceDeclaration">
<summary>
 Enumerations cannot have interface declarations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:758)
</summary>
</member>
<member name="M:FSComp.SR.tcEnumTypeCannotBeEnumerated(System.String)">
<summary>
 The type &apos;%s&apos; is not a valid enumerator type , i.e. does not have a &apos;MoveNext()&apos; method returning a bool, and a &apos;Current&apos; property
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1120)
</summary>
</member>
<member name="M:FSComp.SR.tcEntryPointAttributeRequiresFunctionInModule">
<summary>
 The &apos;EntryPointAttribute&apos; attribute may only be used on function definitions in modules
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:683)
</summary>
</member>
<member name="M:FSComp.SR.tcEmptyRecordInvalid">
<summary>
 &apos;{ }&apos; is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list &apos;[]&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:645)
</summary>
</member>
<member name="M:FSComp.SR.tcEmptyCopyAndUpdateRecordInvalid">
<summary>
 Copy-and-update record expressions must include at least one field.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1346)
</summary>
</member>
<member name="M:FSComp.SR.tcEmptyBodyRequiresBuilderZeroMethod">
<summary>
 An empty body may only be used if the computation expression builder defines a &apos;Zero&apos; method.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:564)
</summary>
</member>
<member name="M:FSComp.SR.tcDuplicateSpecOfInterface">
<summary>
 Duplicate specification of an interface
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:742)
</summary>
</member>
<member name="M:FSComp.SR.tcDotLambdaAtNotSupportedExpression">
<summary>
 Shorthand lambda syntax is only supported for atomic expressions, such as method, property, field or indexer on the implied &apos;_&apos; argument. For example: &apos;let f = _.Length&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1761)
</summary>
</member>
<member name="M:FSComp.SR.tcDoesNotAllowExplicitTypeArguments(System.String)">
<summary>
 The method or function &apos;%s&apos; should not be given explicit type argument(s) because it does not declare its type parameters explicitly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:541)
</summary>
</member>
<member name="M:FSComp.SR.tcDoBangIllegalInSequenceExpression">
<summary>
 &apos;do!&apos; cannot be used within sequence expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:650)
</summary>
</member>
<member name="M:FSComp.SR.tcDllImportStubsCannotBeInlined">
<summary>
 DLLImport stubs cannot be inlined
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:513)
</summary>
</member>
<member name="M:FSComp.SR.tcDllImportNotAllowed">
<summary>
 DLLImport bindings must be static members in a class or function definitions in a module
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1114)
</summary>
</member>
<member name="M:FSComp.SR.tcDelegatesCannotBeCurried">
<summary>
 Delegate specifications must not be curried types. Use &apos;typ * ... * typ -&gt; typ&apos; for multi-argument delegates, and &apos;typ -&gt; (typ -&gt; typ)&apos; for delegates returning function values.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:805)
</summary>
</member>
<member name="M:FSComp.SR.tcDelegateConstructorMustBePassed">
<summary>
 A delegate constructor must be passed a single function value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:676)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultValueAttributeRequiresVal">
<summary>
 The &apos;DefaultValue&apos; attribute may only be used on &apos;val&apos; declarations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:680)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultStructConstructorCall">
<summary>
 The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:543)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultImplementationForInterfaceHasAlreadyBeenAdded">
<summary>
 A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:761)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultImplementationAlreadyExists">
<summary>
 This method already has a default implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:712)
</summary>
</member>
<member name="M:FSComp.SR.tcDefaultAmbiguous">
<summary>
 The method implemented by this default is ambiguous
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:713)
</summary>
</member>
<member name="M:FSComp.SR.tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(System.String)">
<summary>
 One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:811)
</summary>
</member>
<member name="M:FSComp.SR.tcDeclarationElementNotPermittedInAugmentation">
<summary>
 This declaration element is not permitted in an augmentation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:763)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationNotUsedCorrectly2(System.String,System.String)">
<summary>
 &apos;%s&apos; is not used correctly. Usage: %s. This is a custom operation in this query or computation expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1267)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationNotUsedCorrectly(System.String)">
<summary>
 &apos;%s&apos; is not used correctly. This is a custom operation in this query or computation expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1266)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings">
<summary>
 A custom operation may not be used in conjunction with a non-value or recursive &apos;let&apos; binding in another part of this computation expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1248)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationMayNotBeUsedHere">
<summary>
 A custom operation may not be used in conjunction with &apos;use&apos;, &apos;try/with&apos;, &apos;try/finally&apos;, &apos;if/then/else&apos; or &apos;match&apos; operators within this computation expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1249)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationMayNotBeOverloaded(System.String)">
<summary>
 The custom operation &apos;%s&apos; refers to a method which is overloaded. The implementations of custom operations may not be overloaded.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1250)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationInvalid(System.String)">
<summary>
 The definition of the custom operator &apos;%s&apos; does not use a valid combination of attribute flags
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1307)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomOperationHasIncorrectArgCount(System.String,System.Int32,System.Int32)">
<summary>
 &apos;%s&apos; is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected %d argument(s), but given %d.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1274)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeMustInvokeConstructor">
<summary>
 A custom attribute must invoke an object constructor
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:703)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeMustBeReferenceType">
<summary>
 A custom attribute must be a reference type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:701)
</summary>
</member>
<member name="M:FSComp.SR.tcCustomAttributeArgumentMismatch">
<summary>
 The number of args for a custom attribute does not match the expected number of args for the attribute constructor
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:702)
</summary>
</member>
<member name="M:FSComp.SR.tcCouldNotFindOffsetToStringData">
<summary>
 Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building &apos;fixed&apos; expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1391)
</summary>
</member>
<member name="M:FSComp.SR.tcCouldNotFindIDisposable">
<summary>
 Couldn&apos;t find Dispose on IDisposable, or it was overloaded
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:544)
</summary>
</member>
<member name="M:FSComp.SR.tcCopyAndUpdateRecordChangesAllFields(System.String)">
<summary>
 This copy-and-update record expression changes all fields of record type &apos;%s&apos;. Consider using the record construction syntax instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1736)
</summary>
</member>
<member name="M:FSComp.SR.tcCopyAndUpdateNeedsRecordType">
<summary>
 The input to a copy-and-update expression that creates an anonymous record must be either an anonymous record or a record
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1522)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsIllegalInAugmentation">
<summary>
 Constructors are not permitted as extension members - they must be defined as part of the original definition of the type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1374)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsIllegalForThisType">
<summary>
 Constructors cannot be defined for this type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:725)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsDisallowedInExceptionAugmentation">
<summary>
 Constructors cannot be specified in exception augmentations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:723)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorsCannotBeFirstClassValues">
<summary>
 Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function &apos;(fun arg1 ... argN -&gt; new Type(arg1,...,argN))&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:666)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorRequiresCall(System.String)">
<summary>
 Constructors for the type &apos;%s&apos; must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:617)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorRequiresArguments">
<summary>
 This object constructor requires arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:637)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorForInterfacesDoNotTakeArguments">
<summary>
 Constructor expressions for interfaces do not take arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:636)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorDoesNotHaveFieldWithGivenName(System.String)">
<summary>
 The constructor does not have a field named &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1354)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructorCannotHaveTypeParameters">
<summary>
 A constructor cannot have explicit type parameters. Consider using a static construction method instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:528)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresSequenceOrComputations">
<summary>
 This construct may only be used within sequence or computation expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:604)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresListArrayOrSequence">
<summary>
 This construct may only be used within list, array and sequence expressions, e.g. expressions of the form &apos;seq { ... }&apos;, &apos;[ ... ]&apos; or &apos;[| ... |]&apos;. These use the syntax &apos;for ... in ... do ... yield...&apos; to generate elements
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:602)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresComputationExpressions">
<summary>
 This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without &apos;return&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:603)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructRequiresComputationExpression">
<summary>
 This construct may only be used within computation expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:605)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructIsAmbiguousInSequenceExpression">
<summary>
 This construct is ambiguous as part of a sequence expression. Nested expressions may be written using &apos;let _ = (...)&apos; and nested sequences using &apos;yield! seq {... }&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:649)
</summary>
</member>
<member name="M:FSComp.SR.tcConstructIsAmbiguousInComputationExpression">
<summary>
 This construct is ambiguous as part of a computation expression. Nested expressions may be written using &apos;let _ = (...)&apos; and nested computations using &apos;let! res = builder { ... }&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:648)
</summary>
</member>
<member name="M:FSComp.SR.tcConstrainedTypeVariableCannotBeGeneralized">
<summary>
 One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:517)
</summary>
</member>
<member name="M:FSComp.SR.tcConditionalAttributeUsage">
<summary>
 Attribute &apos;System.Diagnostics.ConditionalAttribute&apos; is only valid on methods or attribute classes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1110)
</summary>
</member>
<member name="M:FSComp.SR.tcConditionalAttributeRequiresMembers">
<summary>
 The &apos;ConditionalAttribute&apos; attribute may only be used on members
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:681)
</summary>
</member>
<member name="M:FSComp.SR.tcConcreteMembersIllegalInInterface">
<summary>
 Interfaces cannot contain definitions of concrete instance members. You may need to define a constructor on your type to indicate that the type is a class.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:722)
</summary>
</member>
<member name="M:FSComp.SR.tcCompiledNameAttributeMisused">
<summary>
 The &apos;CompiledName&apos; attribute cannot be used with this language element
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:610)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotPartiallyApplyExtensionMethodForByref(System.String)">
<summary>
 Cannot partially apply the extension method &apos;%s&apos; because the first parameter is a byref type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1518)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotOverrideSealedMethod(System.String)">
<summary>
 Cannot override inherited member &apos;%s&apos; because it is sealed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1236)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromVariableType">
<summary>
 Cannot inherit from a variable type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:608)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromSealedType">
<summary>
 Cannot inherit a sealed type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:800)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromInterfaceType">
<summary>
 Cannot inherit from interface type. Use interface ... with instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:801)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotInheritFromErasedType">
<summary>
 Cannot inherit from erased provided type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1231)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCreateExtensionOfSealedType">
<summary>
 Cannot create an extension of a sealed type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:629)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCallExtensionMethodInrefToByref(System.String)">
<summary>
 Cannot call the byref extension method &apos;%s. &apos;this&apos; parameter requires the value to be mutable or a non-readonly byref type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1516)
</summary>
</member>
<member name="M:FSComp.SR.tcCannotCallAbstractBaseMember(System.String)">
<summary>
 Cannot call an abstract base member: &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1087)
</summary>
</member>
<member name="M:FSComp.SR.tcCallerInfoWrongType(System.String,System.String,System.String)">
<summary>
 &apos;%s&apos; must be applied to an argument of type &apos;%s&apos;, but has been applied to an argument of type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1129)
</summary>
</member>
<member name="M:FSComp.SR.tcCallerInfoNotOptional(System.String)">
<summary>
 &apos;%s&apos; can only be applied to optional arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1130)
</summary>
</member>
<member name="M:FSComp.SR.tcByrefsMayNotHaveTypeExtensions">
<summary>
 Byref types are not allowed to have optional type extensions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1517)
</summary>
</member>
<member name="M:FSComp.SR.tcByrefReturnImplicitlyDereferenced">
<summary>
 A byref pointer returned by a function or method is implicitly dereferenced as of F# 4.5. To acquire the return value as a pointer, use the address-of operator, e.g. &apos;&amp;f(x)&apos; or &apos;&amp;obj.Method(arg1, arg2)&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1505)
</summary>
</member>
<member name="M:FSComp.SR.tcByRefLikeNotStruct">
<summary>
 A type annotated with IsByRefLike must also be a struct. Consider adding the [&lt;Struct&gt;] attribute to the type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1506)
</summary>
</member>
<member name="M:FSComp.SR.tcBuiltInImplicitConversionUsed(System.String,System.String)">
<summary>
 This expression uses a built-in implicit conversion to convert type &apos;%s&apos; to type &apos;%s&apos;. See https://aka.ms/fsharp-implicit-convs.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1668)
</summary>
</member>
<member name="M:FSComp.SR.tcBindingCannotBeUseAndRec">
<summary>
 A binding cannot be marked both &apos;use&apos; and &apos;rec&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:677)
</summary>
</member>
<member name="M:FSComp.SR.tcBindMayNotBeUsedInQueries">
<summary>
 &apos;let!&apos;, &apos;use!&apos; and &apos;do!&apos; expressions may not be used in queries
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1318)
</summary>
</member>
<member name="M:FSComp.SR.tcBinaryOperatorRequiresVariable(System.String,System.String)">
<summary>
 &apos;%s&apos; must be followed by a variable name. Usage: %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1271)
</summary>
</member>
<member name="M:FSComp.SR.tcBinaryOperatorRequiresBody(System.String,System.String)">
<summary>
 &apos;%s&apos; must come after a &apos;for&apos; selection clause and be followed by the rest of the query. Syntax: ... %s ...
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1273)
</summary>
</member>
<member name="M:FSComp.SR.tcAutoPropertyRequiresImplicitConstructionSequence">
<summary>
 &apos;member val&apos; definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. &apos;type X(args) = ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1309)
</summary>
</member>
<member name="M:FSComp.SR.tcAugmentationsCannotHaveAttributes">
<summary>
 Attributes cannot be applied to type extensions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1523)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesOfTypeSpecifyMultipleKindsForType">
<summary>
 The attributes of this type specify multiple kinds for the type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:777)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesInvalidInPatterns">
<summary>
 Attributes are not allowed within patterns
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:539)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributesAreNotPermittedOnLetBindings">
<summary>
 Attributes are not permitted on &apos;let&apos; bindings in expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:679)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeIsNotValidForLanguageElementUseDo">
<summary>
 This attribute is not valid for use on this language element. Assembly attributes should be attached to a &apos;do ()&apos; declaration, if necessary within an F# module.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:696)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeIsNotValidForLanguageElement">
<summary>
 This attribute is not valid for use on this language element
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:697)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeExpressionsMustBeConstructorCalls">
<summary>
 Attribute expressions must be calls to object constructors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:704)
</summary>
</member>
<member name="M:FSComp.SR.tcAttributeAutoOpenWasIgnored(System.String,System.String)">
<summary>
 The attribute &apos;AutoOpen(\&quot;%s\&quot;)&apos; in the assembly &apos;%s&apos; did not refer to a valid module or namespace in that assembly and has been ignored
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:821)
</summary>
</member>
<member name="M:FSComp.SR.tcAttribArgsDiffer(System.String)">
<summary>
 The attribute &apos;%s&apos; appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1086)
</summary>
</member>
<member name="M:FSComp.SR.tcAtLeastOneOverrideIsInvalid">
<summary>
 At least one override did not correctly implement its corresponding abstract member
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:639)
</summary>
</member>
<member name="M:FSComp.SR.tcArgumentArityMismatchOneOverload(System.String,System.Int32,System.Int32,System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not accept the correct number of arguments. One overload accepts %d arguments, but %d were given. The required signature is &apos;%s&apos;.%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:625)
</summary>
</member>
<member name="M:FSComp.SR.tcArgumentArityMismatch(System.String,System.Int32,System.Int32,System.String,System.String)">
<summary>
 The member &apos;%s&apos; does not accept the correct number of arguments. %d argument(s) are expected, but %d were given. The required signature is &apos;%s&apos;.%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:624)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonymousUnitsOfMeasureCannotBeNested">
<summary>
 Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:569)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonymousTypeInvalidInDeclaration">
<summary>
 Anonymous type variables are not permitted in this declaration
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:570)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdTypeDuplicateFieldId(System.String)">
<summary>
 The field &apos;%s&apos; appears multiple times in this anonymous record type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1710)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdSingleFieldNameSuperset(System.String)">
<summary>
 This anonymous record has an extra field. Remove field &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1404)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdSingleFieldNameSubset(System.String)">
<summary>
 This anonymous record is missing field &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1402)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdSingleFieldNameSingleDifferent(System.String,System.String)">
<summary>
 This anonymous record should have field &apos;%s&apos; but here has field &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1406)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdSingleFieldNameMultipleDifferent(System.String,System.String)">
<summary>
 This anonymous record should have field &apos;%s&apos; but here has fields %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1407)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdMultipleFieldsNameSuperset(System.String)">
<summary>
 This anonymous record has extra fields. Remove fields %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1405)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdMultipleFieldsNameSubset(System.String)">
<summary>
 This anonymous record is missing fields %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1403)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdMultipleFieldNameSingleDifferent(System.String,System.String)">
<summary>
 This anonymous record should have fields %s; but here has field &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1408)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdMultipleFieldNameMultipleDifferent(System.String,System.String)">
<summary>
 This anonymous record should have fields %s; but here has fields %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1409)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdInvalid">
<summary>
 Invalid Anonymous Record type declaration.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1399)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdFieldNameMismatch(System.String,System.String)">
<summary>
 This anonymous record does not exactly match the expected shape. Add the missing fields %s and remove the extra fields %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1401)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdDuplicateFieldId(System.String)">
<summary>
 The field &apos;%s&apos; appears multiple times in this record expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1709)
</summary>
</member>
<member name="M:FSComp.SR.tcAnonRecdCcuMismatch(System.String,System.String)">
<summary>
 Two anonymous record types are from different assemblies &apos;%s&apos; and &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1400)
</summary>
</member>
<member name="M:FSComp.SR.tcAndBangNotSupported">
<summary>
 This feature is not supported in this version of F#. You may need to add /langversion:preview to use this feature.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1550)
</summary>
</member>
<member name="M:FSComp.SR.tcAmbiguousImplicitConversion(System.String,System.String,System.String)">
<summary>
 This expression has type &apos;%s&apos; and is only made compatible with type &apos;%s&apos; through an ambiguous implicit conversion. Consider using an explicit call to &apos;op_Implicit&apos;. The applicable implicit conversions are:%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1666)
</summary>
</member>
<member name="M:FSComp.SR.tcAmbiguousDiscardDotLambda">
<summary>
 The meaning of _ is ambiguous here. It cannot be used for a discarded variable and a function shorthand in the same scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1748)
</summary>
</member>
<member name="M:FSComp.SR.tcAllowNullTypesMayOnlyInheritFromAllowNullTypes">
<summary>
 Types with the &apos;AllowNullLiteral&apos; attribute may only inherit from or implement types which also allow the use of the null literal
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:785)
</summary>
</member>
<member name="M:FSComp.SR.tcAllImplementedInterfacesShouldBeDeclared">
<summary>
 All implemented interfaces should be declared on the initial declaration of the type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:760)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternsDoNotHaveFields">
<summary>
 Active patterns do not have fields. This syntax is invalid.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1353)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternArgsCountNotMatchOnlyPat(System.String)">
<summary>
 This active pattern expects exactly one pattern argument, e.g., &apos;%s pat&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1775)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternArgsCountNotMatchNoArgsNoPat(System.String,System.String)">
<summary>
 This active pattern does not expect any arguments, i.e., it should be used like &apos;%s&apos; instead of &apos;%s x&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1774)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternArgsCountNotMatchArgsAndPat(System.Int32,System.String,System.String)">
<summary>
 This active pattern expects %d expression argument(s) and a pattern argument, e.g., &apos;%s%s pat&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1777)
</summary>
</member>
<member name="M:FSComp.SR.tcActivePatternArgsCountNotMatchArgs(System.Int32,System.String,System.String)">
<summary>
 This active pattern expects %d expression argument(s), e.g., &apos;%s%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1776)
</summary>
</member>
<member name="M:FSComp.SR.tcAccessModifiersNotAllowedInSRTPConstraint">
<summary>
 Access modifiers cannot be applied to an SRTP constraint.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1784)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractTypeCannotBeInstantiated">
<summary>
 Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression &apos;{ new ... with ... }&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:614)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractPropertyMissingGetOrSet(System.String)">
<summary>
 This property overrides or implements an abstract property but the abstract property doesn&apos;t have a corresponding %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:715)
</summary>
</member>
<member name="M:FSComp.SR.tcAbstractMembersIllegalInAugmentation">
<summary>
 Abstract members are not permitted in an augmentation - they must be defined as part of the type itself
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:708)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor">
<summary>
 Abbreviations for Common IL exception types must have a matching object constructor
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:773)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviationsFordotNetExceptionsCannotTakeArguments">
<summary>
 Abbreviations for Common IL exceptions cannot take arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:771)
</summary>
</member>
<member name="M:FSComp.SR.tcAbbreviatedTypesCannotBeSealed">
<summary>
 Abbreviated types cannot be given the &apos;Sealed&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:799)
</summary>
</member>
<member name="M:FSComp.SR.tastopsMaxArrayThirtyTwo(System.Int32)">
<summary>
 F# supports array ranks between 1 and 32. The value %d is not allowed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1313)
</summary>
</member>
<member name="M:FSComp.SR.tastValueMustBeMutable">
<summary>
 A value must be mutable in order to mutate the contents or take the address of a value type, e.g. &apos;let mutable x = ...&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:94)
</summary>
</member>
<member name="M:FSComp.SR.tastValueMustBeLocal">
<summary>
 A value defined in a module must be mutable in order to take its address, e.g. &apos;let mutable x = ...&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1509)
</summary>
</member>
<member name="M:FSComp.SR.tastValueHasBeenCopied">
<summary>
 The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:96)
</summary>
</member>
<member name="M:FSComp.SR.tastValueDoesNotHaveSetterType">
<summary>
 This value does not have a valid property setter type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:90)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfInternalsVisibleToAttribute">
<summary>
 Unexpected decode of InternalsVisibleToAttribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:101)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfInterfaceDataVersionAttribute">
<summary>
 Unexpected decode of InterfaceDataVersionAttribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:102)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedDecodeOfAutoOpenAttribute">
<summary>
 Unexpected decode of AutoOpenAttribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:100)
</summary>
</member>
<member name="M:FSComp.SR.tastUnexpectedByRef">
<summary>
 Unexpected use of a byref-typed variable
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:93)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefVal(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the val &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1081)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefModuleNamespaceType(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the namespace, module or type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1082)
</summary>
</member>
<member name="M:FSComp.SR.tastUndefinedItemRefModuleNamespace(System.String,System.String,System.String)">
<summary>
 The module/namespace &apos;%s&apos; from compilation unit &apos;%s&apos; did not contain the module/namespace &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1080)
</summary>
</member>
<member name="M:FSComp.SR.tastTypeOrModuleNotConcrete(System.String)">
<summary>
 The type/module &apos;%s&apos; is not a concrete module or type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:82)
</summary>
</member>
<member name="M:FSComp.SR.tastTypeHasAssemblyCodeRepresentation(System.String)">
<summary>
 The type &apos;%s&apos; has an inline assembly code representation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:83)
</summary>
</member>
<member name="M:FSComp.SR.tastTwoModulesWithSameNameInAssembly(System.String)">
<summary>
 Two modules named &apos;%s&apos; occur in two parts of this assembly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:86)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotBeInConstructionOfTuple">
<summary>
 Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:97)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotBeAssignedToNonMutableField(System.String,System.String)">
<summary>
 Recursive values cannot be directly assigned to the non-mutable field &apos;%s&apos; of the type &apos;%s&apos; within a recursive binding. Consider using a mutable field instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:99)
</summary>
</member>
<member name="M:FSComp.SR.tastRecursiveValuesMayNotAppearInConstructionOfType(System.String)">
<summary>
 Recursive values cannot appear directly as a construction of the type &apos;%s&apos; within a recursive binding. This feature has been removed from the F# language. Consider using a record instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:98)
</summary>
</member>
<member name="M:FSComp.SR.tastNotAConstantExpression">
<summary>
 This is not a valid constant expression or custom attribute value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:104)
</summary>
</member>
<member name="M:FSComp.SR.tastNamespaceAndModuleWithSameNameInAssembly(System.String)">
<summary>
 A namespace and a module named &apos;%s&apos; both occur in two parts of this assembly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:85)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidMutationOfConstant">
<summary>
 Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. &apos;let mutable x = ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:95)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidMemberSignature">
<summary>
 Invalid member signature encountered because of an earlier error
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:89)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidFormForPropertySetter">
<summary>
 Invalid form for a property setter. At least one argument is required.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:92)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidFormForPropertyGetter">
<summary>
 Invalid form for a property getter. At least one &apos;()&apos; argument is required when using the explicit syntax.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:91)
</summary>
</member>
<member name="M:FSComp.SR.tastInvalidAddressOfMutableAcrossAssemblyBoundary">
<summary>
 This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. &apos;let mutable x = ...&apos;, and if necessary assigning the value back after the completion of the operation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1076)
</summary>
</member>
<member name="M:FSComp.SR.tastDuplicateTypeDefinitionInAssembly(System.String,System.String)">
<summary>
 Two type definitions named &apos;%s&apos; occur in namespace &apos;%s&apos; in two parts of this assembly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:87)
</summary>
</member>
<member name="M:FSComp.SR.tastConstantExpressionOverflow">
<summary>
 This literal expression or attribute argument results in an arithmetic overflow.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1358)
</summary>
</member>
<member name="M:FSComp.SR.tastConflictingModuleAndTypeDefinitionInAssembly(System.String,System.String)">
<summary>
 A module and a type definition named &apos;%s&apos; occur in namespace &apos;%s&apos; in two parts of this assembly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:88)
</summary>
</member>
<member name="M:FSComp.SR.tastCantTakeAddressOfExpression">
<summary>
 Cannot take the address of the value returned from the expression. Assign the returned value to a let-bound value before taking the address.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1515)
</summary>
</member>
<member name="M:FSComp.SR.tastActivePatternsLimitedToSeven">
<summary>
 Active patterns cannot return more than 7 possibilities
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:103)
</summary>
</member>
<member name="M:FSComp.SR.suggestedName">
<summary>
 (Suggested name)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:970)
</summary>
</member>
<member name="M:FSComp.SR.structOrClassFieldIsNotAccessible(System.String)">
<summary>
 The struct or class field &apos;%s&apos; is not accessible from this code location
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:979)
</summary>
</member>
<member name="M:FSComp.SR.srcFileTooLarge">
<summary>
 Source file is too large to embed in a portable PDB
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:874)
</summary>
</member>
<member name="P:FSComp.SR.SwallowResourceText(System.Boolean)">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:FSComp.SR.scriptSdkNotDeterminedUnexpected(System.String)">
<summary>
 The .NET SDK for this script could not be determined. If the script is in a directory using a &apos;global.json&apos; then ensure the relevant .NET SDK is installed. Unexpected error &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1663)
</summary>
</member>
<member name="M:FSComp.SR.scriptSdkNotDeterminedNoHost">
<summary>
 The .NET SDK for this script could not be determined. dotnet.exe could not be found ensure a .NET SDK is installed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1664)
</summary>
</member>
<member name="M:FSComp.SR.scriptSdkNotDetermined(System.String,System.String,System.String,System.Int32)">
<summary>
 The .NET SDK for this script could not be determined. If the script is in a directory using a &apos;global.json&apos; then ensure the relevant .NET SDK is installed. The output from &apos;%s --version&apos; in the directory &apos;%s&apos; was: &apos;%s&apos; and the exit code was &apos;%d&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1662)
</summary>
</member>
<member name="M:FSComp.SR.returnUsedInsteadOfReturnBang">
<summary>
 Consider using &apos;return!&apos; instead of &apos;return&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:37)
</summary>
</member>
<member name="M:FSComp.SR.reprStateMachineNotCompilableNoAlternative(System.String)">
<summary>
 This state machine is not statically compilable and no alternative is available. %s. Use an &apos;if __useResumableCode then &lt;state-machine&gt; else &lt;alternative&gt;&apos; to give an alternative.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1691)
</summary>
</member>
<member name="M:FSComp.SR.reprStateMachineNotCompilable(System.String)">
<summary>
 This state machine is not statically compilable. %s. An alternative dynamic implementation will be used, which may be slower. Consider adjusting your code to ensure this state machine is statically compilable, or else suppress this warning.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1690)
</summary>
</member>
<member name="M:FSComp.SR.reprStateMachineInvalidForm">
<summary>
 The state machine has an unexpected form
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1703)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeValueHasNoDefinition(System.String)">
<summary>
 The resumable code value(s) &apos;%s&apos; does not have a definition
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1701)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeInvokeNotReduced(System.String)">
<summary>
 A resumable code invocation at &apos;%s&apos; could not be reduced
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1694)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeDefinitionWasGeneric">
<summary>
 A delegate or function producing resumable code in a state machine has type parameters
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1702)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsResumptionInTryFinally">
<summary>
 A try/finally may not contain resumption points
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1698)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsResumptionInHandlerOrFilter">
<summary>
 The &apos;with&apos; block of a try/with may not contain resumption points
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1699)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsLetRec">
<summary>
 A &apos;let rec&apos; occurred in the resumable code specification
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1695)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsFastIntegerForLoop">
<summary>
 A fast integer for loop may not contain resumption points
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1700)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsDynamicResumeAtInBody">
<summary>
 A target label for __resumeAt was not statically determined. A __resumeAt with a non-static target label may only appear at the start of a resumable code method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1697)
</summary>
</member>
<member name="M:FSComp.SR.reprResumableCodeContainsConstrainedGenericLet">
<summary>
 A constrained generic construct occurred in the resumable code specification
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1696)
</summary>
</member>
<member name="M:FSComp.SR.replaceWithSuggestion(System.String)">
<summary>
 Replace with &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:20)
</summary>
</member>
<member name="M:FSComp.SR.recursiveClassHierarchy(System.String)">
<summary>
 Recursive class hierarchy in type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:971)
</summary>
</member>
<member name="M:FSComp.SR.readOnlyAttributeOnStructWithMutableField">
<summary>
 A ReadOnly attribute has been applied to a struct type with a mutable field.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1504)
</summary>
</member>
<member name="M:FSComp.SR.ppparsUnexpectedToken(System.String)">
<summary>
 Unexpected token &apos;%s&apos; in preprocessor expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1365)
</summary>
</member>
<member name="M:FSComp.SR.ppparsMissingToken(System.String)">
<summary>
 Missing token &apos;%s&apos; in preprocessor expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1367)
</summary>
</member>
<member name="M:FSComp.SR.ppparsIncompleteExpression">
<summary>
 Incomplete preprocessor expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1366)
</summary>
</member>
<member name="M:FSComp.SR.pplexUnexpectedChar(System.String)">
<summary>
 Unexpected character &apos;%s&apos; in preprocessor expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1364)
</summary>
</member>
<member name="M:FSComp.SR.pplexExpectedSingleLineComment">
<summary>
 Expected single line comment or end of line
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1056)
</summary>
</member>
<member name="M:FSComp.SR.poundiNotSupportedByRegisteredDependencyManagers">
<summary>
 #i is not supported by the registered PackageManagers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1548)
</summary>
</member>
<member name="M:FSComp.SR.pickleUnexpectedNonZero(System.String)">
<summary>
 An error occurred while reading the F# metadata of assembly &apos;%s&apos;. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn&apos;t make use of a specific construct.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1498)
</summary>
</member>
<member name="M:FSComp.SR.pickleMissingDefinition(System.Int32,System.String,System.String)">
<summary>
 An error occurred while reading the F# metadata node at position %d in table &apos;%s&apos; of assembly &apos;%s&apos;. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1368)
</summary>
</member>
<member name="M:FSComp.SR.pickleFsharpCoreBackwardsCompatible(System.String,System.String)">
<summary>
 Newly added pickle state cannot be used in FSharp.Core, since it must be working in older compilers+tooling as well. The time window is at least 3 years after feature introduction. Violation: %s . Context: \n %s 
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1752)
</summary>
</member>
<member name="M:FSComp.SR.pickleErrorReadingWritingMetadata(System.String,System.String)">
<summary>
 Error reading/writing metadata for the F# compiled DLL &apos;%s&apos;. Was the DLL compiled with an earlier version of the F# compiler? (error: &apos;%s&apos;).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:81)
</summary>
</member>
<member name="M:FSComp.SR.patternMatchGuardIsNotBool(System.String)">
<summary>
 A pattern match guard must be of type &apos;bool&apos;, but this &apos;when&apos; expression is of type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:33)
</summary>
</member>
<member name="M:FSComp.SR.pathIsInvalid(System.String)">
<summary>
 Problem with filename &apos;%s&apos;: Illegal characters in path.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1174)
</summary>
</member>
<member name="M:FSComp.SR.patcPartialActivePatternsGenerateOneResult">
<summary>
 Partial active patterns may only generate one result
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:989)
</summary>
</member>
<member name="M:FSComp.SR.patcMissingVariable(System.String)">
<summary>
 Missing variable &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:988)
</summary>
</member>
<member name="M:FSComp.SR.parsWhileDoExpected">
<summary>
 Missing &apos;do&apos; in &apos;while&apos; expression. Expected &apos;while &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1297)
</summary>
</member>
<member name="M:FSComp.SR.parsVisibilityIllegalOnInherit">
<summary>
 Accessibility modifiers are not permitted on an &apos;inherits&apos; declaration
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:433)
</summary>
</member>
<member name="M:FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier">
<summary>
 Accessibility modifiers should come immediately prior to the identifier naming a construct
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:404)
</summary>
</member>
<member name="M:FSComp.SR.parsUseBindingsIllegalInModules">
<summary>
 &apos;use&apos; bindings are not permitted in modules and are treated as &apos;let&apos; bindings
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:397)
</summary>
</member>
<member name="M:FSComp.SR.parsUseBindingsIllegalInImplicitClassConstructors">
<summary>
 &apos;use&apos; bindings are not permitted in primary constructors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:396)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedWith">
<summary>
 Unmatched &apos;with&apos; or badly formatted &apos;with&apos; block
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:420)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedUseBang">
<summary>
 Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;use!&apos; keyword.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1295)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedUse">
<summary>
 Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;use&apos; keyword.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1296)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedParen">
<summary>
 Unmatched &apos;(&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:446)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLetBang">
<summary>
 Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;let!&apos; keyword.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1294)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLet">
<summary>
 Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the &apos;let&apos; keyword.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1293)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedLBrackLess">
<summary>
 Unmatched &apos;[&lt;&apos;. Expected closing &apos;&gt;]&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1277)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedClassInterfaceOrStruct">
<summary>
 Unmatched &apos;class&apos;, &apos;interface&apos; or &apos;struct&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:418)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBracketBar">
<summary>
 Unmatched &apos;[|&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:462)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBracket">
<summary>
 Unmatched &apos;[&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:457)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBraceBar">
<summary>
 Unmatched &apos;{|&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:464)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBrace">
<summary>
 Unmatched &apos;{&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:463)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBeginOrStruct">
<summary>
 Unmatched &apos;begin&apos; or &apos;struct&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:411)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatchedBegin">
<summary>
 Unmatched &apos;begin&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:423)
</summary>
</member>
<member name="M:FSComp.SR.parsUnmatched(System.String)">
<summary>
 Unmatched &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:461)
</summary>
</member>
<member name="M:FSComp.SR.parsUnionCasesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on union cases. Use &apos;type U = internal ...&apos; or &apos;type U = private ...&apos; to give an accessibility to the whole representation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:441)
</summary>
</member>
<member name="M:FSComp.SR.parsUnfinishedExpression(System.String)">
<summary>
 Unexpected token &apos;%s&apos; or incomplete expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1333)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedVisibilityDeclaration(System.String)">
<summary>
 Accessibility modifiers are not permitted here, but &apos;%s&apos; was given.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:402)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedSymbolEqualsInsteadOfIn">
<summary>
 Unexpected symbol &apos;=&apos; in expression. Did you intend to use &apos;for x in y .. z do&apos; instead?
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1398)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedSymbolDot">
<summary>
 Unexpected symbol &apos;.&apos; in member definition. Expected &apos;with&apos;, &apos;=&apos; or other token.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:40)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedSemicolon">
<summary>
 A semicolon is not expected at this point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:400)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString">
<summary>
 Unexpected quotation operator &apos;&lt;@&apos; in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the &apos;&lt;&apos; and &apos;@&apos; characters.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1126)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure">
<summary>
 Unexpected infix operator in unit-of-measure expression. Legal operators are &apos;*&apos;, &apos;/&apos; and &apos;^&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:472)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedIntegerLiteralForUnitOfMeasure">
<summary>
 Unexpected integer literal in unit-of-measure expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:473)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedInfixOperator">
<summary>
 Unexpected infix operator in type expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:469)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedIdentifier(System.String)">
<summary>
 Unexpected identifier: &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:440)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileWith">
<summary>
 Unexpected end of input in &apos;match&apos; or &apos;try&apos; expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1282)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileWhile">
<summary>
 Unexpected end of input in &apos;while&apos; expression. Expected &apos;while &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1280)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTypeSignature">
<summary>
 Unexpected end of input in type signature
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1287)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTypeDefinition">
<summary>
 Unexpected end of input in type definition
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1288)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTypeArgs">
<summary>
 Unexpected end of input in type arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1286)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileTry">
<summary>
 Unexpected end of input in &apos;try&apos; expression. Expected &apos;try &lt;expr&gt; with &lt;rules&gt;&apos; or &apos;try &lt;expr&gt; finally &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1279)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileThen">
<summary>
 Unexpected end of input in &apos;then&apos; branch of conditional expression. Expected &apos;if &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1283)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileObjectMembers">
<summary>
 Unexpected end of input in object members
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1289)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileMatch">
<summary>
 Unexpected end of input in &apos;match&apos; expression. Expected &apos;match &lt;expr&gt; with | &lt;pat&gt; -&gt; &lt;expr&gt; | &lt;pat&gt; -&gt; &lt;expr&gt; ...&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1278)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileFunBody">
<summary>
 Unexpected end of input in body of lambda expression. Expected &apos;fun &lt;pat&gt; ... &lt;pat&gt; -&gt; &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1285)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileFor">
<summary>
 Unexpected end of input in &apos;for&apos; expression. Expected &apos;for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1281)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileExpression">
<summary>
 Unexpected end of input in expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1291)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileElse">
<summary>
 Unexpected end of input in &apos;else&apos; branch of conditional expression. Expected &apos;if &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1284)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileElif">
<summary>
 Unexpected end of input in &apos;else if&apos; or &apos;elif&apos; branch of conditional expression. Expected &apos;elif &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;else if &lt;expr&gt; then &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1738)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFileDefinition">
<summary>
 Unexpected end of input in value, function or member definition
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1290)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEndOfFile">
<summary>
 Unexpected end of input
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:401)
</summary>
</member>
<member name="M:FSComp.SR.parsUnexpectedEmptyModuleDefn">
<summary>
 Unexpected empty type moduleDefn list
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:413)
</summary>
</member>
<member name="M:FSComp.SR.parsUnderscoreInvalidFieldName">
<summary>
 &apos;_&apos; cannot be used as field name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1347)
</summary>
</member>
<member name="M:FSComp.SR.parsUnClosedBlockInHashLight">
<summary>
 Unclosed block
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:410)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeNameCannotBeEmpty">
<summary>
 Type name cannot be empty.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1335)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeAnnotationsOnGetSet">
<summary>
 Type annotations on property getters and setters must be given after the &apos;get()&apos; or &apos;set(v)&apos;, e.g. &apos;with get() : string = ...&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:426)
</summary>
</member>
<member name="M:FSComp.SR.parsTypeAbbreviationsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted in this position for type abbreviations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:436)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxModuleStructEndDeprecated">
<summary>
 The syntax &apos;module ... = struct .. end&apos; is not used in F# code. Consider using &apos;module ... = begin .. end&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:482)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxModuleSigEndDeprecated">
<summary>
 The syntax &apos;module ... : sig .. end&apos; is not used in F# code. Consider using &apos;module ... = begin .. end&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:483)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxErrorInLabeledType">
<summary>
 Syntax error in labelled type argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:468)
</summary>
</member>
<member name="M:FSComp.SR.parsSyntaxError">
<summary>
 Syntax error
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:416)
</summary>
</member>
<member name="M:FSComp.SR.parsSuccessivePatternsShouldBeSpacedOrTupled">
<summary>
 Successive patterns should be separated by spaces or tupled
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:447)
</summary>
</member>
<member name="M:FSComp.SR.parsSuccessiveArgsShouldBeSpacedOrTupled">
<summary>
 Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:456)
</summary>
</member>
<member name="M:FSComp.SR.parsStaticMemberImcompleteSyntax">
<summary>
 Incomplete declaration of a static construct. Use &apos;static let&apos;,&apos;static do&apos;,&apos;static member&apos; or &apos;static val&apos; for declaration.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1768)
</summary>
</member>
<member name="M:FSComp.SR.parsSetterAtMostTwoArguments">
<summary>
 A setter property may have at most two argument groups
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1073)
</summary>
</member>
<member name="M:FSComp.SR.parsSetSyntax">
<summary>
 Property setters must be defined using &apos;set value = &apos;, &apos;set idx value = &apos; or &apos;set (idx1,...,idxN) value = ... &apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:429)
</summary>
</member>
<member name="M:FSComp.SR.parsRecordFieldsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on record fields. Use &apos;type R = internal ...&apos; or &apos;type R = private ...&apos; to give an accessibility to the whole representation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:444)
</summary>
</member>
<member name="M:FSComp.SR.parsParenFormIsForML">
<summary>
 In F# code you may use &apos;expr.[expr]&apos;. A type annotation may be required to indicate the first expression is an array
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:459)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlySimplePatternsAreAllowedInConstructors">
<summary>
 Only simple patterns are allowed in primary constructors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1771)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyOneWithAugmentationAllowed">
<summary>
 At most one &apos;with&apos; augmentation is permitted
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:399)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyHashDirectivesAllowed">
<summary>
 Only &apos;#&apos; compiler directives may occur prior to the first &apos;namespace&apos; declaration
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:403)
</summary>
</member>
<member name="M:FSComp.SR.parsOnlyClassCanTakeValueArguments">
<summary>
 Only class types may take value arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:422)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAtomicType">
<summary>
 The use of the type syntax &apos;int C&apos; and &apos;C  &lt;int&gt;&apos; is not permitted here. Consider adjusting this type to be written in the form &apos;C&lt;int&gt;&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1079)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAdjacentTypars">
<summary>
 Remove spaces between the type name and type parameter, e.g. \&quot;type C&lt;&apos;T&gt;\&quot;, not type \&quot;C   &lt;&apos;T&gt;\&quot;. Type parameters must be placed directly adjacent to the type name.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1077)
</summary>
</member>
<member name="M:FSComp.SR.parsNonAdjacentTyargs">
<summary>
 Remove spaces between the type name and type parameter, e.g. \&quot;C&lt;&apos;T&gt;\&quot;, not \&quot;C &lt;&apos;T&gt;\&quot;. Type parameters must be placed directly adjacent to the type name.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1078)
</summary>
</member>
<member name="M:FSComp.SR.parsNoMatchingInForLet">
<summary>
 No matching &apos;in&apos; found for this &apos;let&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:448)
</summary>
</member>
<member name="M:FSComp.SR.parsNoHashEndIfFound">
<summary>
 No #endif found for #if or #else
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:394)
</summary>
</member>
<member name="M:FSComp.SR.parsNoEqualShouldFollowNamespace">
<summary>
 No &apos;=&apos; symbol should follow a &apos;namespace&apos; declaration
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:481)
</summary>
</member>
<member name="M:FSComp.SR.parsNewExprMemberAccess">
<summary>
 This member access is ambiguous. Please use parentheses around the object creation, e.g. &apos;(new SomeType(args)).MemberName&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1679)
</summary>
</member>
<member name="M:FSComp.SR.parsNamespaceOrModuleNotBoth">
<summary>
 Files should begin with either a namespace or module declaration, e.g. &apos;namespace SomeNamespace.SubNamespace&apos; or &apos;module SomeNamespace.SomeModule&apos;, but not both. To define a module within a namespace use &apos;module SomeModule = ...&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:405)
</summary>
</member>
<member name="M:FSComp.SR.parsMutableOnAutoPropertyShouldBeGetSetNotJustSet">
<summary>
 To indicate that this property can be set, use &apos;member val PropertyName = expr with get,set&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1311)
</summary>
</member>
<member name="M:FSComp.SR.parsMutableOnAutoPropertyShouldBeGetSet">
<summary>
 Property definitions may not be declared mutable. To indicate that this property can be set, use &apos;member val PropertyName = expr with get,set&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1310)
</summary>
</member>
<member name="M:FSComp.SR.parsMultipleAccessibilitiesForGetSet">
<summary>
 When the visibility for a property is specified, setting the visibility of the set or get method is not allowed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:428)
</summary>
</member>
<member name="M:FSComp.SR.parsMultiArgumentGenericTypeFormDeprecated">
<summary>
 The syntax &apos;(typ,...,typ) ident&apos; is not used in F# code. Consider using &apos;ident&lt;typ,...,typ&gt;&apos; instead
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:470)
</summary>
</member>
<member name="M:FSComp.SR.parsModuleDefnMustBeSimpleName">
<summary>
 A module name must be a simple name, not a path
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:412)
</summary>
</member>
<member name="M:FSComp.SR.parsModuleAbbreviationMustBeSimpleName">
<summary>
 A module abbreviation must be a simple name, not a path
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:406)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingUnionCaseName">
<summary>
 Missing union case name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1740)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingTypeArgs">
<summary>
 Expected type argument or static argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1124)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingQualificationAfterDot">
<summary>
 Missing qualification after &apos;.&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:458)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingMemberBody">
<summary>
 Expecting member body
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1745)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingKeyword(System.String)">
<summary>
 Missing keyword &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1746)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingGreaterThan">
<summary>
 Unmatched &apos;&lt;&apos;. Expected closing &apos;&gt;&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1125)
</summary>
</member>
<member name="M:FSComp.SR.parsMissingFunctionBody">
<summary>
 Missing function body
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:467)
</summary>
</member>
<member name="M:FSComp.SR.parsMismatchedQuote(System.String)">
<summary>
 Mismatched quotation, beginning with &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:460)
</summary>
</member>
<member name="M:FSComp.SR.parsMismatchedQuotationName(System.String)">
<summary>
 Mismatched quotation operator name, beginning with &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:475)
</summary>
</member>
<member name="M:FSComp.SR.parsMemberIllegalInObjectImplementation">
<summary>
 This member is not permitted in an object implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:466)
</summary>
</member>
<member name="M:FSComp.SR.parsLetAndForNonRecBindings">
<summary>
 The declaration form &apos;let ... and ...&apos; for non-recursive bindings is not used in F# code. Consider using a sequence of &apos;let&apos; bindings
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:445)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidUseOfRec">
<summary>
 Invalid use of &apos;rec&apos; keyword
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1387)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidProperty">
<summary>
 Invalid property getter or setter
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1074)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidPrefixOperatorDefinition">
<summary>
 Invalid operator definition. Prefix operator definitions must use a valid prefix operator name.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1102)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidPrefixOperator">
<summary>
 Invalid prefix operator
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1101)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidLiteralInType">
<summary>
 Invalid literal in type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:471)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidDeclarationSyntax">
<summary>
 Invalid declaration syntax
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:424)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidAnonRecdType">
<summary>
 Invalid anonymous record type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1521)
</summary>
</member>
<member name="M:FSComp.SR.parsInvalidAnonRecdExpr">
<summary>
 Invalid anonymous record expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1520)
</summary>
</member>
<member name="M:FSComp.SR.parsInterfacesHaveSameVisibilityAsEnclosingType">
<summary>
 Interfaces always have the same visibility as the enclosing type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:430)
</summary>
</member>
<member name="M:FSComp.SR.parsIntegerForLoopRequiresSimpleIdentifier">
<summary>
 An integer for loop must use a simple identifier
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:398)
</summary>
</member>
<member name="M:FSComp.SR.parsInlineAssemblyCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on inline assembly code types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:439)
</summary>
</member>
<member name="M:FSComp.SR.parsInheritDeclarationsCannotHaveAsBindings">
<summary>
 &apos;inherit&apos; declarations cannot have &apos;as&apos; bindings. To access members of the base class when overriding a method, the syntax &apos;base.SomeMember&apos; may be used; &apos;base&apos; is a keyword. Remove this &apos;as&apos; binding.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:434)
</summary>
</member>
<member name="M:FSComp.SR.parsIndexerPropertyRequiresAtLeastOneArgument">
<summary>
 An indexer property must be given at least one argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1075)
</summary>
</member>
<member name="M:FSComp.SR.parsIncompleteTyparExpr2">
<summary>
 Incomplete operator expression (example a^b) or qualified type invocation (example: ^T.Name)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:480)
</summary>
</member>
<member name="M:FSComp.SR.parsIncompleteTyparExpr1">
<summary>
 Incomplete character literal (example: &apos;Q&apos;) or qualified type invocation (example: &apos;T.Name)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:479)
</summary>
</member>
<member name="M:FSComp.SR.parsIncompleteIf">
<summary>
 Incomplete conditional. Expected &apos;if &lt;expr&gt; then &lt;expr&gt;&apos; or &apos;if &lt;expr&gt; then &lt;expr&gt; else &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:451)
</summary>
</member>
<member name="M:FSComp.SR.parsInOrEqualExpected">
<summary>
 &apos;in&apos; or &apos;=&apos; expected
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:454)
</summary>
</member>
<member name="M:FSComp.SR.parsIllegalMemberVarInObjectImplementation">
<summary>
 Neither &apos;member val&apos; nor &apos;override val&apos; definitions are permitted in object expressions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1345)
</summary>
</member>
<member name="M:FSComp.SR.parsIllegalDenominatorForMeasureExponent">
<summary>
 Denominator must not be 0 in unit-of-measure exponent
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:478)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate(System.String)">
<summary>
 The &apos;%s&apos; visibility attribute is not allowed on module abbreviation. Module abbreviations are always private.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:409)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate(System.String)">
<summary>
 The &apos;%s&apos; accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:408)
</summary>
</member>
<member name="M:FSComp.SR.parsIgnoreAttributesOnModuleAbbreviation">
<summary>
 Ignoring attributes on module abbreviation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:407)
</summary>
</member>
<member name="M:FSComp.SR.parsIdentifierExpected">
<summary>
 Identifier expected
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:453)
</summary>
</member>
<member name="M:FSComp.SR.parsGetterMustHaveAtLeastOneArgument">
<summary>
 A getter property is expected to be a function, e.g. &apos;get() = ...&apos; or &apos;get(index) = ...&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:427)
</summary>
</member>
<member name="M:FSComp.SR.parsGetterAtMostOneArgument">
<summary>
 A getter property may have at most one argument group
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1072)
</summary>
</member>
<member name="M:FSComp.SR.parsGetOrSetRequired">
<summary>
 &apos;get&apos;, &apos;set&apos; or &apos;get,set&apos; required
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:421)
</summary>
</member>
<member name="M:FSComp.SR.parsGetAndOrSetRequired">
<summary>
 &apos;get&apos; and/or &apos;set&apos; required
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:425)
</summary>
</member>
<member name="M:FSComp.SR.parsForDoExpected">
<summary>
 Missing &apos;do&apos; in &apos;for&apos; expression. Expected &apos;for &lt;pat&gt; in &lt;expr&gt; do &lt;expr&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1298)
</summary>
</member>
<member name="M:FSComp.SR.parsFieldBinding">
<summary>
 Field bindings must have the form &apos;id = expr;&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:465)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingUnionCaseField">
<summary>
 Expecting union case field
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1782)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingType">
<summary>
 Expecting type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1741)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingRecordField">
<summary>
 Expecting record field
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1769)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingPattern">
<summary>
 Expecting pattern
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1721)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectingExpression">
<summary>
 Expecting expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1711)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedTypeAfterToken">
<summary>
 Expected a type after this point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1276)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedPatternAfterToken">
<summary>
 Expected a pattern after this point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1722)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedNameAfterToken">
<summary>
 Unexpected end of type. Expected a name after this point.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1292)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedExpressionAfterToken">
<summary>
 Expected an expression after this point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1275)
</summary>
</member>
<member name="M:FSComp.SR.parsExpectedExpressionAfterLet(System.String,System.String)">
<summary>
 The block following this &apos;%s&apos; is unfinished. Every code block is an expression and must have a result. &apos;%s&apos; cannot be the final code element in a block. Consider giving this block an explicit result.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:450)
</summary>
</member>
<member name="M:FSComp.SR.parsErrorParsingAsOperatorName">
<summary>
 Attempted to parse this as an operator name, but failed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1127)
</summary>
</member>
<member name="M:FSComp.SR.parsErrorInReturnForLetIncorrectIndentation">
<summary>
 Error in the return expression for this &apos;let&apos;. Possible incorrect indentation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:449)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInVerbatimStringInComment">
<summary>
 End of file in verbatim string embedded in comment begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:391)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInVerbatimString">
<summary>
 End of file in verbatim string begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:388)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInTripleQuoteStringInComment">
<summary>
 End of file in triple-quote string embedded in comment begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1122)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInTripleQuoteString">
<summary>
 End of file in triple-quote string begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1121)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInStringInComment">
<summary>
 End of file in string embedded in comment begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:390)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInString">
<summary>
 End of file in string begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:387)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInInterpolatedVerbatimString">
<summary>
 Incomplete interpolated verbatim string begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1658)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInInterpolatedTripleQuoteString">
<summary>
 Incomplete interpolated triple-quote string begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1659)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInInterpolatedStringFill">
<summary>
 Incomplete interpolated string expression fill begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1656)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInInterpolatedString">
<summary>
 Incomplete interpolated string begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1657)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInIfOcaml">
<summary>
 End of file in IF-OCAML section begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:392)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInHashIf">
<summary>
 End of file in #if section begun at or after here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:386)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInDirective">
<summary>
 End of file in directive begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:393)
</summary>
</member>
<member name="M:FSComp.SR.parsEofInComment">
<summary>
 End of file in comment begun at or before here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:389)
</summary>
</member>
<member name="M:FSComp.SR.parsEnumTypesCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted in this position for enum types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:437)
</summary>
</member>
<member name="M:FSComp.SR.parsEnumFieldsCannotHaveVisibilityDeclarations">
<summary>
 Accessibility modifiers are not permitted on enumeration fields
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:442)
</summary>
</member>
<member name="M:FSComp.SR.parsEmptyTypeDefinition">
<summary>
 A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use &apos;type ... = class end&apos;, &apos;interface end&apos; or &apos;struct end&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:419)
</summary>
</member>
<member name="M:FSComp.SR.parsEmptyFillInInterpolatedString">
<summary>
 Invalid interpolated string. This interpolated string expression fill is empty, an expression was expected.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1660)
</summary>
</member>
<member name="M:FSComp.SR.parsDoCannotHaveVisibilityDeclarations(System.String)">
<summary>
 Accessibility modifiers are not permitted on &apos;do&apos; bindings, but &apos;%s&apos; was given.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:385)
</summary>
</member>
<member name="M:FSComp.SR.parsConstraintIntersectionSyntaxUsedWithNonFlexibleType">
<summary>
 Constraint intersection syntax may only be used with flexible types, e.g. &apos;#IDisposable &amp; #ISomeInterface&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1750)
</summary>
</member>
<member name="M:FSComp.SR.parsConsiderUsingSeparateRecordType">
<summary>
 Consider using a separate record type instead
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:443)
</summary>
</member>
<member name="M:FSComp.SR.parsAugmentationsIllegalOnDelegateType">
<summary>
 Augmentations are not permitted on delegate type moduleDefns
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:417)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesMustComeBeforeVal">
<summary>
 Attributes should be placed before &apos;val&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:414)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIllegalOnInherit">
<summary>
 Attributes are not permitted on &apos;inherit&apos; declarations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:432)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIllegalHere">
<summary>
 Attributes are not allowed here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:435)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesIgnored">
<summary>
 Attributes have been ignored in this construct
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:395)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributesAreNotPermittedOnInterfaceImplementations">
<summary>
 Attributes are not permitted on interface implementations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:415)
</summary>
</member>
<member name="M:FSComp.SR.parsAttributeOnIncompleteCode">
<summary>
 Cannot find code target for this attribute, possibly because the code after the attribute is incomplete.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1334)
</summary>
</member>
<member name="M:FSComp.SR.parsAssertIsNotFirstClassValue">
<summary>
 &apos;assert&apos; may not be used as a first class value. Use &apos;assert &lt;expr&gt;&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:452)
</summary>
</member>
<member name="M:FSComp.SR.parsArrowUseIsLimited">
<summary>
 The use of &apos;-&gt;&apos; in sequence and computation expressions is limited to the form &apos;for pat in expr -&gt; expr&apos;. Use the syntax &apos;for ... in ... do ... yield...&apos; to generate elements in more complex sequence expressions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:455)
</summary>
</member>
<member name="M:FSComp.SR.parsAllEnumFieldsRequireValues">
<summary>
 All enum fields must be given values
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:438)
</summary>
</member>
<member name="M:FSComp.SR.parsActivePatternCaseMustBeginWithUpperCase">
<summary>
 Active pattern case identifiers must begin with an uppercase letter
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:476)
</summary>
</member>
<member name="M:FSComp.SR.parsActivePatternCaseContainsPipe">
<summary>
 The &apos;|&apos; character is not permitted in active pattern case identifiers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:477)
</summary>
</member>
<member name="M:FSComp.SR.parsAccessibilityModsIllegalForAbstract">
<summary>
 Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:431)
</summary>
</member>
<member name="M:FSComp.SR.packageManagerUnknown(System.String,System.String,System.String)">
<summary>
 Package manager key &apos;%s&apos; was not registered in %s. Currently registered: %s. You can provide extra path(s) by passing &apos;--compilertool:&lt;extensionsfolder&gt;&apos; to the command line. To learn more about extensions, visit: https://aka.ms/dotnetdepmanager
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:843)
</summary>
</member>
<member name="M:FSComp.SR.packageManagerError(System.String)">
<summary>
 %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:844)
</summary>
</member>
<member name="M:FSComp.SR.packageManagementRequiresVFive">
<summary>
 The &apos;package management&apos; feature requires language version 5.0 or above
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1546)
</summary>
</member>
<member name="M:FSComp.SR.optsWriteXml">
<summary>
 Write the xmldoc of the assembly to the given file
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:855)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32res">
<summary>
 Specify a Win32 resource file (.res)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:867)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32manifest">
<summary>
 Specify a Win32 manifest file
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:868)
</summary>
</member>
<member name="M:FSComp.SR.optsWin32icon">
<summary>
 Specify a Win32 icon file (.ico)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:866)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnaserrorPM">
<summary>
 Report all warnings as errors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:888)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnaserror">
<summary>
 Report specific warnings as errors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:889)
</summary>
</member>
<member name="M:FSComp.SR.optsWarnOn">
<summary>
 Enable specific warnings that may be off by default
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:892)
</summary>
</member>
<member name="M:FSComp.SR.optsWarn">
<summary>
 Set a warning level (0-5)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:890)
</summary>
</member>
<member name="M:FSComp.SR.optsVersion">
<summary>
 Display compiler version banner and exit
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:898)
</summary>
</member>
<member name="M:FSComp.SR.optsUtf8output">
<summary>
 Output messages in UTF-8 encoding
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:902)
</summary>
</member>
<member name="M:FSComp.SR.optsUseHighEntropyVA">
<summary>
 Enable high-entropy ASLR
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:929)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedTarget(System.String)">
<summary>
 Unrecognized target &apos;%s&apos;, expected &apos;exe&apos;, &apos;winexe&apos;, &apos;library&apos; or &apos;module&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:939)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedLanguageVersion(System.String)">
<summary>
 Unrecognized value &apos;%s&apos; for --langversion use --langversion:? for complete list
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:84)
</summary>
</member>
<member name="M:FSComp.SR.optsUnrecognizedDebugType(System.String)">
<summary>
 Unrecognized debug type &apos;%s&apos;, expected &apos;pdbonly&apos; or &apos;full&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:940)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownSignatureData(System.String)">
<summary>
 Invalid value &apos;%s&apos; for --interfacedata, valid value are: none, file, compress.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:936)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownPlatform(System.String)">
<summary>
 Unrecognized platform &apos;%s&apos;, valid values are &apos;x86&apos;, &apos;x64&apos;, &apos;Arm&apos;, &apos;Arm64&apos;, &apos;Itanium&apos;, &apos;anycpu32bitpreferred&apos;, and &apos;anycpu&apos;. The default is anycpu.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:945)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownOptimizationData(System.String)">
<summary>
 Invalid value &apos;%s&apos; for --optimizationdata, valid value are: none, file, compress.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:938)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownChecksumAlgorithm(System.String)">
<summary>
 Algorithm &apos;%s&apos; is not supported
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:946)
</summary>
</member>
<member name="M:FSComp.SR.optsUnknownArgumentToTheTestSwitch(System.String)">
<summary>
 Unknown --test argument: &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:944)
</summary>
</member>
<member name="M:FSComp.SR.optsTargetProfile">
<summary>
 Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:931)
</summary>
</member>
<member name="M:FSComp.SR.optsTailcalls">
<summary>
 Enable or disable tailcalls
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:880)
</summary>
</member>
<member name="M:FSComp.SR.optsSupportedLangVersions">
<summary>
 Supported language versions:
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1562)
</summary>
</member>
<member name="M:FSComp.SR.optsSubSystemVersion">
<summary>
 Specify subsystem version of this assembly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:930)
</summary>
</member>
<member name="M:FSComp.SR.optsStrongKeyFile">
<summary>
 Specify a strong name key file
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:856)
</summary>
</member>
<member name="M:FSComp.SR.optsStrongKeyContainer">
<summary>
 Specify a strong name key container
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:857)
</summary>
</member>
<member name="M:FSComp.SR.optsStrictIndentation">
<summary>
 Override indentation rules implied by the language version
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1563)
</summary>
</member>
<member name="M:FSComp.SR.optsStaticlink">
<summary>
 Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:909)
</summary>
</member>
<member name="M:FSComp.SR.optsStandalone">
<summary>
 Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:908)
</summary>
</member>
<member name="M:FSComp.SR.optsSourceLink">
<summary>
 Source link information file to embed in the portable PDB file
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:872)
</summary>
</member>
<member name="M:FSComp.SR.optsSimpleresolution">
<summary>
 Resolve assembly references using directory-based rules rather than MSBuild resolution
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:912)
</summary>
</member>
<member name="M:FSComp.SR.optsSignatureData">
<summary>
 Include F# interface information, the default is file. Essential for distributing libraries.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:935)
</summary>
</member>
<member name="M:FSComp.SR.optsSig">
<summary>
 Print the inferred interface of the assembly to a file
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:862)
</summary>
</member>
<member name="M:FSComp.SR.optsShortFormOf(System.String)">
<summary>
 Short form of &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:913)
</summary>
</member>
<member name="M:FSComp.SR.optsSetLangVersion">
<summary>
 Specify language version such as &apos;latest&apos; or &apos;preview&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1561)
</summary>
</member>
<member name="M:FSComp.SR.optsResponseFileNotFound(System.String,System.String)">
<summary>
 Response file &apos;%s&apos; not found in &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1376)
</summary>
</member>
<member name="M:FSComp.SR.optsResponseFileNameInvalid(System.String)">
<summary>
 Response file name &apos;%s&apos; is empty, contains invalid characters, has a drive specification without an absolute path, or is too long
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1377)
</summary>
</member>
<member name="M:FSComp.SR.optsResponseFile">
<summary>
 Read response file for more options
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:899)
</summary>
</member>
<member name="M:FSComp.SR.optsResource">
<summary>
 Embed the specified managed resource
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:875)
</summary>
</member>
<member name="M:FSComp.SR.optsResident">
<summary>
 Use a resident background compilation service to improve compiler startup times.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:910)
</summary>
</member>
<member name="M:FSComp.SR.optsReflectionFree">
<summary>
 Disable implicit generation of constructs using reflection
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:887)
</summary>
</member>
<member name="M:FSComp.SR.optsReference">
<summary>
 Reference an assembly (Short form: -r)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:864)
</summary>
</member>
<member name="M:FSComp.SR.optsRefOut">
<summary>
 Produce a reference assembly with the specified file path.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:884)
</summary>
</member>
<member name="M:FSComp.SR.optsRefOnly">
<summary>
 Produce a reference assembly, instead of a full assembly, as the primary output
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:883)
</summary>
</member>
<member name="M:FSComp.SR.optsRealsig">
<summary>
 Generate assembly with IL visibility that matches the source code visibility
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:882)
</summary>
</member>
<member name="M:FSComp.SR.optsPublicSign">
<summary>
 Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:854)
</summary>
</member>
<member name="M:FSComp.SR.optsProblemWithCodepage(System.Int32,System.String)">
<summary>
 Problem with codepage &apos;%d&apos;: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:845)
</summary>
</member>
<member name="M:FSComp.SR.optsPreferredUiLang">
<summary>
 Specify the preferred output language culture name (e.g. es-ES, ja-JP)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:933)
</summary>
</member>
<member name="M:FSComp.SR.optsPlatform">
<summary>
 Limit which platforms this code can run on: x86, x64, Arm, Arm64, Itanium, anycpu32bitpreferred, or anycpu. The default is anycpu.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:859)
</summary>
</member>
<member name="M:FSComp.SR.optsPdbMatchesOutputFileName">
<summary>
 The pdb output file name cannot match the build output filename use --pdb:filename.pdb
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:873)
</summary>
</member>
<member name="M:FSComp.SR.optsPdb">
<summary>
 Name the output debug file
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:911)
</summary>
</member>
<member name="M:FSComp.SR.optsPathMap">
<summary>
 Maps physical paths to source path names output by the compiler
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:885)
</summary>
</member>
<member name="M:FSComp.SR.optsOptimize">
<summary>
 Enable optimizations (Short form: -O)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:879)
</summary>
</member>
<member name="M:FSComp.SR.optsOptimizationData">
<summary>
 Specify included optimization information, the default is file. Important for distributed libraries.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:937)
</summary>
</member>
<member name="M:FSComp.SR.optsNowin32manifest">
<summary>
 Do not include the default Win32 manifest
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:869)
</summary>
</member>
<member name="M:FSComp.SR.optsNowarn">
<summary>
 Disable specific warning messages
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:891)
</summary>
</member>
<member name="M:FSComp.SR.optsNologo">
<summary>
 Suppress compiler copyright message
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:896)
</summary>
</member>
<member name="M:FSComp.SR.optsNoframework">
<summary>
 Do not reference the default CLI assemblies by default
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:907)
</summary>
</member>
<member name="M:FSComp.SR.optsNoOpt">
<summary>
 Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:860)
</summary>
</member>
<member name="M:FSComp.SR.optsNoInterface">
<summary>
 Don&apos;t add a resource to the generated assembly containing F#-specific metadata
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:861)
</summary>
</member>
<member name="M:FSComp.SR.optsNoCopyFsharpCore">
<summary>
 Don&apos;t copy FSharp.Core.dll along the produced binaries
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:934)
</summary>
</member>
<member name="M:FSComp.SR.optsNameOfOutputFile">
<summary>
 Name of the output file (Short form: -o)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:848)
</summary>
</member>
<member name="M:FSComp.SR.optsMlcompatibility">
<summary>
 Ignore ML compatibility warnings
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:895)
</summary>
</member>
<member name="M:FSComp.SR.optsLinkresource">
<summary>
 Link the specified resource to this assembly where the resinfo format is &lt;file&gt;[,&lt;string name&gt;[,public|private]]
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:876)
</summary>
</member>
<member name="M:FSComp.SR.optsLib">
<summary>
 Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:904)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidWarningLevel(System.Int32)">
<summary>
 Invalid warning level &apos;%d&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:941)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidTargetProfile(System.String)">
<summary>
 Invalid value &apos;%s&apos; for &apos;--targetprofile&apos;, valid values are &apos;mscorlib&apos;, &apos;netcore&apos; or &apos;netstandard&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:943)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidSubSystemVersion(System.String)">
<summary>
 Invalid version &apos;%s&apos; for &apos;--subsystemversion&apos;. The version must be 4.00 or greater.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:942)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidResponseFile(System.String,System.String)">
<summary>
 Invalid response file &apos;%s&apos; ( &apos;%s&apos; )
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1375)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidRefOut">
<summary>
 Invalid reference assembly path&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1179)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidRefAssembly">
<summary>
 Invalid use of emitting a reference assembly, do not use &apos;--standalone or --staticlink&apos; with &apos;--refonly or --refout&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1180)
</summary>
</member>
<member name="M:FSComp.SR.optsInvalidPathMapFormat">
<summary>
 Invalid path map. Mappings must be comma separated and of the format &apos;path=sourcePath&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1178)
</summary>
</member>
<member name="M:FSComp.SR.optsInternalNoDescription(System.String)">
<summary>
 The command-line option &apos;%s&apos; is for test purposes only
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:924)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerResources">
<summary>
 - RESOURCES -
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:918)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerOutputFiles">
<summary>
 - OUTPUT FILES -
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:916)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerMisc">
<summary>
 - MISCELLANEOUS -
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:921)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerLanguage">
<summary>
 - LANGUAGE -
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:922)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerInputFiles">
<summary>
 - INPUT FILES -
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:917)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerErrsAndWarns">
<summary>
 - ERRORS AND WARNINGS -
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:923)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerCodeGen">
<summary>
 - CODE GENERATION -
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:919)
</summary>
</member>
<member name="M:FSComp.SR.optsHelpBannerAdvanced">
<summary>
 - ADVANCED -
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:920)
</summary>
</member>
<member name="M:FSComp.SR.optsHelp">
<summary>
 Display this usage message (Short form: -?)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:897)
</summary>
</member>
<member name="M:FSComp.SR.optsGetLangVersions">
<summary>
 Display the allowed values for language version.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1560)
</summary>
</member>
<member name="M:FSComp.SR.optsFullpaths">
<summary>
 Output messages with fully qualified paths
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:903)
</summary>
</member>
<member name="M:FSComp.SR.optsEmitDebugInfoInQuotations">
<summary>
 Emit debug information in quotations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:932)
</summary>
</member>
<member name="M:FSComp.SR.optsEmbedSource">
<summary>
 Embed specific source files in the portable PDB file
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:871)
</summary>
</member>
<member name="M:FSComp.SR.optsEmbedAllSource">
<summary>
 Embed all source files in the portable PDB file
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:870)
</summary>
</member>
<member name="M:FSComp.SR.optsDeterministic">
<summary>
 Produce a deterministic assembly (including module version GUID and timestamp)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:881)
</summary>
</member>
<member name="M:FSComp.SR.optsDelaySign">
<summary>
 Delay-sign the assembly using only the public portion of the strong name key
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:853)
</summary>
</member>
<member name="M:FSComp.SR.optsDefine">
<summary>
 Define conditional compilation symbols (Short form: -d)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:894)
</summary>
</member>
<member name="M:FSComp.SR.optsDebugPM">
<summary>
 Emit debug information (Short form: -g)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:877)
</summary>
</member>
<member name="M:FSComp.SR.optsDebug(System.String)">
<summary>
 Specify debugging type: full, portable, embedded, pdbonly. (&apos;%s&apos; is the default if no debugging type specified and enables attaching a debugger to a running program, &apos;portable&apos; is a cross-platform format, &apos;embedded&apos; is a cross-platform format embedded into the output file).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:878)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLONoDescription(System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:925)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLOHtmlDoc(System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:927)
</summary>
</member>
<member name="M:FSComp.SR.optsDCLODeprecatedSuggestAlternative(System.String,System.String)">
<summary>
 The command-line option &apos;%s&apos; has been deprecated. Use &apos;%s&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:926)
</summary>
</member>
<member name="M:FSComp.SR.optsCrossoptimize">
<summary>
 Enable or disable cross-module optimizations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:886)
</summary>
</member>
<member name="M:FSComp.SR.optsCopyrightCommunity">
<summary>
 Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:847)
</summary>
</member>
<member name="M:FSComp.SR.optsCopyright">
<summary>
 Copyright (c) Microsoft Corporation. All Rights Reserved.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:846)
</summary>
</member>
<member name="M:FSComp.SR.optsConsoleColors">
<summary>
 Output warning and error messages in color
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:928)
</summary>
</member>
<member name="M:FSComp.SR.optsCompressMetadata">
<summary>
 Compress interface and optimization data files
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:858)
</summary>
</member>
<member name="M:FSComp.SR.optsCompilerTool">
<summary>
 Reference an assembly or directory containing a design time tool (Short form: -t)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:865)
</summary>
</member>
<member name="M:FSComp.SR.optsCodepage">
<summary>
 Specify the codepage used to read source files
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:900)
</summary>
</member>
<member name="M:FSComp.SR.optsClirootDescription">
<summary>
 Use to override where the compiler looks for mscorlib.dll and framework components
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:915)
</summary>
</member>
<member name="M:FSComp.SR.optsClirootDeprecatedMsg">
<summary>
 The command-line option &apos;--cliroot&apos; has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:914)
</summary>
</member>
<member name="M:FSComp.SR.optsClearResultsCache">
<summary>
 Clear the package manager results cache
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:901)
</summary>
</member>
<member name="M:FSComp.SR.optsChecksumAlgorithm">
<summary>
 Specify algorithm for calculating source file checksum stored in PDB. Supported values are: SHA1 or SHA256 (default)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:906)
</summary>
</member>
<member name="M:FSComp.SR.optsChecked">
<summary>
 Generate overflow checks
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:893)
</summary>
</member>
<member name="M:FSComp.SR.optsCheckNulls">
<summary>
 Enable nullness declarations and checks
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1558)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildWindows">
<summary>
 Build a Windows executable
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:850)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildModule">
<summary>
 Build a module that can be added to another assembly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:852)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildLibrary">
<summary>
 Build a library (Short form: -a)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:851)
</summary>
</member>
<member name="M:FSComp.SR.optsBuildConsole">
<summary>
 Build a console executable
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:849)
</summary>
</member>
<member name="M:FSComp.SR.optsBaseaddress">
<summary>
 Base address for the library to be built
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:905)
</summary>
</member>
<member name="M:FSComp.SR.optsAllSigs">
<summary>
 Print the inferred interfaces of all compilation files to associated signature files
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:863)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineHasUnexpectedValue">
<summary>
 A value marked as &apos;inline&apos; has an unexpected value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:997)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineCouldNotBeInlined">
<summary>
 A value marked as &apos;inline&apos; could not be inlined
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:998)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineButWasNotBoundInTheOptEnv(System.String)">
<summary>
 The value &apos;%s&apos; was marked inline but was not bound in the optimization environment
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:996)
</summary>
</member>
<member name="M:FSComp.SR.optValueMarkedInlineButIncomplete(System.String)">
<summary>
 The value &apos;%s&apos; was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:995)
</summary>
</member>
<member name="M:FSComp.SR.optRecursiveValValue(System.String)">
<summary>
 Recursive ValValue %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1000)
</summary>
</member>
<member name="M:FSComp.SR.optFailedToInlineValue(System.String)">
<summary>
 Failed to inline the value &apos;%s&apos; marked &apos;inline&apos;, perhaps because a recursive value was marked &apos;inline&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:999)
</summary>
</member>
<member name="M:FSComp.SR.optFailedToInlineSuggestedValue(System.String)">
<summary>
 The value &apos;%s&apos; was marked &apos;InlineIfLambda&apos; but was not determined to have a lambda value. This warning is for informational purposes only.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1704)
</summary>
</member>
<member name="M:FSComp.SR.nrUnionTypeNeedsQualifiedAccess(System.String,System.String)">
<summary>
 The union type for union case &apos;%s&apos; was defined with the RequireQualifiedAccessAttribute. Include the name of the union type (&apos;%s&apos;) in the name you are using.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1014)
</summary>
</member>
<member name="M:FSComp.SR.nrUnexpectedEmptyLongId">
<summary>
 Unexpected empty long identifier
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1009)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeInstantiationNeededToDisambiguateTypesWithSameName(System.String,System.String)">
<summary>
 Multiple types exist called &apos;%s&apos;, taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1005)
</summary>
</member>
<member name="M:FSComp.SR.nrTypeInstantiationIsMissingAndCouldNotBeInferred(System.String,System.String)">
<summary>
 The instantiation of the generic type &apos;%s&apos; is missing and can&apos;t be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1006)
</summary>
</member>
<member name="M:FSComp.SR.nrRecordTypeNeedsQualifiedAccess(System.String,System.String)">
<summary>
 The record type for the record field &apos;%s&apos; was defined with the RequireQualifiedAccessAttribute. Include the name of the record type (&apos;%s&apos;) in the name you are using.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1015)
</summary>
</member>
<member name="M:FSComp.SR.nrRecordDoesNotContainSuchLabel(System.String,System.String)">
<summary>
 The record type &apos;%s&apos; does not contain a label &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1010)
</summary>
</member>
<member name="M:FSComp.SR.nrNoConstructorsAvailableForType(System.String)">
<summary>
 No constructors are available for the type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1013)
</summary>
</member>
<member name="M:FSComp.SR.nrIsNotConstructorOrLiteral">
<summary>
 This is not a constructor or literal, or a constructor is being used incorrectly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1008)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidModuleExprType">
<summary>
 Invalid module/expression/type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1004)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidFieldLabel">
<summary>
 Invalid field label
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1011)
</summary>
</member>
<member name="M:FSComp.SR.nrInvalidExpression(System.String)">
<summary>
 Invalid expression &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1012)
</summary>
</member>
<member name="M:FSComp.SR.nrGlobalUsedOnlyAsFirstName">
<summary>
 &apos;global&apos; may only be used as the first name in a qualified path
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1007)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexerWithName2(System.String)">
<summary>
 This value is not a function and cannot be applied. Did you intend to access the indexer via &apos;%s[index]&apos;?
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1494)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexerWithName(System.String)">
<summary>
 This value is not a function and cannot be applied. Did you intend to access the indexer via &apos;%s.[index]&apos;?
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1492)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexerErrorCode">
<summary>
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1496)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexer2">
<summary>
 This expression is not a function and cannot be applied. Did you intend to access the indexer via &apos;expr[index]&apos;?
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1495)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeIndexer">
<summary>
 This expression is not a function and cannot be applied. Did you intend to access the indexer via &apos;expr.[index]&apos;?
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1493)
</summary>
</member>
<member name="M:FSComp.SR.notAFunctionButMaybeDeclaration">
<summary>
 This value is not a function and cannot be applied. Did you forget to terminate a declaration?
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1497)
</summary>
</member>
<member name="M:FSComp.SR.notAFunction">
<summary>
 This value is not a function and cannot be applied.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1491)
</summary>
</member>
<member name="M:FSComp.SR.noInvokeMethodsFound">
<summary>
 No Invoke methods found for delegate type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:981)
</summary>
</member>
<member name="M:FSComp.SR.noEqualSignAfterModule">
<summary>
 Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the &apos;=&apos; sign is not allowed. If this is a top-level module, consider removing the = to resolve this error.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:58)
</summary>
</member>
<member name="M:FSComp.SR.nicePrintOtherOverloadsN(System.Int32)">
<summary>
 + %d overloads
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1331)
</summary>
</member>
<member name="M:FSComp.SR.nicePrintOtherOverloads1">
<summary>
 + 1 overload
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1330)
</summary>
</member>
<member name="M:FSComp.SR.nativeResourceHeaderMalformed(System.String)">
<summary>
 Resource header beginning at offset %s is malformed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1565)
</summary>
</member>
<member name="M:FSComp.SR.nativeResourceFormatError">
<summary>
 Stream does not begin with a null resource and is not in &apos;.RES&apos; format.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1564)
</summary>
</member>
<member name="M:FSComp.SR.moreThanOneInvokeMethodFound">
<summary>
 More than one Invoke method found for delegate type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:982)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatStructEndNoLongerSupported">
<summary>
 The use of &apos;module M = struct ... end &apos; was deprecated in F# 2.0 and is no longer supported. Remove the &apos;struct&apos; and &apos;end&apos; and use indentation instead
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1098)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatSigEndNoLongerSupported">
<summary>
 The use of &apos;module M = sig ... end &apos; was deprecated in F# 2.0 and is no longer supported. Remove the &apos;sig&apos; and &apos;end&apos; and use indentation instead
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1096)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatSigColonNoLongerSupported">
<summary>
 The use of &apos;module M: sig ... end &apos; was deprecated in F# 2.0 and is no longer supported. Change the &apos;:&apos; to an &apos;=&apos; and remove the &apos;sig&apos; and &apos;end&apos; and use indentation instead
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1095)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatMultiPrefixTyparsNoLongerSupported">
<summary>
 The use of multiple parenthesized type parameters before a generic type name such as &apos;(int, int) Map&apos; was deprecated in F# 2.0 and is no longer supported
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1097)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatMessage(System.String)">
<summary>
 This construct is for ML compatibility. %s. You can disable this warning by using &apos;--mlcompatibility&apos; or &apos;--nowarn:62&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1091)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatLightOffNoLongerSupported">
<summary>
 The use of &apos;#light \&quot;off\&quot;&apos; or &apos;#indent \&quot;off\&quot;&apos; was deprecated in F# 2.0 and is no longer supported
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1094)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatKeyword(System.String)">
<summary>
 In previous versions of F# &apos;%s&apos; was a reserved keyword but the use of this keyword is now deprecated
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1093)
</summary>
</member>
<member name="M:FSComp.SR.mlCompatError(System.String)">
<summary>
 This construct is deprecated. %s. You can enable this feature by using &apos;--langversion:5.0&apos; and &apos;--mlcompatibility&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1092)
</summary>
</member>
<member name="M:FSComp.SR.missingElseBranch(System.String)">
<summary>
 This &apos;if&apos; expression is missing an &apos;else&apos; branch. Because &apos;if&apos; is an expression, and not a statement, add an &apos;else&apos; branch which also returns a value of type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:26)
</summary>
</member>
<member name="M:FSComp.SR.methodIsNotStatic(System.String)">
<summary>
 Method or object constructor &apos;%s&apos; is not static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1397)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNonTripleArgument(System.String,System.Int32)">
<summary>
 Infix operator member &apos;%s&apos; has %d initial argument(s). Expected a tuple of 3 arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1342)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNonPairArgument(System.String,System.Int32)">
<summary>
 Infix operator member &apos;%s&apos; has %d initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1058)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithNoArguments(System.String)">
<summary>
 Infix operator member &apos;%s&apos; has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1057)
</summary>
</member>
<member name="M:FSComp.SR.memberOperatorDefinitionWithCurriedArguments(System.String)">
<summary>
 Infix operator member &apos;%s&apos; has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ...
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1059)
</summary>
</member>
<member name="M:FSComp.SR.matchNotAllowedForUnionCaseWithNoData">
<summary>
 Pattern discard is not allowed for union case that takes no data.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1723)
</summary>
</member>
<member name="M:FSComp.SR.loadingDescription">
<summary>
 (loading description...)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1338)
</summary>
</member>
<member name="M:FSComp.SR.listElementHasWrongTypeTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 All elements of a list must be implicitly convertible to the type of the first element, which here is a tuple of length %d of type\n    %s    \nThis element is a tuple of length %d of type\n    %s    \n
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:23)
</summary>
</member>
<member name="M:FSComp.SR.listElementHasWrongType(System.String,System.String)">
<summary>
 All elements of a list must be implicitly convertible to the type of the first element, which here is &apos;%s&apos;. This element has type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:22)
</summary>
</member>
<member name="M:FSComp.SR.lexhlpIdentifiersContainingAtSymbolReserved">
<summary>
 Identifiers containing &apos;@&apos; are reserved for use in F# code generation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:986)
</summary>
</member>
<member name="M:FSComp.SR.lexhlpIdentifierReserved(System.String)">
<summary>
 The identifier &apos;%s&apos; is reserved for future use by F#
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:987)
</summary>
</member>
<member name="M:FSComp.SR.lexfltTokenIsOffsideOfContextStartedEarlier(System.String)">
<summary>
 Unexpected syntax or possible incorrect indentation: this token is offside of context started at position %s. Try indenting this further.\nTo continue using non-conforming indentation, pass the &apos;--strict-indentation-&apos; flag to the compiler, or set the language version to F# 7.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1002)
</summary>
</member>
<member name="M:FSComp.SR.lexfltSeparatorTokensOfPatternMatchMisaligned">
<summary>
 The &apos;|&apos; tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1003)
</summary>
</member>
<member name="M:FSComp.SR.lexfltIncorrentIndentationOfIn">
<summary>
 The indentation of this &apos;in&apos; token is incorrect with respect to the corresponding &apos;let&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1001)
</summary>
</member>
<member name="M:FSComp.SR.lexWrongNestedHashEndif">
<summary>
 Syntax error. Wrong nested #endif, unexpected tokens before it.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1054)
</summary>
</member>
<member name="M:FSComp.SR.lexUnmatchedRBracesInTripleQuote">
<summary>
 The interpolated string contains unmatched closing braces.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1132)
</summary>
</member>
<member name="M:FSComp.SR.lexUnexpectedChar(System.String)">
<summary>
 Unexpected character &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1022)
</summary>
</member>
<member name="M:FSComp.SR.lexTripleQuoteInTripleQuote">
<summary>
 Invalid interpolated string. Triple quote string literals may not be used in interpolated expressions. Consider using an explicit &apos;let&apos; binding for the interpolation expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1653)
</summary>
</member>
<member name="M:FSComp.SR.lexTooManyPercentsInTripleQuote">
<summary>
 The interpolated triple quoted string literal does not start with enough &apos;$&apos; characters to allow this many consecutive &apos;%%&apos; characters.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1133)
</summary>
</member>
<member name="M:FSComp.SR.lexTooManyLBracesInTripleQuote">
<summary>
 The interpolated triple quoted string literal does not start with enough &apos;$&apos; characters to allow this many consecutive opening braces as content.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1131)
</summary>
</member>
<member name="M:FSComp.SR.lexTokenReserved">
<summary>
 This token is reserved for future use
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1044)
</summary>
</member>
<member name="M:FSComp.SR.lexThisUnicodeOnlyInStringLiterals">
<summary>
 This Unicode encoding is only valid in string literals
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1043)
</summary>
</member>
<member name="M:FSComp.SR.lexTabsNotAllowed">
<summary>
 TABs are not allowed in F# code unless the #indent \&quot;off\&quot; option is used
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1045)
</summary>
</member>
<member name="M:FSComp.SR.lexSingleQuoteInSingleQuote">
<summary>
 Invalid interpolated string. Single quote or verbatim string literals may not be used in interpolated expressions in single quote or verbatim strings. Consider using an explicit &apos;let&apos; binding for the interpolation expression or use a triple quote string as the outer string literal.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1652)
</summary>
</member>
<member name="M:FSComp.SR.lexRBraceInInterpolatedString">
<summary>
 A &apos;}&apos; character must be escaped (by doubling) in an interpolated string.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1661)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitUnsigned">
<summary>
 This number is outside the allowable range for 32-bit unsigned integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1031)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitSigned">
<summary>
 This number is outside the allowable range for 32-bit signed integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1030)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideThirtyTwoBitFloat">
<summary>
 This number is outside the allowable range for 32-bit floats
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1038)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixtyFourBitUnsigned">
<summary>
 This number is outside the allowable range for 64-bit unsigned integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1033)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixtyFourBitSigned">
<summary>
 This number is outside the allowable range for 64-bit signed integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1032)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixteenBitUnsigned">
<summary>
 This number is outside the allowable range for 16-bit unsigned integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1029)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideSixteenBitSigned">
<summary>
 This number is outside the allowable range for 16-bit signed integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1028)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideNativeUnsigned">
<summary>
 This number is outside the allowable range for unsigned native integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1035)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideNativeSigned">
<summary>
 This number is outside the allowable range for signed native integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1034)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideIntegerRange">
<summary>
 This number is outside the allowable range for this integer type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1017)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitUnsigned">
<summary>
 This number is outside the allowable range for 8-bit unsigned integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1027)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitSignedHex">
<summary>
 This number is outside the allowable range for hexadecimal 8-bit signed integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1026)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideEightBitSigned">
<summary>
 This number is outside the allowable range for 8-bit signed integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1025)
</summary>
</member>
<member name="M:FSComp.SR.lexOutsideDecimal">
<summary>
 This number is outside the allowable range for decimal literals
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1037)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidUnicodeLiteral(System.String)">
<summary>
 \U%s is not a valid Unicode character escape sequence
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1128)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidTrigraphAsciiByteLiteral">
<summary>
 This is not a valid byte character literal. The value must be less than or equal to &apos;\127&apos;B.\nNote: In a future F# version this warning will be promoted to an error.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1041)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidNumericLiteral">
<summary>
 This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0o1, 0b1, 1l (int/int32), 1u (uint/uint32), 1L (int64), 1UL (uint64), 1s (int16), 1us (uint16), 1y (int8/sbyte), 1uy (uint8/byte), 1.0 (float/double), 1.0f (float32/single), 1.0m (decimal), 1I (bigint).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1039)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidLineNumber(System.String)">
<summary>
 Invalid line number: &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1046)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidIdentifier">
<summary>
 This is not a valid identifier
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1739)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidFloat">
<summary>
 Invalid floating point number
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1036)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidCharLiteralInString(System.String,System.String)">
<summary>
 &apos;%s&apos; is not a valid character literal.\nNote: Currently the value is wrapped around byte range to &apos;%s&apos;. In a future F# version this warning will be promoted to an error.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1135)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidCharLiteral">
<summary>
 This is not a valid character literal
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1042)
</summary>
</member>
<member name="M:FSComp.SR.lexInvalidAsciiByteLiteral">
<summary>
 This is not a valid byte character literal. The value must be less than or equal to &apos;\127&apos;B.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1040)
</summary>
</member>
<member name="M:FSComp.SR.lexIndentOffForML">
<summary>
 Consider using a file with extension &apos;.ml&apos; or &apos;.mli&apos; instead
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1104)
</summary>
</member>
<member name="M:FSComp.SR.lexIfOCaml">
<summary>
 IF-FSHARP/IF-CAML regions are no longer supported
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1105)
</summary>
</member>
<member name="M:FSComp.SR.lexIdentEndInMarkReserved(System.String)">
<summary>
 Identifiers followed by &apos;%s&apos; are reserved for future use
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1024)
</summary>
</member>
<member name="M:FSComp.SR.lexHashIfMustHaveIdent">
<summary>
 #if directive should be immediately followed by an identifier
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1053)
</summary>
</member>
<member name="M:FSComp.SR.lexHashIfMustBeFirst">
<summary>
 #if directive must appear as the first non-whitespace character on a line
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1047)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndingNoMatchingIf">
<summary>
 #endif has no matching #if
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1051)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndifRequiredForElse">
<summary>
 #endif required for #else
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1049)
</summary>
</member>
<member name="M:FSComp.SR.lexHashEndifMustBeFirst">
<summary>
 #endif directive must appear as the first non-whitespace character on a line
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1052)
</summary>
</member>
<member name="M:FSComp.SR.lexHashElseNoMatchingIf">
<summary>
 #else has no matching #if
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1048)
</summary>
</member>
<member name="M:FSComp.SR.lexHashElseMustBeFirst">
<summary>
 #else directive must appear as the first non-whitespace character on a line
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1050)
</summary>
</member>
<member name="M:FSComp.SR.lexHashBangMustBeFirstInFile">
<summary>
 #! may only appear as the first line at the start of a file.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1055)
</summary>
</member>
<member name="M:FSComp.SR.lexExtendedStringInterpolationNotSupported">
<summary>
 Extended string interpolation is not supported in this version of F#.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1134)
</summary>
</member>
<member name="M:FSComp.SR.lexCharNotAllowedInOperatorNames(System.String)">
<summary>
 &apos;%s&apos; is not permitted as a character in operator names and is reserved for future use
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1021)
</summary>
</member>
<member name="M:FSComp.SR.lexByteStringMayNotBeInterpolated">
<summary>
 a byte string may not be interpolated
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1655)
</summary>
</member>
<member name="M:FSComp.SR.lexByteArrayOutisdeAscii(System.Int32)">
<summary>
 This byte array literal contains %d non-ASCII characters. All characters should be &lt; 128y.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1136)
</summary>
</member>
<member name="M:FSComp.SR.lexByteArrayCannotEncode(System.Int32)">
<summary>
 This byte array literal contains %d characters that do not encode as a single byte
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1023)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionYieldBang">
<summary>
 Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1481)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionYield">
<summary>
 Used in a sequence expression to produce a value for a sequence.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1480)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionWith">
<summary>
 Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1479)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionWhileBang">
<summary>
 Used in computation expressions to introduce a looping construct where the condition is the result of another computation expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1478)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionWhile">
<summary>
 Introduces a looping construct.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1477)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionWhen">
<summary>
 Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1476)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionVoid">
<summary>
 Indicates the .NET void type. Used when interoperating with other .NET languages.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1475)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionVal">
<summary>
 Used in a signature to indicate a value, or in a type to declare a member, in limited situations.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1474)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionUseBang">
<summary>
 Used instead of let! in computation expressions for computation expression results that implement IDisposable.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1473)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionUse">
<summary>
 Used instead of let for values that implement IDisposable
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1472)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionUpcast">
<summary>
 Used to convert to a type that is higher in the inheritance chain.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1471)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionUntypedQuotation">
<summary>
 Delimits a untyped code quotation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1487)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTypedQuotation">
<summary>
 Delimits a typed code quotation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1486)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTypeTest">
<summary>
 Used to check if an object is of the given type in a pattern or binding.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1470)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionType">
<summary>
 Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1469)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTry">
<summary>
 Used to introduce a block of code that might generate an exception. Used together with &apos;with&apos; or &apos;finally&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1468)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTrueFalse">
<summary>
 Used as a Boolean literal.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1429)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionTo">
<summary>
 Used in for loops to indicate a range.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1467)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionThen">
<summary>
 Used in conditional expressions. Also used to perform side effects after object construction.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1466)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionStruct">
<summary>
 Used to declare a structure type. Also used in generic parameter constraints.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1465)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionStatic">
<summary>
 Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1464)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionSig">
<summary>
 Keyword reserved for ML-compatibility.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1463)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionSelect">
<summary>
 Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1462)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionRightArrow">
<summary>
 In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1482)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionReturnBang">
<summary>
 Used to provide a value for the result of the containing computation expression, where that value itself comes from the result another computation expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1461)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionReturn">
<summary>
 Used to provide a value for the result of the containing computation expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1460)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionRec">
<summary>
 Used to indicate that a function is recursive.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1459)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionPublic">
<summary>
 Allows access to a member from outside the type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1458)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionPrivate">
<summary>
 Restricts access to a member to code in the same type or module.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1457)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionOverride">
<summary>
 Used to implement a version of an abstract or virtual method that differs from the base version.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1456)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionOr">
<summary>
 Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1455)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionOpen">
<summary>
 Used to make the contents of a namespace or module available without qualification.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1454)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionOf">
<summary>
 Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1453)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionNull">
<summary>
 Indicates the absence of an object. Also used in generic parameter constraints.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1452)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionNot">
<summary>
 Not actually a keyword. However, not struct in combination is used as a generic parameter constraint.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1451)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionNew">
<summary>
 Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1450)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionNamespace">
<summary>
 Used to associate a name with a group of related types and modules, to logically separate it from other code.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1449)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionMutable">
<summary>
 Used to declare a variable, that is, a value that can be changed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1448)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionModule">
<summary>
 Used to associate a name with a group of related types, values, and functions, to logically separate it from other code.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1447)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionMember">
<summary>
 Used to declare a property or method in an object type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1446)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionMatchBang">
<summary>
 Used in computation expressions to pattern match directly over the result of another computation expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1445)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionMatch">
<summary>
 Used to branch by comparing a value to a pattern.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1444)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionLetBang">
<summary>
 Used in computation expressions to bind a name to the result of another computation expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1443)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionLet">
<summary>
 Used to associate, or bind, a name to a value or function.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1442)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionLeftArrow">
<summary>
 Assigns a value to a variable.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1483)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionLazy">
<summary>
 Used to specify a computation that is to be performed only when a result is needed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1441)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionInternal">
<summary>
 Used to specify that a member is visible inside an assembly but not outside it.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1440)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionInterface">
<summary>
 Used to declare and implement interfaces.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1439)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionInline">
<summary>
 Used to indicate a function that should be integrated directly into the caller&apos;s code.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1438)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionInherit">
<summary>
 Used to specify a base class or base interface.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1437)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionIn">
<summary>
 Used for sequence expressions and, in verbose syntax, to separate expressions from bindings.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1436)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionIf">
<summary>
 Used in conditional branching constructs.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1435)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionGlobal">
<summary>
 Used to reference the top-level .NET namespace.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1434)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionFunction">
<summary>
 Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1433)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionFun">
<summary>
 Used in lambda expressions, also known as anonymous functions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1432)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionFor">
<summary>
 Used in looping constructs.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1431)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionFinally">
<summary>
 Used together with try to introduce a block of code that executes regardless of whether an exception occurs.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1430)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionExtern">
<summary>
 Indicates that a declared program element is defined in another binary or assembly.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1428)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionException">
<summary>
 Used to declare an exception type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1427)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionEnd">
<summary>
 In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1426)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionElse">
<summary>
 Used in conditional branching.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1425)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionElif">
<summary>
 Used in conditional branching. A short form of else if.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1424)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDynamicCast">
<summary>
 Converts a type to a type that is lower in the hierarchy.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1485)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDownto">
<summary>
 In a for expression, used when counting in reverse.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1423)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDowncast">
<summary>
 Used to convert to a type that is lower in the inheritance chain.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1422)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDone">
<summary>
 In verbose syntax, indicates the end of a block of code in a looping expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1421)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDo">
<summary>
 Used in looping constructs or to execute imperative code.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1420)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDelegate">
<summary>
 Used to declare a delegate.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1419)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionDefault">
<summary>
 Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1418)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionConst">
<summary>
 Keyword to specify a constant literal as a type parameter argument in Type Providers.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1417)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionClass">
<summary>
 In verbose syntax, indicates the start of a class definition.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1416)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionCast">
<summary>
 Converts a type to type that is higher in the hierarchy.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1484)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionBegin">
<summary>
 In verbose syntax, indicates the start of a code block.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1415)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionBase">
<summary>
 Used as the name of the base class object.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1414)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionAssert">
<summary>
 Used to verify code during debugging.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1413)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionAs">
<summary>
 Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1412)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionAnd">
<summary>
 Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1411)
</summary>
</member>
<member name="M:FSComp.SR.keywordDescriptionAbstract">
<summary>
 Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1410)
</summary>
</member>
<member name="M:FSComp.SR.itemNotFoundInTypeDuringDynamicCodeGen(System.String,System.String,System.String,System.String)">
<summary>
 %s &apos;%s&apos; not found in type &apos;%s&apos; from assembly &apos;%s&apos;. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1489)
</summary>
</member>
<member name="M:FSComp.SR.itemNotFoundDuringDynamicCodeGen(System.String,System.String,System.String)">
<summary>
 %s &apos;%s&apos; not found in assembly &apos;%s&apos;. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1488)
</summary>
</member>
<member name="M:FSComp.SR.invalidXmlDocPosition">
<summary>
 XML comment is not placed on a valid language element.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1707)
</summary>
</member>
<member name="M:FSComp.SR.invalidPlatformTarget">
<summary>
 The &apos;anycpu32bitpreferred&apos; platform can only be used with EXE targets. You must use &apos;anycpu&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1325)
</summary>
</member>
<member name="M:FSComp.SR.invalidNamespaceForProvidedType">
<summary>
 invalid namespace for provided type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1221)
</summary>
</member>
<member name="M:FSComp.SR.invalidFullNameForProvidedType">
<summary>
 invalid full name for provided type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1222)
</summary>
</member>
<member name="M:FSComp.SR.infosInvalidProvidedLiteralValue(System.String)">
<summary>
 Invalid provided literal value &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1324)
</summary>
</member>
<member name="M:FSComp.SR.implicitlyDiscardedSequenceInSequenceExpression(System.String)">
<summary>
 This expression returns a value of type &apos;%s&apos; but is implicitly discarded. Consider using &apos;let&apos; to bind the result to a name, e.g. &apos;let result = expression&apos;. If you intended to use the expression as a value in the sequence then use an explicit &apos;yield!&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1501)
</summary>
</member>
<member name="M:FSComp.SR.implicitlyDiscardedInSequenceExpression(System.String)">
<summary>
 This expression returns a value of type &apos;%s&apos; but is implicitly discarded. Consider using &apos;let&apos; to bind the result to a name, e.g. &apos;let result = expression&apos;. If you intended to use the expression as a value in the sequence then use an explicit &apos;yield&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1500)
</summary>
</member>
<member name="M:FSComp.SR.implMissingInlineIfLambda">
<summary>
 The &apos;InlineIfLambda&apos; attribute is present in the signature but not the implementation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1705)
</summary>
</member>
<member name="M:FSComp.SR.impTypeRequiredUnavailable(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is required here and is unavailable. You must add a reference to assembly &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:990)
</summary>
</member>
<member name="M:FSComp.SR.impReferencedTypeCouldNotBeFoundInAssembly(System.String,System.String)">
<summary>
 A reference to the type &apos;%s&apos; in assembly &apos;%s&apos; was found, but the type could not be found in that assembly
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:991)
</summary>
</member>
<member name="M:FSComp.SR.impReferenceToDllRequiredByAssembly(System.String,System.String,System.String)">
<summary>
 A reference to the DLL %s is required by assembly %s. The imported type %s is located in the first assembly and could not be resolved.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:993)
</summary>
</member>
<member name="M:FSComp.SR.impNotEnoughTypeParamsInScopeWhileImporting">
<summary>
 Internal error or badly formed metadata: not enough type parameters were in scope while importing
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:992)
</summary>
</member>
<member name="M:FSComp.SR.impInvalidNumberOfGenericArguments(System.String,System.Int32,System.Int32)">
<summary>
 Invalid number of generic arguments to type &apos;%s&apos; in provided type. Expected &apos;%d&apos; arguments, given &apos;%d&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1301)
</summary>
</member>
<member name="M:FSComp.SR.impInvalidMeasureArgument2(System.String)">
<summary>
 Invalid value unit-of-measure parameter &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1303)
</summary>
</member>
<member name="M:FSComp.SR.impInvalidMeasureArgument1(System.String,System.String)">
<summary>
 Invalid value &apos;%s&apos; for unit-of-measure parameter &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1302)
</summary>
</member>
<member name="M:FSComp.SR.impImportedAssemblyUsesNotPublicType(System.String)">
<summary>
 An imported assembly uses the type &apos;%s&apos; but that type is not public
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:994)
</summary>
</member>
<member name="M:FSComp.SR.ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen">
<summary>
 Invalid argument to &apos;methodhandleof&apos; during codegen
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1263)
</summary>
</member>
<member name="M:FSComp.SR.ilxgenInvalidConstructInStateMachineDuringCodegen(System.String)">
<summary>
 The resumable code construct &apos;%s&apos; may only be used in inlined code protected by &apos;if __useResumableCode then ...&apos; and the overall composition must form valid resumable code.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1682)
</summary>
</member>
<member name="M:FSComp.SR.ilxGenUnknownDebugPoint(System.String,System.String)">
<summary>
 Unknown debug point &apos;%s&apos;. The available debug points are &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1693)
</summary>
</member>
<member name="M:FSComp.SR.ilwriteErrorCreatingPdb(System.String)">
<summary>
 Unexpected error creating debug information file &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1016)
</summary>
</member>
<member name="M:FSComp.SR.ilreadFileChanged(System.String)">
<summary>
 The file &apos;%s&apos; changed on disk unexpectedly, please reload.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1502)
</summary>
</member>
<member name="M:FSComp.SR.ilUnexpectedUnrealizedValue">
<summary>
 Compiler error: unexpected unrealized value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:835)
</summary>
</member>
<member name="M:FSComp.SR.ilUnexpectedGetSetAnnotation">
<summary>
 Unexpected GetSet annotation on a property
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:838)
</summary>
</member>
<member name="M:FSComp.SR.ilUndefinedValue(System.String)">
<summary>
 Undefined value &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:822)
</summary>
</member>
<member name="M:FSComp.SR.ilTypeCannotBeUsedForLiteralField">
<summary>
 This type cannot be used for a literal field
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:837)
</summary>
</member>
<member name="M:FSComp.SR.ilStructLayoutAttributeCouldNotBeDecoded">
<summary>
 The StructLayout attribute could not be decoded
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:840)
</summary>
</member>
<member name="M:FSComp.SR.ilStaticMethodIsNotLambda(System.String)">
<summary>
 GenSetStorage: %s was represented as a static method but was not an appropriate lambda expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:833)
</summary>
</member>
<member name="M:FSComp.SR.ilSignatureForExternalFunctionContainsTypeParameters">
<summary>
 The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:830)
</summary>
</member>
<member name="M:FSComp.SR.ilSignRsaKeyExpected">
<summary>
 RSA key expected
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1145)
</summary>
</member>
<member name="M:FSComp.SR.ilSignPrivateKeyExpected">
<summary>
 Private key expected
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1144)
</summary>
</member>
<member name="M:FSComp.SR.ilSignNoSignatureDirectory">
<summary>
 No signature directory
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1150)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidSignatureSize">
<summary>
 Invalid signature size
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1149)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidRSAParams">
<summary>
 Invalid RSAParameters structure - &apos;{0}&apos; expected
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1147)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidPKBlob">
<summary>
 Invalid Public Key blob
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1151)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidMagicValue">
<summary>
 Invalid Magic value in CLR Header
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1142)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidBitLen">
<summary>
 Invalid bit Length
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1146)
</summary>
</member>
<member name="M:FSComp.SR.ilSignInvalidAlgId">
<summary>
 Invalid algId - &apos;Exponent&apos; expected
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1148)
</summary>
</member>
<member name="M:FSComp.SR.ilSignBadImageFormat">
<summary>
 Bad image format
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1143)
</summary>
</member>
<member name="M:FSComp.SR.ilReflectedDefinitionsCannotUseSliceOperator">
<summary>
 Reflected definitions cannot contain uses of the prefix splice operator &apos;%%&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:842)
</summary>
</member>
<member name="M:FSComp.SR.ilMutableVariablesCannotEscapeMethod">
<summary>
 Mutable variables cannot escape their method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:834)
</summary>
</member>
<member name="M:FSComp.SR.ilMarshalAsAttributeCannotBeDecoded">
<summary>
 The MarshalAs attribute could not be decoded
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:829)
</summary>
</member>
<member name="M:FSComp.SR.ilMainModuleEmpty">
<summary>
 Main module of program is empty: nothing will happen when it is run
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:836)
</summary>
</member>
<member name="M:FSComp.SR.ilLiteralFieldsCannotBeSet">
<summary>
 Literal fields cannot be set
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:832)
</summary>
</member>
<member name="M:FSComp.SR.ilLabelNotFound(System.String)">
<summary>
 Label %s not found
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:823)
</summary>
</member>
<member name="M:FSComp.SR.ilIncorrectNumberOfTypeArguments">
<summary>
 Incorrect number of type arguments to local call
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:824)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldOffsetAttributeCouldNotBeDecoded">
<summary>
 The FieldOffset attribute could not be decoded
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:839)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldHasOffsetForSequentialLayout">
<summary>
 The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1108)
</summary>
</member>
<member name="M:FSComp.SR.ilFieldDoesNotHaveValidOffsetForStructureLayout(System.String,System.String)">
<summary>
 The type &apos;%s&apos; has been marked as having an Explicit layout, but the field &apos;%s&apos; has not been marked with the &apos;FieldOffset&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1099)
</summary>
</member>
<member name="M:FSComp.SR.ilDynamicInvocationNotSupported(System.String)">
<summary>
 Dynamic invocation of %s is not supported
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:825)
</summary>
</member>
<member name="M:FSComp.SR.ilDllImportAttributeCouldNotBeDecoded">
<summary>
 The DllImport attribute could not be decoded
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:831)
</summary>
</member>
<member name="M:FSComp.SR.ilDefaultAugmentationAttributeCouldNotBeDecoded">
<summary>
 The DefaultAugmentation attribute could not be decoded
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:841)
</summary>
</member>
<member name="M:FSComp.SR.ilCustomMarshallersCannotBeUsedInFSharp">
<summary>
 Custom marshallers cannot be specified in F# code. Consider using a C# helper function.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:828)
</summary>
</member>
<member name="M:FSComp.SR.ilAddressOfValueHereIsInvalid(System.String)">
<summary>
 This operation involves taking the address of a value &apos;%s&apos; represented using a local variable or other special representation. This is invalid.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:827)
</summary>
</member>
<member name="M:FSComp.SR.ilAddressOfLiteralFieldIsInvalid">
<summary>
 Taking the address of a literal field is invalid
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:826)
</summary>
</member>
<member name="M:FSComp.SR.ifExpressionTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 The &apos;if&apos; expression needs to return a tuple of length %d of type\n    %s    \nto satisfy context type requirements. It currently returns a tuple of length %d of type\n    %s    \n
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:28)
</summary>
</member>
<member name="M:FSComp.SR.ifExpression(System.String,System.String)">
<summary>
 The &apos;if&apos; expression needs to have type &apos;%s&apos; to satisfy context type requirements. It currently has type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:27)
</summary>
</member>
<member name="P:FSComp.SR.SwallowResourceText">
<summary>
 If set to true, then all error messages will just return the filled &apos;holes&apos; delimited by &apos;,,,&apos;s - this is for language-neutral testing (e.g. localization-invariant baselines).
</summary>
</member>
<member name="M:FSComp.SR.fsiInvalidDirective(System.String,System.String)">
<summary>
 Invalid directive &apos;#%s %s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1556)
</summary>
</member>
<member name="M:FSComp.SR.fsharpCoreNotFoundToBeCopied">
<summary>
 Cannot find FSharp.Core.dll in compiler&apos;s directory
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1378)
</summary>
</member>
<member name="M:FSComp.SR.fscTwoResourceManifests">
<summary>
 Conflicting options specified: &apos;win32manifest&apos; and &apos;win32res&apos;. Only one of these can be used.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1157)
</summary>
</member>
<member name="M:FSComp.SR.fscTooManyErrors">
<summary>
 Exiting - too many errors
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1153)
</summary>
</member>
<member name="M:FSComp.SR.fscSystemRuntimeInteropServicesIsRequired">
<summary>
 System.Runtime.InteropServices assembly is required to use UnknownWrapper\DispatchWrapper classes.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1360)
</summary>
</member>
<member name="M:FSComp.SR.fscStaticLinkingNoProfileMismatches">
<summary>
 Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1176)
</summary>
</member>
<member name="M:FSComp.SR.fscStaticLinkingNoMixedDLL">
<summary>
 Static linking may not include a mixed managed/unmanaged DLL
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1161)
</summary>
</member>
<member name="M:FSComp.SR.fscStaticLinkingNoEXE">
<summary>
 Static linking may not include a .EXE
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1160)
</summary>
</member>
<member name="M:FSComp.SR.fscResxSourceFileDeprecated(System.String)">
<summary>
 Passing a .resx file (%s) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an &lt;EmbeddedResource&gt; item in the .fsproj project file.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1175)
</summary>
</member>
<member name="M:FSComp.SR.fscRemotingError">
<summary>
 The resident compilation service was not used because a problem occurred in communicating with the server.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1173)
</summary>
</member>
<member name="M:FSComp.SR.fscReferenceOnCommandLine(System.String)">
<summary>
 The assembly &apos;%s&apos; is listed on the command line. Assemblies should be referenced using a command line flag such as &apos;-r&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1172)
</summary>
</member>
<member name="M:FSComp.SR.fscQuotationLiteralsStaticLinking0">
<summary>
 Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1159)
</summary>
</member>
<member name="M:FSComp.SR.fscQuotationLiteralsStaticLinking(System.String)">
<summary>
 The code in assembly &apos;%s&apos; makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1158)
</summary>
</member>
<member name="M:FSComp.SR.fscProblemWritingBinary(System.String,System.String)">
<summary>
 A problem occurred writing the binary &apos;%s&apos;: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1166)
</summary>
</member>
<member name="M:FSComp.SR.fscNoImplementationFiles">
<summary>
 No implementation files specified
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1155)
</summary>
</member>
<member name="M:FSComp.SR.fscKeyNameWarning">
<summary>
 Option &apos;--keycontainer&apos; overrides attribute &apos;System.Reflection.AssemblyNameAttribute&apos; given in a source file or added module
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1171)
</summary>
</member>
<member name="M:FSComp.SR.fscKeyFileWarning">
<summary>
 Option &apos;--keyfile&apos; overrides attribute &apos;System.Reflection.AssemblyKeyFileAttribute&apos; given in a source file or added module
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1170)
</summary>
</member>
<member name="M:FSComp.SR.fscKeyFileCouldNotBeOpened(System.String)">
<summary>
 The key file &apos;%s&apos; could not be opened
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1165)
</summary>
</member>
<member name="M:FSComp.SR.fscIgnoringMixedWhenLinking(System.String)">
<summary>
 Ignoring mixed managed/unmanaged assembly &apos;%s&apos; during static linking
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1162)
</summary>
</member>
<member name="M:FSComp.SR.fscDelaySignWarning">
<summary>
 Option &apos;--delaysign&apos; overrides attribute &apos;System.Reflection.AssemblyDelaySignAttribute&apos; given in a source file or added module
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1169)
</summary>
</member>
<member name="M:FSComp.SR.fscBadAssemblyVersion(System.String,System.String)">
<summary>
 The attribute %s specified version &apos;%s&apos;, but this value is invalid and has been ignored
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1156)
</summary>
</member>
<member name="M:FSComp.SR.fscAssumeStaticLinkContainsNoDependencies(System.String)">
<summary>
 Assembly &apos;%s&apos; was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1163)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyWildcardAndDeterminism(System.String,System.String)">
<summary>
 An %s specified version &apos;%s&apos;, but this value is a wildcard, and you have requested a deterministic build, these are in conflict.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1177)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyVersionAttributeIgnored">
<summary>
 The &apos;AssemblyVersionAttribute&apos; has been ignored because a version was given using a command line option
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1167)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyNotFoundInDependencySet(System.String)">
<summary>
 Assembly &apos;%s&apos; not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1164)
</summary>
</member>
<member name="M:FSComp.SR.fscAssemblyCultureAttributeError">
<summary>
 Error emitting &apos;System.Reflection.AssemblyCultureAttribute&apos; attribute -- &apos;Executables cannot be satellite assemblies, Culture should always be empty&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1168)
</summary>
</member>
<member name="M:FSComp.SR.fromEndSlicingRequiresVFive">
<summary>
 The &apos;from the end slicing&apos; feature requires language version &apos;preview&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1547)
</summary>
</member>
<member name="M:FSComp.SR.formatDashItem(System.String)">
<summary>
  - %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1566)
</summary>
</member>
<member name="M:FSComp.SR.forPrefixFlagSpacePlusSetTwice">
<summary>
 Prefix flag (&apos; &apos; or &apos;+&apos;) set twice
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:232)
</summary>
</member>
<member name="M:FSComp.SR.forPrecisionMissingAfterDot">
<summary>
 Precision missing after the &apos;.&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:237)
</summary>
</member>
<member name="M:FSComp.SR.forPositionalSpecifiersNotPermitted">
<summary>
 Positional specifiers are not permitted in format strings
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:229)
</summary>
</member>
<member name="M:FSComp.SR.forPercentAInReflectionFreeCode">
<summary>
 The &apos;%%A&apos; format specifier may not be used in an assembly being compiled with option &apos;--reflectionfree&apos;. This construct implicitly uses reflection.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:244)
</summary>
</member>
<member name="M:FSComp.SR.forMissingFormatSpecifier">
<summary>
 Missing format specifier
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:230)
</summary>
</member>
<member name="M:FSComp.SR.forLIsUnnecessary">
<summary>
 The &apos;l&apos; or &apos;L&apos; in this format specifier is unnecessary. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:240)
</summary>
</member>
<member name="M:FSComp.SR.forHashSpecifierIsInvalid">
<summary>
 The # formatting modifier is invalid in F#
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:233)
</summary>
</member>
<member name="M:FSComp.SR.forHIsUnnecessary">
<summary>
 The &apos;h&apos; or &apos;H&apos; in this format specifier is unnecessary. You can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:241)
</summary>
</member>
<member name="M:FSComp.SR.forFormatInvalidForInterpolated4">
<summary>
 Interpolated strings used as type IFormattable or type FormattableString may not use &apos;%%&apos; specifiers, only .NET-style interpolands such as &apos;{expr}&apos;, &apos;{expr,3}&apos; or &apos;{expr:N5}&apos; may be used.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1649)
</summary>
</member>
<member name="M:FSComp.SR.forFormatInvalidForInterpolated3">
<summary>
 The &apos;%%P&apos; specifier may not be used explicitly.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1648)
</summary>
</member>
<member name="M:FSComp.SR.forFormatInvalidForInterpolated2">
<summary>
 .NET-style format specifiers such as &apos;{x,3}&apos; or &apos;{x:N5}&apos; may not be mixed with &apos;%%&apos; format specifiers.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1647)
</summary>
</member>
<member name="M:FSComp.SR.forFormatInvalidForInterpolated">
<summary>
 Interpolated strings may not use &apos;%%&apos; format specifiers unless each is given an expression, e.g. &apos;%%d{1+1}&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1646)
</summary>
</member>
<member name="M:FSComp.SR.forFormatDoesntSupportPrecision(System.String)">
<summary>
 &apos;%s&apos; format does not support precision
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:238)
</summary>
</member>
<member name="M:FSComp.SR.forFlagSetTwice(System.String)">
<summary>
 &apos;%s&apos; flag set twice
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:231)
</summary>
</member>
<member name="M:FSComp.SR.forDoesNotSupportZeroFlag(System.String)">
<summary>
 &apos;%s&apos; format does not support &apos;0&apos; flag
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:236)
</summary>
</member>
<member name="M:FSComp.SR.forDoesNotSupportPrefixFlag(System.String,System.String)">
<summary>
 &apos;%s&apos; does not support prefix &apos;%s&apos; flag
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:242)
</summary>
</member>
<member name="M:FSComp.SR.forBadWidth">
<summary>
 Bad width in format specifier
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:235)
</summary>
</member>
<member name="M:FSComp.SR.forBadPrecision">
<summary>
 Bad precision in format specifier
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:234)
</summary>
</member>
<member name="M:FSComp.SR.forBadFormatSpecifierGeneral(System.String)">
<summary>
 Bad format specifier: &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:243)
</summary>
</member>
<member name="M:FSComp.SR.forBadFormatSpecifier">
<summary>
 Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:239)
</summary>
</member>
<member name="M:FSComp.SR.followingPatternMatchClauseHasWrongTypeTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 All branches of a pattern match expression must return values implicitly convertible to the type of the first branch, which here is a tuple of length %d of type\n    %s    \nThis branch returns a tuple of length %d of type\n    %s    \n
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:32)
</summary>
</member>
<member name="M:FSComp.SR.followingPatternMatchClauseHasWrongType(System.String,System.String)">
<summary>
 All branches of a pattern match expression must return values implicitly convertible to the type of the first branch, which here is &apos;%s&apos;. This branch returns a value of type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:31)
</summary>
</member>
<member name="M:FSComp.SR.fieldIsNotAccessible(System.String)">
<summary>
 The record, struct or class field &apos;%s&apos; is not accessible from this code location
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:978)
</summary>
</member>
<member name="M:FSComp.SR.featureWitnessPassing">
<summary>
 witness passing for trait constraints in F# quotations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1583)
</summary>
</member>
<member name="M:FSComp.SR.featureWildCardInForLoop">
<summary>
 wild card in for loop
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1568)
</summary>
</member>
<member name="M:FSComp.SR.featureWhileBang">
<summary>
 &apos;while!&apos; expression
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1611)
</summary>
</member>
<member name="M:FSComp.SR.featureWarningWhenMultipleRecdTypeChoice">
<summary>
 Raises warnings when multiple record type matches were found during name resolution because of overlapping field names.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1606)
</summary>
</member>
<member name="M:FSComp.SR.featureWarningWhenInliningMethodImplNoInlineMarkedFunction">
<summary>
 Raises warnings when &apos;let inline ... =&apos; is used together with [&lt;MethodImpl(MethodImplOptions.NoInlining)&gt;] attribute. Function is not getting inlined.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1597)
</summary>
</member>
<member name="M:FSComp.SR.featureWarningWhenCopyAndUpdateRecordChangesAllFields">
<summary>
 Raises warnings when an copy-and-update record expression changes all fields of a record.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1601)
</summary>
</member>
<member name="M:FSComp.SR.featureWarningIndexedPropertiesGetSetSameType">
<summary>
 Indexed properties getter and setter must have the same type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1615)
</summary>
</member>
<member name="M:FSComp.SR.featureUnmanagedConstraintCsharpInterop">
<summary>
 Interop between C#&apos;s and F#&apos;s unmanaged generic constraint (emit additional modreq)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1754)
</summary>
</member>
<member name="M:FSComp.SR.featureUnionIsPropertiesVisible">
<summary>
 Union case test properties
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1617)
</summary>
</member>
<member name="M:FSComp.SR.featureTryWithInSeqExpressions">
<summary>
 Support for try-with in sequence expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1600)
</summary>
</member>
<member name="M:FSComp.SR.featureStructActivePattern">
<summary>
 struct representation for active patterns
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1585)
</summary>
</member>
<member name="M:FSComp.SR.featureStringInterpolation">
<summary>
 string interpolation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1582)
</summary>
</member>
<member name="M:FSComp.SR.featureStrictIndentation">
<summary>
 Raises errors on incorrect indentation, allows better recovery and analysis during editing
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1608)
</summary>
</member>
<member name="M:FSComp.SR.featureStaticMembersInInterfaces">
<summary>
 Static members in interfaces
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1602)
</summary>
</member>
<member name="M:FSComp.SR.featureStaticLetInRecordsDusEmptyTypes">
<summary>
 Allow static let bindings in union, record, struct, non-incremental-class types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1743)
</summary>
</member>
<member name="M:FSComp.SR.featureSingleUnderscorePattern">
<summary>
 single underscore pattern
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1567)
</summary>
</member>
<member name="M:FSComp.SR.featureSelfTypeConstraints">
<summary>
 self type constraints
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1590)
</summary>
</member>
<member name="M:FSComp.SR.featureReuseSameFieldsInStructUnions">
<summary>
 Share underlying fields in a [&lt;Struct&gt;] discriminated union as long as they have same name and type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1763)
</summary>
</member>
<member name="M:FSComp.SR.featureResumableStateMachines">
<summary>
 resumable state machines
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1579)
</summary>
</member>
<member name="M:FSComp.SR.featureRequiredProperties">
<summary>
 support for required properties
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1591)
</summary>
</member>
<member name="M:FSComp.SR.featureRelaxWhitespace2">
<summary>
 whitespace relaxation v2
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1586)
</summary>
</member>
<member name="M:FSComp.SR.featureRelaxWhitespace">
<summary>
 whitespace relaxation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1569)
</summary>
</member>
<member name="M:FSComp.SR.featureRefCellNotationInformationals">
<summary>
 informational messages related to reference cells
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1255)
</summary>
</member>
<member name="M:FSComp.SR.featureReallyLongList">
<summary>
 list literals of any size
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1587)
</summary>
</member>
<member name="M:FSComp.SR.featurePrintfBinaryFormat">
<summary>
 binary formatting for integers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1253)
</summary>
</member>
<member name="M:FSComp.SR.featurePreferStringGetPinnableReference">
<summary>
 prefer String.GetPinnableReference in fixed bindings
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1613)
</summary>
</member>
<member name="M:FSComp.SR.featurePreferExtensionMethodOverPlainProperty">
<summary>
 prefer extension method over plain property
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1614)
</summary>
</member>
<member name="M:FSComp.SR.featureParsedHashDirectiveUnexpectedInteger(System.Int32)">
<summary>
 Unexpected integer literal &apos;%d&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1779)
</summary>
</member>
<member name="M:FSComp.SR.featureParsedHashDirectiveUnexpectedIdentifier(System.String)">
<summary>
 Unexpected identifier &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1780)
</summary>
</member>
<member name="M:FSComp.SR.featureParsedHashDirectiveArgumentNonString">
<summary>
 # directives with non-quoted string arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1778)
</summary>
</member>
<member name="M:FSComp.SR.featurePackageManagement">
<summary>
 package management
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1574)
</summary>
</member>
<member name="M:FSComp.SR.featureOverloadsForCustomOperations">
<summary>
 overloads for custom operations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1251)
</summary>
</member>
<member name="M:FSComp.SR.featureOpenTypeDeclaration">
<summary>
 open type declaration
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1572)
</summary>
</member>
<member name="M:FSComp.SR.featureNullnessChecking">
<summary>
 nullness checking
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1578)
</summary>
</member>
<member name="M:FSComp.SR.featureNullableOptionalInterop">
<summary>
 nullable optional interop
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1580)
</summary>
</member>
<member name="M:FSComp.SR.featureNonVariablePatternsToRightOfAsPatterns">
<summary>
 non-variable patterns to the right of &apos;as&apos; patterns
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1257)
</summary>
</member>
<member name="M:FSComp.SR.featureNonInlineLiteralsAsPrintfFormat">
<summary>
 String values marked as literals and IL constants as printf format
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1603)
</summary>
</member>
<member name="M:FSComp.SR.featureNestedCopyAndUpdate">
<summary>
 Nested record field copy-and-update
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1604)
</summary>
</member>
<member name="M:FSComp.SR.featureNameOf">
<summary>
 nameof
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1570)
</summary>
</member>
<member name="M:FSComp.SR.featureMatchNotAllowedForUnionCaseWithNoData">
<summary>
 Pattern match discard is not allowed for union case that takes no data.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1594)
</summary>
</member>
<member name="M:FSComp.SR.featureMLCompatRevisions">
<summary>
 ML compatibility revisions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1259)
</summary>
</member>
<member name="M:FSComp.SR.featureLowercaseDUWhenRequireQualifiedAccess">
<summary>
 Allow lowercase DU when RequireQualifiedAccess attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1593)
</summary>
</member>
<member name="M:FSComp.SR.featureLowerSimpleMappingsInComprehensionsToFastLoops">
<summary>
 Lowers [for x in xs -&gt; f x] and [|for x in xs -&gt; f x|] to fast loops when xs is a list or an array, respectively.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1622)
</summary>
</member>
<member name="M:FSComp.SR.featureLowerInterpolatedStringToConcat">
<summary>
 Optimizes interpolated strings in certain cases, by lowering to concatenation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1620)
</summary>
</member>
<member name="M:FSComp.SR.featureLowerIntegralRangesToFastLoops">
<summary>
 Optimizes certain uses of the integral range (..) and range-step (.. ..) operators to fast while-loops.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1621)
</summary>
</member>
<member name="M:FSComp.SR.featureInterfacesWithMultipleGenericInstantiation">
<summary>
 interfaces with multiple generic instantiation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1629)
</summary>
</member>
<member name="M:FSComp.SR.featureInterfacesWithAbstractStaticMembers">
<summary>
 static abstract interface members
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1589)
</summary>
</member>
<member name="M:FSComp.SR.featureInitProperties">
<summary>
 support for consuming init properties
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1592)
</summary>
</member>
<member name="M:FSComp.SR.featureInformationalObjInferenceDiagnostic">
<summary>
 Diagnostic 3559 (warn when obj inferred) at informational level, off by default
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1742)
</summary>
</member>
<member name="M:FSComp.SR.featureIndexerNotationWithoutDot">
<summary>
 expr[idx] notation for indexing and slicing
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1254)
</summary>
</member>
<member name="M:FSComp.SR.featureImprovedImpliedArgumentNames">
<summary>
 Improved implied argument names
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1607)
</summary>
</member>
<member name="M:FSComp.SR.featureImplicitYield">
<summary>
 implicit yield
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1571)
</summary>
</member>
<member name="M:FSComp.SR.featureFromEndSlicing">
<summary>
 from-end slicing
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1575)
</summary>
</member>
<member name="M:FSComp.SR.featureFixedIndexSlice3d4d">
<summary>
 fixed-index slice 3d/4d
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1576)
</summary>
</member>
<member name="M:FSComp.SR.featureExtendedStringInterpolation">
<summary>
 Extended string interpolation similar to C# raw string literals.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1605)
</summary>
</member>
<member name="M:FSComp.SR.featureExtendedFixedBindings">
<summary>
 extended fixed bindings for byref and GetPinnableReference
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1612)
</summary>
</member>
<member name="M:FSComp.SR.featureExpandedMeasurables">
<summary>
 more types support units of measure
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1252)
</summary>
</member>
<member name="M:FSComp.SR.featureEscapeBracesInFormattableString">
<summary>
 Escapes curly braces before calling FormattableStringFactory.Create when interpolated string literal is typed as FormattableString
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1726)
</summary>
</member>
<member name="M:FSComp.SR.featureErrorReportingOnStaticClasses">
<summary>
 Error reporting on static classes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1599)
</summary>
</member>
<member name="M:FSComp.SR.featureErrorOnDeprecatedRequireQualifiedAccess">
<summary>
 give error on deprecated access of construct with RequireQualifiedAccess attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1588)
</summary>
</member>
<member name="M:FSComp.SR.featureErrorForNonVirtualMembersOverrides">
<summary>
 Raises errors for non-virtual members overrides
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1596)
</summary>
</member>
<member name="M:FSComp.SR.featureEnforceAttributeTargets">
<summary>
 Enforce AttributeTargets
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1619)
</summary>
</member>
<member name="M:FSComp.SR.featureEmptyBodiedComputationExpressions">
<summary>
 Support for computation expressions with empty bodies: builder { }
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1781)
</summary>
</member>
<member name="M:FSComp.SR.featureDotlessFloat32Literal">
<summary>
 dotless float32 literal
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1573)
</summary>
</member>
<member name="M:FSComp.SR.featureDiscardUseValue">
<summary>
 discard pattern in use binding
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1256)
</summary>
</member>
<member name="M:FSComp.SR.featureDelegateTypeNameResolutionFix">
<summary>
 fix to resolution of delegate type names, see https://github.com/dotnet/fsharp/issues/10228
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1261)
</summary>
</member>
<member name="M:FSComp.SR.featureDefaultInterfaceMemberConsumption">
<summary>
 default interface member consumption
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1581)
</summary>
</member>
<member name="M:FSComp.SR.featureConstraintIntersectionOnFlexibleTypes">
<summary>
 Constraint intersection on flexible types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1609)
</summary>
</member>
<member name="M:FSComp.SR.featureConsistentNowarnLineDirectiveInteraction">
<summary>
 The interaction between #nowarn and #line is now consistent.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1787)
</summary>
</member>
<member name="M:FSComp.SR.featureChkTailCallAttrOnNonRec">
<summary>
 Raises warnings if the &apos;TailCall&apos; attribute is used on non-recursive functions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1616)
</summary>
</member>
<member name="M:FSComp.SR.featureChkNotTailRecursive">
<summary>
 Raises warnings if a member or function has the &apos;TailCall&apos; attribute, but is not being used in a tail recursive way.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1610)
</summary>
</member>
<member name="M:FSComp.SR.featureCSharpExtensionAttributeNotRequired">
<summary>
 Allow implicit Extension attribute on declaring types, modules
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1595)
</summary>
</member>
<member name="M:FSComp.SR.featureBooleanReturningAndReturnTypeDirectedPartialActivePattern">
<summary>
 Boolean-returning and return-type-directed partial active patterns
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1618)
</summary>
</member>
<member name="M:FSComp.SR.featureBetterExceptionPrinting">
<summary>
 automatic generation of &apos;Message&apos; property for &apos;exception&apos; declarations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1260)
</summary>
</member>
<member name="M:FSComp.SR.featureAttributesToRightOfModuleKeyword">
<summary>
 attributes to the right of the &apos;module&apos; keyword
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1258)
</summary>
</member>
<member name="M:FSComp.SR.featureArithmeticInLiterals">
<summary>
 Arithmetic and logical operations in literals, enum definitions and attributes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1598)
</summary>
</member>
<member name="M:FSComp.SR.featureAndBang">
<summary>
 applicative computation expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1577)
</summary>
</member>
<member name="M:FSComp.SR.featureAllowObjectExpressionWithoutOverrides">
<summary>
 Allow object expressions without overrides
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1785)
</summary>
</member>
<member name="M:FSComp.SR.featureAllowAccessModifiersToAutoPropertiesGettersAndSetters">
<summary>
 Allow access modifiers to auto properties getters and setters
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1783)
</summary>
</member>
<member name="M:FSComp.SR.featureAdditionalImplicitConversions">
<summary>
 additional type-directed conversions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1584)
</summary>
</member>
<member name="M:FSComp.SR.featureAccessorFunctionShorthand">
<summary>
 underscore dot shorthand for accessor only function
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1749)
</summary>
</member>
<member name="M:FSComp.SR.fSharpBannerVersion(System.String,System.String)">
<summary>
 %s for F# %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1559)
</summary>
</member>
<member name="M:FSComp.SR.expressionHasNoName">
<summary>
 Expression does not have a name.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1525)
</summary>
</member>
<member name="M:FSComp.SR.experimentalConstruct">
<summary>
 This construct is experimental
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:980)
</summary>
</member>
<member name="M:FSComp.SR.eventHasNonStandardType(System.String,System.String,System.String)">
<summary>
 The event &apos;%s&apos; has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit %s and %s methods for the event. If this event is declared in F#, make the type of the event an instantiation of either &apos;IDelegateEvent&lt;_&gt;&apos; or &apos;IEvent&lt;_,_&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:973)
</summary>
</member>
<member name="M:FSComp.SR.etUnsupportedProvidedExpression(System.String)">
<summary>
 Unsupported expression &apos;%s&apos; from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1200)
</summary>
</member>
<member name="M:FSComp.SR.etUnsupportedMemberKind(System.String,System.String)">
<summary>
 Invalid member &apos;%s&apos; on provided type &apos;%s&apos;. Only properties, methods and constructors are allowed
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1192)
</summary>
</member>
<member name="M:FSComp.SR.etUnsupportedConstantType(System.String)">
<summary>
 Unsupported constant type &apos;%s&apos;. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a &apos;let&apos; binding inside the quotation literal.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1199)
</summary>
</member>
<member name="M:FSComp.SR.etUnknownStaticArgumentKind(System.String,System.String)">
<summary>
 Unknown static argument kind &apos;%s&apos; when resolving a reference to a provided type or method &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1218)
</summary>
</member>
<member name="M:FSComp.SR.etUnexpectedNullFromProvidedTypeMember(System.String,System.String)">
<summary>
 Unexpected &apos;null&apos; return value from provided type &apos;%s&apos; member &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1213)
</summary>
</member>
<member name="M:FSComp.SR.etUnexpectedExceptionFromProvidedTypeMember(System.String,System.String,System.String)">
<summary>
 Unexpected exception from provided type &apos;%s&apos; member &apos;%s&apos;: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1198)
</summary>
</member>
<member name="M:FSComp.SR.etUnexpectedExceptionFromProvidedMemberMember(System.String,System.String,System.String,System.String)">
<summary>
 Unexpected exception from member &apos;%s&apos; of provided type &apos;%s&apos; member &apos;%s&apos;: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1214)
</summary>
</member>
<member name="M:FSComp.SR.etTypeProviderConstructorException(System.String)">
<summary>
 The type provider constructor has thrown an exception: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1224)
</summary>
</member>
<member name="M:FSComp.SR.etTooManyStaticParameters(System.Int32,System.Int32,System.Int32)">
<summary>
 Too many static parameters. Expected at most %d parameters, but got %d unnamed and %d named parameters.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1323)
</summary>
</member>
<member name="M:FSComp.SR.etStaticParameterRequiresAValue(System.String,System.String,System.String,System.String)">
<summary>
 The static parameter &apos;%s&apos; of the provided type or method &apos;%s&apos; requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. &apos;%s&lt;%s=...&gt;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1244)
</summary>
</member>
<member name="M:FSComp.SR.etStaticParameterAlreadyHasValue(System.String)">
<summary>
 The static parameter &apos;%s&apos; has already been given a value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1246)
</summary>
</member>
<member name="M:FSComp.SR.etProviderReturnedNull(System.String)">
<summary>
 The type provider returned &apos;null&apos;, which is not a valid return value from &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1223)
</summary>
</member>
<member name="M:FSComp.SR.etProviderHasWrongDesignerAssemblyNoPath(System.String,System.String,System.String,System.String)">
<summary>
 Assembly attribute &apos;%s&apos; refers to a designer assembly &apos;%s&apos; which cannot be loaded or doesn&apos;t exist. The exception reported was: %s - %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1204)
</summary>
</member>
<member name="M:FSComp.SR.etProviderHasWrongDesignerAssembly(System.String,System.String,System.String,System.String,System.String)">
<summary>
 Assembly attribute &apos;%s&apos; refers to a designer assembly &apos;%s&apos; which cannot be loaded from path &apos;%s&apos;. The exception reported was: %s - %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1205)
</summary>
</member>
<member name="M:FSComp.SR.etProviderHasDesignerAssemblyException(System.String,System.String,System.String,System.String)">
<summary>
 The type provider designer assembly &apos;%s&apos; could not be loaded from folder &apos;%s&apos;. The exception reported was: %s - %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1220)
</summary>
</member>
<member name="M:FSComp.SR.etProviderHasDesignerAssemblyDependency(System.String,System.String,System.String,System.String)">
<summary>
 The type provider designer assembly &apos;%s&apos; could not be loaded from folder &apos;%s&apos; because a dependency was missing or could not loaded. All dependencies of the type provider designer assembly must be located in the same folder as that assembly. The exception reported was: %s - %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1219)
</summary>
</member>
<member name="M:FSComp.SR.etProviderErrorWithContext(System.String,System.String,System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; reported an error in the context of provided type &apos;%s&apos;, member &apos;%s&apos;. The error: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1237)
</summary>
</member>
<member name="M:FSComp.SR.etProviderError(System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; reported an error: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1207)
</summary>
</member>
<member name="M:FSComp.SR.etProviderDoesNotHaveValidConstructor">
<summary>
 The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type &apos;TypeProviderConfig&apos; was expected.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1206)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeWithNullOrEmptyName(System.String)">
<summary>
 The &apos;%s&apos; of a provided type was null or empty.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1239)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeWithNameException(System.String,System.String)">
<summary>
 An exception occurred when accessing the &apos;%s&apos; of a provided type: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1238)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeReferenceMissingArgument(System.String)">
<summary>
 A reference to a provided type was missing a value for the static parameter &apos;%s&apos;. You may need to recompile one or more referenced assemblies.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1264)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeReferenceInvalidText(System.String)">
<summary>
 A reference to a provided type had an invalid value &apos;%s&apos; for a static parameter. You may need to recompile one or more referenced assemblies.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1265)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeHasUnexpectedPath(System.String,System.String)">
<summary>
 Expected provided type with path &apos;%s&apos; but provided type has path &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1212)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedTypeHasUnexpectedName(System.String,System.String)">
<summary>
 Expected provided type named &apos;%s&apos; but provided type has &apos;Name&apos; with value &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1201)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedAppliedTypeHadWrongName(System.String,System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; returned an invalid type from &apos;ApplyStaticArguments&apos;. A type with name &apos;%s&apos; was expected, but a type with name &apos;%s&apos; was returned.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1226)
</summary>
</member>
<member name="M:FSComp.SR.etProvidedAppliedMethodHadWrongName(System.String,System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; returned an invalid method from &apos;ApplyStaticArgumentsForMethod&apos;. A method with name &apos;%s&apos; was expected, but a method with name &apos;%s&apos; was returned.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1227)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyNeedsCanWriteOrCanRead(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; is neither readable nor writable as it has CanRead=false and CanWrite=false
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1304)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyHasSetterButNoCanWrite(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanWrite=false but GetSetMethod() returned a method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1196)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyHasGetterButNoCanRead(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanRead=false but GetGetMethod() returned a method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1194)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyCanWriteButHasNoSetter(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanWrite=true but there was no value from GetSetMethod()
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1195)
</summary>
</member>
<member name="M:FSComp.SR.etPropertyCanReadButHasNoGetter(System.String,System.String)">
<summary>
 Property &apos;%s&apos; on provided type &apos;%s&apos; has CanRead=true but there was no value from GetGetMethod()
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1193)
</summary>
</member>
<member name="M:FSComp.SR.etOneOrMoreErrorsSeenDuringExtensionTypeSetting">
<summary>
 One or more errors seen during provided type setup
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1197)
</summary>
</member>
<member name="M:FSComp.SR.etNullProvidedExpression(System.String)">
<summary>
 Type provider &apos;%s&apos; returned null from GetInvokerExpression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1225)
</summary>
</member>
<member name="M:FSComp.SR.etNullOrEmptyMemberName(System.String)">
<summary>
 The provided type &apos;%s&apos; returned a member with a null or empty member name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1182)
</summary>
</member>
<member name="M:FSComp.SR.etNullMemberDeclaringTypeDifferentFromProvidedType(System.String,System.String,System.String)">
<summary>
 The provided type &apos;%s&apos; has member &apos;%s&apos; which has declaring type &apos;%s&apos;. Expected declaring type to be the same as provided type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1185)
</summary>
</member>
<member name="M:FSComp.SR.etNullMemberDeclaringType(System.String,System.String)">
<summary>
 The provided type &apos;%s&apos; member info &apos;%s&apos; has null declaring type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1184)
</summary>
</member>
<member name="M:FSComp.SR.etNullMember(System.String)">
<summary>
 The provided type &apos;%s&apos; returned a null member
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1183)
</summary>
</member>
<member name="M:FSComp.SR.etNoStaticParameterWithName(System.String)">
<summary>
 No static parameter exists with name &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1245)
</summary>
</member>
<member name="M:FSComp.SR.etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters">
<summary>
 Nested provided types do not take static arguments or generic parameters
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1215)
</summary>
</member>
<member name="M:FSComp.SR.etMustNotBeGeneric(System.String)">
<summary>
 Provided type &apos;%s&apos; has &apos;IsGenericType&apos; as true, but generic types are not supported.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1189)
</summary>
</member>
<member name="M:FSComp.SR.etMustNotBeAnArray(System.String)">
<summary>
 Provided type &apos;%s&apos; has &apos;IsArray&apos; as true, but array types are not supported.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1190)
</summary>
</member>
<member name="M:FSComp.SR.etMultipleStaticParameterWithName(System.String)">
<summary>
 Multiple static parameters exist with name &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1247)
</summary>
</member>
<member name="M:FSComp.SR.etMissingStaticArgumentsToMethod">
<summary>
 This provided method requires static parameters
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1380)
</summary>
</member>
<member name="M:FSComp.SR.etMethodHasRequirements(System.String,System.String)">
<summary>
 Invalid member &apos;%s&apos; on provided type &apos;%s&apos;. Provided type members must be public, and not be generic, virtual, or abstract.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1191)
</summary>
</member>
<member name="M:FSComp.SR.etInvalidTypeProviderAssemblyName(System.String,System.String)">
<summary>
 Assembly &apos;%s&apos; has TypeProviderAssembly attribute with invalid value &apos;%s&apos;. The value should be a valid assembly name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1232)
</summary>
</member>
<member name="M:FSComp.SR.etInvalidStaticArgument(System.String)">
<summary>
 Invalid static argument to provided type. Expected an argument of kind &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1216)
</summary>
</member>
<member name="M:FSComp.SR.etIncorrectProvidedMethod(System.String,System.String,System.Int32,System.String)">
<summary>
 The type provider &apos;%s&apos; provided a method with a name &apos;%s&apos; and metadata token &apos;%d&apos;, which is not reported among its methods of its declaring type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1209)
</summary>
</member>
<member name="M:FSComp.SR.etIncorrectProvidedConstructor(System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; provided a constructor which is not reported among the constructors of its declaring type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1210)
</summary>
</member>
<member name="M:FSComp.SR.etIncorrectParameterExpression(System.String,System.String)">
<summary>
 The type provider &apos;%s&apos; used an invalid parameter in the ParameterExpression: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1208)
</summary>
</member>
<member name="M:FSComp.SR.etIllegalCharactersInTypeName(System.String,System.String)">
<summary>
 Character &apos;%s&apos; is not allowed in provided type name &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1240)
</summary>
</member>
<member name="M:FSComp.SR.etIllegalCharactersInNamespaceName(System.String,System.String)">
<summary>
 Character &apos;%s&apos; is not allowed in provided namespace name &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1181)
</summary>
</member>
<member name="M:FSComp.SR.etHostingAssemblyFoundWithoutHosts(System.String,System.String)">
<summary>
 Referenced assembly &apos;%s&apos; has assembly level attribute &apos;%s&apos; but no public type provider classes were found
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1186)
</summary>
</member>
<member name="M:FSComp.SR.etEventNoRemove(System.String,System.String)">
<summary>
 Event &apos;%s&apos; on provided type &apos;%s&apos; has no value from GetRemoveMethod()
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1203)
</summary>
</member>
<member name="M:FSComp.SR.etEventNoAdd(System.String,System.String)">
<summary>
 Event &apos;%s&apos; on provided type &apos;%s&apos; has no value from GetAddMethod()
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1202)
</summary>
</member>
<member name="M:FSComp.SR.etErrorApplyingStaticArgumentsToType">
<summary>
 An error occurred applying the static arguments to a provided type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1217)
</summary>
</member>
<member name="M:FSComp.SR.etErrorApplyingStaticArgumentsToMethod">
<summary>
 An error occurred applying the static arguments to a provided method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1363)
</summary>
</member>
<member name="M:FSComp.SR.etErasedTypeUsedInGeneration(System.String,System.String)">
<summary>
 The provider &apos;%s&apos; returned a non-generated type &apos;%s&apos; in the context of a set of generated types. Consider adjusting the type provider to only return generated types.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1327)
</summary>
</member>
<member name="M:FSComp.SR.etEmptyNamespaceOfTypeNotAllowed(System.String,System.String)">
<summary>
 Type &apos;%s&apos; from type provider &apos;%s&apos; has an empty namespace. Use &apos;null&apos; for the global namespace.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1187)
</summary>
</member>
<member name="M:FSComp.SR.etEmptyNamespaceNotAllowed(System.String)">
<summary>
 Empty namespace found from the type provider &apos;%s&apos;. Use &apos;null&apos; for the global namespace.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1188)
</summary>
</member>
<member name="M:FSComp.SR.etDirectReferenceToGeneratedTypeNotAllowed(System.String)">
<summary>
 A direct reference to the generated type &apos;%s&apos; is not permitted. Instead, use a type definition, e.g. &apos;type TypeAlias = &lt;path&gt;&apos;. This indicates that a type provider adds generated types to your assembly.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1211)
</summary>
</member>
<member name="M:FSComp.SR.etBadUnnamedStaticArgs">
<summary>
 Named static arguments must come after all unnamed static arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1243)
</summary>
</member>
<member name="M:FSComp.SR.estApplyStaticArgumentsForMethodNotImplemented">
<summary>
 A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1362)
</summary>
</member>
<member name="M:FSComp.SR.erasedTo">
<summary>
 Erased to
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1332)
</summary>
</member>
<member name="M:FSComp.SR.elseBranchHasWrongTypeTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 All branches of an &apos;if&apos; expression must return values implicitly convertible to the type of the first branch, which here is a tuple of length %d of type\n    %s    \nThis branch returns a tuple of length %d of type\n    %s    \n
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:30)
</summary>
</member>
<member name="M:FSComp.SR.elseBranchHasWrongType(System.String,System.String)">
<summary>
 All branches of an &apos;if&apos; expression must return values implicitly convertible to the type of the first branch, which here is &apos;%s&apos;. This branch returns a value of type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:29)
</summary>
</member>
<member name="M:FSComp.SR.elSysEnvExitDidntExit">
<summary>
 System.Environment.Exit did not exit
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:245)
</summary>
</member>
<member name="M:FSComp.SR.elDeprecatedOperator">
<summary>
 The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:246)
</summary>
</member>
<member name="M:FSComp.SR.docfileNoXmlSuffix">
<summary>
 The documentation file has no .xml suffix
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1154)
</summary>
</member>
<member name="M:FSComp.SR.descriptionWordIs">
<summary>
 is
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1490)
</summary>
</member>
<member name="M:FSComp.SR.descriptionUnavailable">
<summary>
 (description unavailable...)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1339)
</summary>
</member>
<member name="M:FSComp.SR.derefInsteadOfNot">
<summary>
 The &apos;!&apos; operator is used to dereference a ref cell. Consider using &apos;not expr&apos; here.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:35)
</summary>
</member>
<member name="M:FSComp.SR.delegatesNotAllowedToHaveCurriedSignatures">
<summary>
 Delegates are not allowed to have curried signatures
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:983)
</summary>
</member>
<member name="M:FSComp.SR.customOperationTextLikeZip(System.String)">
<summary>
 %s var in collection
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1270)
</summary>
</member>
<member name="M:FSComp.SR.customOperationTextLikeJoin(System.String,System.String,System.String)">
<summary>
 %s var in collection %s (outerKey = innerKey). Note that parentheses are required after &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1268)
</summary>
</member>
<member name="M:FSComp.SR.customOperationTextLikeGroupJoin(System.String,System.String,System.String)">
<summary>
 %s var in collection %s (outerKey = innerKey) into group. Note that parentheses are required after &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1269)
</summary>
</member>
<member name="M:FSComp.SR.csUnmanagedConstraintInconsistent">
<summary>
 The constraints &apos;unmanaged&apos; and &apos;not struct&apos; are inconsistent
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:324)
</summary>
</member>
<member name="M:FSComp.SR.csTypesDoNotSupportOperatorNullable(System.String,System.String)">
<summary>
 None of the types &apos;%s&apos; support the operator &apos;%s&apos;. Consider opening the module &apos;Microsoft.FSharp.Linq.NullableOperators&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:318)
</summary>
</member>
<member name="M:FSComp.SR.csTypesDoNotSupportOperator(System.String,System.String)">
<summary>
 None of the types &apos;%s&apos; support the operator &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:315)
</summary>
</member>
<member name="M:FSComp.SR.csTypeParameterCannotBeNullable">
<summary>
 This type parameter cannot be instantiated to &apos;Nullable&apos;. This is a restriction imposed in order to ensure the meaning of &apos;null&apos; in some CLI languages is not confusing when used in conjunction with &apos;Nullable&apos; values.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:336)
</summary>
</member>
<member name="M:FSComp.SR.csTypeNotCompatibleBecauseOfPrintf(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is not compatible with any of the types %s, arising from the use of a printf-style format string
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:339)
</summary>
</member>
<member name="M:FSComp.SR.csTypeIsNotEnumType(System.String)">
<summary>
 The type &apos;%s&apos; is not a CLI enum type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:333)
</summary>
</member>
<member name="M:FSComp.SR.csTypeIsNotDelegateType(System.String)">
<summary>
 The type &apos;%s&apos; is not a CLI delegate type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:335)
</summary>
</member>
<member name="M:FSComp.SR.csTypeInstantiationLengthMismatch">
<summary>
 Type instantiation length mismatch
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:344)
</summary>
</member>
<member name="M:FSComp.SR.csTypeInferenceMaxDepth">
<summary>
 Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:310)
</summary>
</member>
<member name="M:FSComp.SR.csTypeHasNullAsTrueValue(System.String)">
<summary>
 The type &apos;%s&apos; uses &apos;null&apos; as a representation value but a non-null type is expected
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1542)
</summary>
</member>
<member name="M:FSComp.SR.csTypeHasNullAsExtraValue(System.String)">
<summary>
 The type &apos;%s&apos; supports &apos;null&apos; but a non-null type is expected
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1543)
</summary>
</member>
<member name="M:FSComp.SR.csTypeHasNonStandardDelegateType(System.String)">
<summary>
 The type &apos;%s&apos; has a non-standard delegate type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:334)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportOperatorNullable(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support the operator &apos;%s&apos;. Consider opening the module &apos;Microsoft.FSharp.Linq.NullableOperators&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:319)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportOperator(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support the operator &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:316)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality3(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it is a record, union or struct with one or more structural element types which do not support the &apos;equality&apos; constraint. Either avoid the use of equality with this type, or add the &apos;StructuralEquality&apos; attribute to the type to determine which field type does not support equality
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:332)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality2(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it is a function type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:331)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportEquality1(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;equality&apos; constraint because it has the &apos;NoEquality&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:330)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportConversion(System.String,System.String)">
<summary>
 The type &apos;%s&apos; does not support a conversion to the type &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:320)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison3(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint because it is a record, union or struct with one or more structural element types which do not support the &apos;comparison&apos; constraint. Either avoid the use of comparison with this type, or add the &apos;StructuralComparison&apos; attribute to the type to determine which field type does not support comparison
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:329)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison2(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint. For example, it does not support the &apos;System.IComparable&apos; interface
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:328)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotSupportComparison1(System.String)">
<summary>
 The type &apos;%s&apos; does not support the &apos;comparison&apos; constraint because it has the &apos;NoComparison&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:327)
</summary>
</member>
<member name="M:FSComp.SR.csTypeDoesNotHaveNull(System.String)">
<summary>
 The type &apos;%s&apos; does not have &apos;null&apos; as a proper value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:325)
</summary>
</member>
<member name="M:FSComp.SR.csTypeCannotBeResolvedAtCompileTime(System.String)">
<summary>
 The declared type parameter &apos;%s&apos; cannot be used here since the type parameter cannot be resolved at compile time
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:308)
</summary>
</member>
<member name="M:FSComp.SR.csStructConstraintInconsistent">
<summary>
 The constraints &apos;struct&apos; and &apos;not struct&apos; are inconsistent
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:323)
</summary>
</member>
<member name="M:FSComp.SR.csRequiredSignatureIs(System.String)">
<summary>
 The required signature is %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:357)
</summary>
</member>
<member name="M:FSComp.SR.csOverloadCandidateNamedArgumentTypeMismatch(System.String)">
<summary>
 Argument &apos;%s&apos; doesn&apos;t match
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:383)
</summary>
</member>
<member name="M:FSComp.SR.csOverloadCandidateIndexedArgumentTypeMismatch(System.Int32)">
<summary>
 Argument at index %d doesn&apos;t match
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:384)
</summary>
</member>
<member name="M:FSComp.SR.csOptionalArgumentNotPermittedHere">
<summary>
 Optional arguments not permitted here
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:345)
</summary>
</member>
<member name="M:FSComp.SR.csNullableTypeDoesNotHaveNull(System.String)">
<summary>
 The type &apos;%s&apos; does not have &apos;null&apos; as a proper value. To create a null value for a Nullable type use &apos;System.Nullable()&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:326)
</summary>
</member>
<member name="M:FSComp.SR.csNullNotNullConstraintInconsistent">
<summary>
 The constraints &apos;null&apos; and &apos;not null&apos; are inconsistent
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1540)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundTypeParametersPrefixSingular(System.String)">
<summary>
 Known type parameter: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:377)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundTypeParametersPrefixPlural(System.String)">
<summary>
 Known type parameters: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:378)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundReturnType(System.String)">
<summary>
 Known return type: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:379)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundArgumentsPrefixSingular(System.String)">
<summary>
 Known type of argument: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:375)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFoundArgumentsPrefixPlural(System.String)">
<summary>
 Known types of arguments: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:376)
</summary>
</member>
<member name="M:FSComp.SR.csNoOverloadsFound(System.String)">
<summary>
 No overloads match for method &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:374)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments3(System.String,System.String,System.Int32,System.String)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments. The named argument &apos;%s&apos; doesn&apos;t correspond to any argument or settable return property for any overload.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:372)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments2(System.String,System.String,System.Int32,System.Int32)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments. Note the call to this member also provides %d named arguments.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:371)
</summary>
</member>
<member name="M:FSComp.SR.csNoMemberTakesTheseArguments(System.String,System.String,System.Int32)">
<summary>
 No %s member or object constructor named &apos;%s&apos; takes %d arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:370)
</summary>
</member>
<member name="M:FSComp.SR.csMethodNotFound(System.String)">
<summary>
 Method or object constructor &apos;%s&apos; not found
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:373)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsOverloaded(System.String)">
<summary>
 A unique overload for method &apos;%s&apos; could not be determined based on type information prior to this program point. A type annotation may be needed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:380)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsNotAnInstanceMethod(System.String)">
<summary>
 %s is not an instance method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:354)
</summary>
</member>
<member name="M:FSComp.SR.csMethodIsNotAStaticMethod(System.String)">
<summary>
 %s is not a static method
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:353)
</summary>
</member>
<member name="M:FSComp.SR.csMethodFoundButIsStatic(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; has a method &apos;%s&apos; (full name &apos;%s&apos;), but the method is static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:321)
</summary>
</member>
<member name="M:FSComp.SR.csMethodFoundButIsNotStatic(System.String,System.String,System.String)">
<summary>
 The type &apos;%s&apos; has a method &apos;%s&apos; (full name &apos;%s&apos;), but the method is not static
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:322)
</summary>
</member>
<member name="M:FSComp.SR.csMethodExpectsParams">
<summary>
 This method expects a CLI &apos;params&apos; parameter in this position. &apos;params&apos; is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:350)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArityType(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; takes %d type argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:366)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArityNamed(System.String,System.Int32,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s) but is here given %d unnamed and %d named argument(s). The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:362)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatchArity(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; takes %d argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:363)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch4(System.String,System.Int32,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d additional argument(s). The required signature is &apos;%s&apos;. Some names for missing arguments are %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:361)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch3(System.String,System.Int32,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s). The required signature is &apos;%s&apos;. Some names for missing arguments are %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:360)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch2(System.String,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d additional argument(s). The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:359)
</summary>
</member>
<member name="M:FSComp.SR.csMemberSignatureMismatch(System.String,System.Int32,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; requires %d argument(s). The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:358)
</summary>
</member>
<member name="M:FSComp.SR.csMemberOverloadArityMismatch(System.String,System.Int32,System.Int32)">
<summary>
 The member or object constructor &apos;%s&apos; does not take %d argument(s). An overload was found taking %d arguments.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:369)
</summary>
</member>
<member name="M:FSComp.SR.csMemberNotAccessible(System.String,System.Int32,System.String,System.Int32)">
<summary>
 A member or object constructor &apos;%s&apos; taking %d arguments is not accessible from this code location. All accessible versions of method &apos;%s&apos; take %d arguments.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:367)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotStatic(System.String)">
<summary>
 %s is not a static member
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:346)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotInstance(System.String)">
<summary>
 %s is not an instance member
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:347)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotAccessible2(System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; is not %s. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:352)
</summary>
</member>
<member name="M:FSComp.SR.csMemberIsNotAccessible(System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; is not %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:351)
</summary>
</member>
<member name="M:FSComp.SR.csMemberHasNoArgumentOrReturnProperty(System.String,System.String,System.String)">
<summary>
 The member or object constructor &apos;%s&apos; has no argument or settable return property &apos;%s&apos;. %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:355)
</summary>
</member>
<member name="M:FSComp.SR.csIndexArgumentMismatch(System.Int32,System.Int32)">
<summary>
 This indexer expects %d arguments but is here given %d
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:312)
</summary>
</member>
<member name="M:FSComp.SR.csIncorrectGenericInstantiation(System.String,System.String,System.Int32)">
<summary>
 Incorrect generic instantiation. No %s member named &apos;%s&apos; takes %d generic arguments.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:368)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresUnmanagedType(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; is an unmanaged type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:338)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresStructType(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; is a CLI or F# struct type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:337)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresStructOrReferenceConstraint">
<summary>
 A generic construct requires that a generic type parameter be known as a struct or reference type. Consider adding a type annotation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:343)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresReferenceSemantics(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; have reference semantics, but it does not, i.e. it is a struct
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:340)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresPublicDefaultConstructor(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; have a public default constructor
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:342)
</summary>
</member>
<member name="M:FSComp.SR.csGenericConstructRequiresNonAbstract(System.String)">
<summary>
 A generic construct requires that the type &apos;%s&apos; be non-abstract
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:341)
</summary>
</member>
<member name="M:FSComp.SR.csFunctionDoesNotSupportType(System.String,System.String,System.String)">
<summary>
 &apos;%s&apos; does not support the type &apos;%s&apos;, because the latter lacks the required (real or built-in) member &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:317)
</summary>
</member>
<member name="M:FSComp.SR.csExpectedArguments">
<summary>
 Expected arguments to an instance member
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:311)
</summary>
</member>
<member name="M:FSComp.SR.csExpectTypeWithOperatorButGivenTuple(System.String)">
<summary>
 Expecting a type supporting the operator &apos;%s&apos; but given a tuple type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:314)
</summary>
</member>
<member name="M:FSComp.SR.csExpectTypeWithOperatorButGivenFunction(System.String)">
<summary>
 Expecting a type supporting the operator &apos;%s&apos; but given a function type. You may be missing an argument to a function.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:313)
</summary>
</member>
<member name="M:FSComp.SR.csCtorSignatureMismatchArityProp(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The object constructor &apos;%s&apos; takes %d argument(s) but is here given %d. The required signature is &apos;%s&apos;. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (&apos;,&apos;).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:365)
</summary>
</member>
<member name="M:FSComp.SR.csCtorSignatureMismatchArity(System.String,System.Int32,System.Int32,System.String)">
<summary>
 The object constructor &apos;%s&apos; takes %d argument(s) but is here given %d. The required signature is &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:364)
</summary>
</member>
<member name="M:FSComp.SR.csCtorHasNoArgumentOrReturnProperty(System.String,System.String,System.String)">
<summary>
 The object constructor &apos;%s&apos; has no argument or settable return property &apos;%s&apos;. %s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:356)
</summary>
</member>
<member name="M:FSComp.SR.csCodeLessGeneric">
<summary>
 This code is less generic than indicated by its annotations. A unit-of-measure specified using &apos;_&apos; has been determined to be &apos;1&apos;, i.e. dimensionless. Consider making the code generic, or removing the use of &apos;_&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:309)
</summary>
</member>
<member name="M:FSComp.SR.csCandidates(System.String)">
<summary>
 Candidates:\n%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:381)
</summary>
</member>
<member name="M:FSComp.SR.csAvailableOverloads(System.String)">
<summary>
 Available overloads:\n%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:382)
</summary>
</member>
<member name="M:FSComp.SR.csArgumentTypesDoNotMatch">
<summary>
 The argument types don&apos;t match
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:349)
</summary>
</member>
<member name="M:FSComp.SR.csArgumentLengthMismatch">
<summary>
 Argument length mismatch
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:348)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantSetUnionFields">
<summary>
 Quotations cannot contain expressions that set union case fields
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:300)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantSetExceptionFields">
<summary>
 Quotations cannot contain expressions that set fields in exception values
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:301)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantRequireByref">
<summary>
 Quotations cannot contain expressions that require byref pointers
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:302)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantFetchUnionIndexes">
<summary>
 Quotations cannot contain expressions that fetch union case indexes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:299)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisType">
<summary>
 Quotations cannot contain this kind of type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:307)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisPatternMatch">
<summary>
 Quotations cannot contain this kind of pattern match
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:305)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainThisConstant">
<summary>
 Quotations cannot contain this kind of constant
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:304)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainStaticFieldRef">
<summary>
 Quotations cannot contain expressions that fetch static fields
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:296)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainObjExprs">
<summary>
 Quotations cannot contain object expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:294)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainInlineIL">
<summary>
 Quotations cannot contain inline assembly code or pattern matching on arrays
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:297)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainGenericFunctions">
<summary>
 Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:293)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainGenericExprs">
<summary>
 Quotations cannot contain uses of generic expressions
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:292)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainDescendingForLoops">
<summary>
 Quotations cannot contain descending for loops
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:298)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainArrayPatternMatching">
<summary>
 Quotations cannot contain array pattern matching
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:306)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantContainAddressOf">
<summary>
 Quotations cannot contain expressions that take the address of a field
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:295)
</summary>
</member>
<member name="M:FSComp.SR.crefQuotationsCantCallTraitMembers">
<summary>
 Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:303)
</summary>
</member>
<member name="M:FSComp.SR.crefNoSetOfHole">
<summary>
 A quotation may not involve an assignment to or taking the address of a captured local variable
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1329)
</summary>
</member>
<member name="M:FSComp.SR.crefNoInnerGenericsInQuotations">
<summary>
 Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1119)
</summary>
</member>
<member name="M:FSComp.SR.crefBoundVarUsedInSplice(System.String)">
<summary>
 The variable &apos;%s&apos; is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:291)
</summary>
</member>
<member name="M:FSComp.SR.couldNotLoadDependencyManagerExtension(System.String,System.String)">
<summary>
 The dependency manager extension %s could not be loaded. Message: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1524)
</summary>
</member>
<member name="M:FSComp.SR.containerSigningUnsupportedOnThisPlatform">
<summary>
 Key container signing is not supported on this platform.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1678)
</summary>
</member>
<member name="M:FSComp.SR.containerDeprecated">
<summary>
 The &apos;AssemblyKeyNameAttribute&apos; has been deprecated. Use &apos;AssemblyKeyFileAttribute&apos; instead.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1677)
</summary>
</member>
<member name="M:FSComp.SR.considerUpcastOperator(System.String,System.String)">
<summary>
 The conversion from %s to %s is a compile-time safe upcast, not a downcast. Consider using the :&gt; (upcast) operator instead of the :?&gt; (downcast) operator.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1382)
</summary>
</member>
<member name="M:FSComp.SR.considerUpcast(System.String,System.String)">
<summary>
 The conversion from %s to %s is a compile-time safe upcast, not a downcast. Consider using &apos;upcast&apos; instead of &apos;downcast&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1381)
</summary>
</member>
<member name="M:FSComp.SR.commaInsteadOfSemicolonInRecord">
<summary>
 A &apos;;&apos; is used to separate field values in records. Consider replacing &apos;,&apos; with &apos;;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:34)
</summary>
</member>
<member name="M:FSComp.SR.chkVariableUsedInInvalidWay(System.String)">
<summary>
 The variable &apos;%s&apos; is used in an invalid way
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:250)
</summary>
</member>
<member name="M:FSComp.SR.chkValueWithDefaultValueMustHaveDefaultValue">
<summary>
 The type of a field using the &apos;DefaultValue&apos; attribute must admit default initialization, i.e. have &apos;null&apos; as a proper value or be a struct type whose fields all admit default initialization. You can use &apos;DefaultValue(false)&apos; to disable this check
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:289)
</summary>
</member>
<member name="M:FSComp.SR.chkUnusedValue(System.String)">
<summary>
 The value &apos;%s&apos; is unused
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1070)
</summary>
</member>
<member name="M:FSComp.SR.chkUnusedThisVariable(System.String)">
<summary>
 The recursive object reference &apos;%s&apos; is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1071)
</summary>
</member>
<member name="M:FSComp.SR.chkUnionCaseDefaultAugmentation">
<summary>
 default augmentation of the union case
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:275)
</summary>
</member>
<member name="M:FSComp.SR.chkUnionCaseCompiledForm">
<summary>
 compiled form of the union case
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:274)
</summary>
</member>
<member name="M:FSComp.SR.chkTypeLessAccessibleThanType(System.String,System.String)">
<summary>
 The type &apos;%s&apos; is less accessible than the value, member or type &apos;%s&apos; it is used in.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:251)
</summary>
</member>
<member name="M:FSComp.SR.chkTyparMultipleClassConstraints">
<summary>
 A type variable has been constrained by multiple different class types. A type variable may only have one class constraint.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1340)
</summary>
</member>
<member name="M:FSComp.SR.chkTailCallAttrOnNonRec">
<summary>
 The TailCall attribute should only be applied to recursive functions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1767)
</summary>
</member>
<member name="M:FSComp.SR.chkSystemVoidOnlyInTypeof">
<summary>
 &apos;System.Void&apos; can only be used as &apos;typeof&lt;System.Void&gt;&apos; in F#
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:252)
</summary>
</member>
<member name="M:FSComp.SR.chkStructsMayNotReturnAddressesOfContents">
<summary>
 Struct members cannot return the address of fields of the struct by reference
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1511)
</summary>
</member>
<member name="M:FSComp.SR.chkStaticMembersOnObjectExpressions">
<summary>
 Object expressions cannot implement interfaces with static abstract members or declare static members.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1766)
</summary>
</member>
<member name="M:FSComp.SR.chkStaticAbstractMembersOnClasses">
<summary>
 Classes cannot contain static abstract members.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1773)
</summary>
</member>
<member name="M:FSComp.SR.chkStaticAbstractInterfaceMembers(System.String)">
<summary>
 A static abstract non-virtual interface member should only be called via type parameter (for example: &apos;T.%s).
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1772)
</summary>
</member>
<member name="M:FSComp.SR.chkSplicingOnlyInQuotations">
<summary>
 Expression-splicing operators may only be used within quotations
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:255)
</summary>
</member>
<member name="M:FSComp.SR.chkReturnTypeNoByref">
<summary>
 A method return type would contain byrefs which is not permitted
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:267)
</summary>
</member>
<member name="M:FSComp.SR.chkReflectedDefCantSplice">
<summary>
 [&lt;ReflectedDefinition&gt;] terms cannot contain uses of the prefix splice operator &apos;%%&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:272)
</summary>
</member>
<member name="M:FSComp.SR.chkProtectedOrBaseCalled">
<summary>
 A protected member is called or &apos;base&apos; is being used. This is only allowed in the direct implementation of members since they could escape their object scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:247)
</summary>
</member>
<member name="M:FSComp.SR.chkPropertySameNameMethod(System.String,System.String)">
<summary>
 The property &apos;%s&apos; has the same name as a method in type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:276)
</summary>
</member>
<member name="M:FSComp.SR.chkPropertySameNameIndexer(System.String,System.String)">
<summary>
 The property &apos;%s&apos; has the same name as another property in type &apos;%s&apos;, but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:278)
</summary>
</member>
<member name="M:FSComp.SR.chkNotTailRecursive(System.String)">
<summary>
 The member or function &apos;%s&apos; has the &apos;TailCallAttribute&apos; attribute, but is not being used in a tail recursive way.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1747)
</summary>
</member>
<member name="M:FSComp.SR.chkNoWriteToLimitedSpan(System.String)">
<summary>
 This value can&apos;t be assigned because the target &apos;%s&apos; may refer to non-stack-local memory, while the expression being assigned is assessed to potentially refer to stack-local memory. This is to help prevent pointers to stack-bound memory escaping their scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1508)
</summary>
</member>
<member name="M:FSComp.SR.chkNoSpanLikeVariable(System.String)">
<summary>
 The Span or IsByRefLike variable &apos;%s&apos; cannot be used at this point. This is to ensure the address of the local value does not escape its scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1513)
</summary>
</member>
<member name="M:FSComp.SR.chkNoSpanLikeValueFromExpression">
<summary>
 A Span or IsByRefLike value returned from the expression cannot be used at ths point. This is to ensure the address of the local value does not escape its scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1514)
</summary>
</member>
<member name="M:FSComp.SR.chkNoReflectedDefinitionOnStructMember">
<summary>
 ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit &apos;this&apos; byref parameter
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1113)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassSplicing">
<summary>
 First-class uses of the expression-splicing operator are not permitted
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:256)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassRethrow">
<summary>
 First-class uses of the &apos;reraise&apos; function is not permitted
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:258)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassNameOf">
<summary>
 Using the &apos;nameof&apos; operator as a first-class function value is not permitted.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1526)
</summary>
</member>
<member name="M:FSComp.SR.chkNoFirstClassAddressOf">
<summary>
 First-class uses of the address-of operators are not permitted
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:257)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefsOfByrefs(System.String)">
<summary>
 Type &apos;%s&apos; is illegal because in byref&lt;T&gt;, T cannot contain byref types.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1312)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefLikeFunctionCall">
<summary>
 The function or method call cannot be used at this point, because one argument that is a byref of a non-stack-local Span or IsByRefLike type is used with another argument that is a stack-local Span or IsByRefLike type. This is to ensure the address of the local value does not escape its scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1512)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefInTypeAbbrev">
<summary>
 The type abbreviation contains byrefs. This is not permitted by F#.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:290)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAtThisPoint(System.String)">
<summary>
 The byref typed value &apos;%s&apos; cannot be used at this point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:259)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAsTopValue">
<summary>
 A byref typed value would be stored here. Top-level let-bound byref values are not permitted.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:271)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAddressOfValueFromExpression">
<summary>
 The address of a value returned from the expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1507)
</summary>
</member>
<member name="M:FSComp.SR.chkNoByrefAddressOfLocal(System.String)">
<summary>
 The address of the variable &apos;%s&apos; or a related expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1392)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressStaticFieldAtThisPoint(System.String)">
<summary>
 The address of the static field &apos;%s&apos; cannot be used at this point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:263)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressOfAtThisPoint(System.String)">
<summary>
 The address of the variable &apos;%s&apos; cannot be used at this point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:262)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressOfArrayElementAtThisPoint">
<summary>
 The address of an array element cannot be used at this point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:265)
</summary>
</member>
<member name="M:FSComp.SR.chkNoAddressFieldAtThisPoint(System.String)">
<summary>
 The address of the field &apos;%s&apos; cannot be used at this point
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:264)
</summary>
</member>
<member name="M:FSComp.SR.chkMultipleGenericInterfaceInstantiations(System.String,System.String)">
<summary>
 This type implements the same interface at different generic instantiations &apos;%s&apos; and &apos;%s&apos;. This is not permitted in this version of F#.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:288)
</summary>
</member>
<member name="M:FSComp.SR.chkMemberUsedInInvalidWay(System.String,System.String,System.String)">
<summary>
 The member &apos;%s&apos; is used in an invalid way. A use of &apos;%s&apos; has been inferred prior to its definition at or near &apos;%s&apos;. This is an invalid forward reference.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:270)
</summary>
</member>
<member name="M:FSComp.SR.chkLimitationsOfBaseKeyword">
<summary>
 &apos;base&apos; values may only be used to make direct calls to the base implementations of overridden members
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:260)
</summary>
</member>
<member name="M:FSComp.SR.chkInvalidFunctionReturnType(System.String)">
<summary>
 The function or method has an invalid return type &apos;%s&apos;. This is not permitted by the rules of Common IL.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1545)
</summary>
</member>
<member name="M:FSComp.SR.chkInvalidFunctionParameterType(System.String,System.String)">
<summary>
 The parameter &apos;%s&apos; has an invalid type &apos;%s&apos;. This is not permitted by the rules of Common IL.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1544)
</summary>
</member>
<member name="M:FSComp.SR.chkInvalidCustAttrVal">
<summary>
 Invalid custom attribute value (not a constant or literal)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:268)
</summary>
</member>
<member name="M:FSComp.SR.chkInstanceMemberOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Instance members are not allowed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1730)
</summary>
</member>
<member name="M:FSComp.SR.chkInstanceLetBindingOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Instance let bindings are not allowed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1731)
</summary>
</member>
<member name="M:FSComp.SR.chkInfoRefcellIncr">
<summary>
 The use of &apos;incr&apos; from the F# library is deprecated. See https://aka.ms/fsharp-refcell-ops. For example, please change &apos;incr cell&apos; to &apos;cell.Value &lt;- cell.Value + 1&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1644)
</summary>
</member>
<member name="M:FSComp.SR.chkInfoRefcellDeref">
<summary>
 The use of &apos;!&apos; from the F# library is deprecated. See https://aka.ms/fsharp-refcell-ops. For example, please change &apos;!cell&apos; to &apos;cell.Value&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1642)
</summary>
</member>
<member name="M:FSComp.SR.chkInfoRefcellDecr">
<summary>
 The use of &apos;decr&apos; from the F# library is deprecated. See https://aka.ms/fsharp-refcell-ops. For example, please change &apos;decr cell&apos; to &apos;cell.Value &lt;- cell.Value - 1&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1645)
</summary>
</member>
<member name="M:FSComp.SR.chkInfoRefcellAssign">
<summary>
 The use of &apos;:=&apos; from the F# library is deprecated. See https://aka.ms/fsharp-refcell-ops. For example, please change &apos;cell := expr&apos; to &apos;cell.Value &lt;- expr&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1643)
</summary>
</member>
<member name="M:FSComp.SR.chkIndexedGetterAndSetterHaveSamePropertyType(System.String,System.String,System.String)">
<summary>
 An indexed property&apos;s getter and setter must have the same type. Property &apos;%s&apos; has getter of type &apos;%s&apos; but setter of type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1758)
</summary>
</member>
<member name="M:FSComp.SR.chkImplementingInterfacesOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Implementing interfaces is not allowed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1732)
</summary>
</member>
<member name="M:FSComp.SR.chkGetterSetterDoNotMatchAbstract(System.String,System.String)">
<summary>
 The property &apos;%s&apos; of type &apos;%s&apos; has a getter and a setter that do not match. If one is abstract then the other must be as well.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:277)
</summary>
</member>
<member name="M:FSComp.SR.chkGetterAndSetterHaveSamePropertyType(System.String,System.String,System.String)">
<summary>
 A property&apos;s getter and setter must have the same type. Property &apos;%s&apos; has getter of type &apos;%s&apos; but setter of type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1349)
</summary>
</member>
<member name="M:FSComp.SR.chkFirstClassFuncNoByref">
<summary>
 The type of a first-class function cannot contain byrefs
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:266)
</summary>
</member>
<member name="M:FSComp.SR.chkFeatureNotSupportedInLibrary(System.String,System.String)">
<summary>
 Feature &apos;%s&apos; requires the F# library for language version %s or greater.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1552)
</summary>
</member>
<member name="M:FSComp.SR.chkFeatureNotRuntimeSupported(System.String)">
<summary>
 Feature &apos;%s&apos; is not supported by target runtime.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1554)
</summary>
</member>
<member name="M:FSComp.SR.chkFeatureNotLanguageSupported(System.String,System.String,System.String)">
<summary>
 Feature &apos;%s&apos; is not available in F# %s. Please use language version %s or greater.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1553)
</summary>
</member>
<member name="M:FSComp.SR.chkExplicitFieldsDeclarationsOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Explicit field declarations are not allowed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1734)
</summary>
</member>
<member name="M:FSComp.SR.chkErrorUseOfByref">
<summary>
 A type instantiation involves a byref type. This is not permitted by the rules of Common IL.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:253)
</summary>
</member>
<member name="M:FSComp.SR.chkErrorContainsCallToRethrow">
<summary>
 Calls to &apos;reraise&apos; may only occur directly in a handler of a try-with
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:254)
</summary>
</member>
<member name="M:FSComp.SR.chkEntryPointUsage">
<summary>
 A function labeled with the &apos;EntryPointAttribute&apos; attribute must be the last declaration in the last file in the compilation sequence.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:273)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicatedMethodParameter(System.String)">
<summary>
 Duplicate parameter. The parameter &apos;%s&apos; has been used more that once in this method.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1725)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicatePropertyWithSuffix(System.String,System.String)">
<summary>
 Duplicate property. The property &apos;%s&apos; has the same name and signature as another property in type &apos;%s&apos; once tuples, functions, units of measure and/or provided types are erased.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:285)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateProperty(System.String,System.String)">
<summary>
 Duplicate property. The property &apos;%s&apos; has the same name and signature as another property in type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:284)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodWithSuffix(System.String,System.String)">
<summary>
 Duplicate method. The method &apos;%s&apos; has the same name and signature as another method in type &apos;%s&apos; once tuples, functions, units of measure and/or provided types are erased.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:281)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodInheritedTypeWithSuffix(System.String)">
<summary>
 Duplicate method. The abstract method &apos;%s&apos; has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:287)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodInheritedType(System.String)">
<summary>
 Duplicate method. The abstract method &apos;%s&apos; has the same name and signature as an abstract method in an inherited type.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:286)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethodCurried(System.String,System.String)">
<summary>
 The method &apos;%s&apos; has curried arguments but has the same name as another method in type &apos;%s&apos;. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:282)
</summary>
</member>
<member name="M:FSComp.SR.chkDuplicateMethod(System.String,System.String)">
<summary>
 Duplicate method. The method &apos;%s&apos; has the same name and signature as another method in type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:280)
</summary>
</member>
<member name="M:FSComp.SR.chkCurriedMethodsCantHaveOutParams">
<summary>
 Methods with curried arguments cannot declare &apos;out&apos;, &apos;ParamArray&apos;, &apos;optional&apos;, &apos;ReflectedDefinition&apos;, &apos;byref&apos;, &apos;CallerLineNumber&apos;, &apos;CallerMemberName&apos;, or &apos;CallerFilePath&apos; arguments
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:283)
</summary>
</member>
<member name="M:FSComp.SR.chkCopyUpdateSyntaxInAnonRecords">
<summary>
 This expression is an anonymous record, use {|...|} instead of {...}.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1755)
</summary>
</member>
<member name="M:FSComp.SR.chkConstructorWithArgumentsOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Constructor with arguments is not allowed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1728)
</summary>
</member>
<member name="M:FSComp.SR.chkCantStoreByrefValue">
<summary>
 A type would store a byref typed value. This is not permitted by Common IL.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:279)
</summary>
</member>
<member name="M:FSComp.SR.chkByrefUsedInInvalidWay(System.String)">
<summary>
 The byref-typed variable &apos;%s&apos; is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:248)
</summary>
</member>
<member name="M:FSComp.SR.chkBaseUsedInInvalidWay">
<summary>
 The &apos;base&apos; keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:249)
</summary>
</member>
<member name="M:FSComp.SR.chkAutoOpenAttributeInTypeAbbrev">
<summary>
 FSharp.Core.AutoOpenAttribute should not be aliased.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1737)
</summary>
</member>
<member name="M:FSComp.SR.chkAttrHasAllowMultiFalse(System.String)">
<summary>
 The attribute type &apos;%s&apos; has &apos;AllowMultiple=false&apos;. Multiple instances of this attribute cannot be attached to a single language element.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:269)
</summary>
</member>
<member name="M:FSComp.SR.chkAdditionalConstructorOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Additional constructor is not allowed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1729)
</summary>
</member>
<member name="M:FSComp.SR.chkAbstractMembersDeclarationsOnStaticClasses">
<summary>
 If a type uses both [&lt;Sealed&gt;] and [&lt;AbstractClass&gt;] attributes, it means it is static. Abstract member declarations are not allowed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1733)
</summary>
</member>
<member name="M:FSComp.SR.checkRaiseFamilyFunctionArgumentCount(System.String,System.Int32,System.Int32)">
<summary>
 Redundant arguments are being ignored in function &apos;%s&apos;. Expected %d but got %d arguments.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1371)
</summary>
</member>
<member name="M:FSComp.SR.checkNotSufficientlyGenericBecauseOfScopeAnon">
<summary>
 Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1370)
</summary>
</member>
<member name="M:FSComp.SR.checkNotSufficientlyGenericBecauseOfScope(System.String)">
<summary>
 Type inference caused the type variable %s to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1369)
</summary>
</member>
<member name="M:FSComp.SR.checkLowercaseLiteralBindingInPattern(System.String)">
<summary>
 Lowercase literal &apos;%s&apos; is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1372)
</summary>
</member>
<member name="M:FSComp.SR.cannotResolveNullableOperators(System.String)">
<summary>
 The operator &apos;%s&apos; cannot be resolved. Consider opening the module &apos;Microsoft.FSharp.Linq.NullableOperators&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1343)
</summary>
</member>
<member name="M:FSComp.SR.buildUnrecognizedOption(System.String)">
<summary>
 Unrecognized option: &apos;%s&apos;. Use &apos;--help&apos; to learn about recognized command line options.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:79)
</summary>
</member>
<member name="M:FSComp.SR.buildUnexpectedTypeArgs(System.String,System.Int32)">
<summary>
 The non-generic type &apos;%s&apos; does not expect any type arguments, but here is given %d type argument(s)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:36)
</summary>
</member>
<member name="M:FSComp.SR.buildUnexpectedFileNameCharacter(System.String,System.String)">
<summary>
 Filename &apos;%s&apos; contains invalid character &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1117)
</summary>
</member>
<member name="M:FSComp.SR.buildSignatureWithoutImplementation(System.String)">
<summary>
 The signature file &apos;%s&apos; does not have a corresponding implementation file. If an implementation file exists then check the &apos;module&apos; and &apos;namespace&apos; declarations in the signature and implementation files match.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:76)
</summary>
</member>
<member name="M:FSComp.SR.buildSignatureAlreadySpecified(System.String)">
<summary>
 A signature for the file or module &apos;%s&apos; has already been specified
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:73)
</summary>
</member>
<member name="M:FSComp.SR.buildSearchDirectoryNotFound(System.String)">
<summary>
 The search directory &apos;%s&apos; could not be found
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:50)
</summary>
</member>
<member name="M:FSComp.SR.buildProblemWithFilename(System.String,System.String)">
<summary>
 Problem with filename &apos;%s&apos;: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:46)
</summary>
</member>
<member name="M:FSComp.SR.buildProblemReadingAssembly(System.String,System.String)">
<summary>
 Problem reading assembly &apos;%s&apos;: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1336)
</summary>
</member>
<member name="M:FSComp.SR.buildPdbRequiresDebug">
<summary>
 The &apos;--pdb&apos; option requires the &apos;--debug&apos; option to be used
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:48)
</summary>
</member>
<member name="M:FSComp.SR.buildOptionRequiresParameter(System.String)">
<summary>
 Option requires parameter: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:60)
</summary>
</member>
<member name="M:FSComp.SR.buildNoInputsSpecified">
<summary>
 No inputs specified
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:47)
</summary>
</member>
<member name="M:FSComp.SR.buildMultipleToplevelModules">
<summary>
 This file contains multiple declarations of the form &apos;module SomeNamespace.SomeModule&apos;. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use &apos;module ModuleName = ...&apos; to define your modules.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:59)
</summary>
</member>
<member name="M:FSComp.SR.buildMultiFileRequiresNamespaceOrModule">
<summary>
 Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. &apos;namespace SomeNamespace.SubNamespace&apos; or &apos;module SomeNamespace.SomeModule&apos;. Only the last source file of an application may omit such a declaration.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:57)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidWarningNumber(System.String)">
<summary>
 Invalid warning number &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:43)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidVersionString(System.String)">
<summary>
 Invalid version string &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:44)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidVersionFile(System.String)">
<summary>
 Invalid version file &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:45)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSourceFileExtensionUpdated(System.String)">
<summary>
 The file extension of &apos;%s&apos; is not recognized. Source files must have extension .fs, .fsi, .fsx or .fsscript
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:63)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSourceFileExtensionML(System.String)">
<summary>
 The file extension of &apos;%s&apos; is not recognized. Source files must have extension .fs, .fsi, .fsx or .fsscript. To enable the deprecated use of .ml or .mli extensions, use &apos;--langversion:5.0&apos; and &apos;--mlcompatibility&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:64)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSourceFileExtension(System.String)">
<summary>
 The file extension of &apos;%s&apos; is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:62)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidSearchDirectory(System.String)">
<summary>
 The search directory &apos;%s&apos; is invalid
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:49)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidPrivacy(System.String)">
<summary>
 Unrecognized privacy setting &apos;%s&apos; for managed resource, valid options are &apos;public&apos; and &apos;private&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:53)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidModuleOrNamespaceName">
<summary>
 Invalid module or namespace name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:80)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashtimeDirective">
<summary>
 Invalid directive. Expected &apos;#time&apos;, &apos;#time \&quot;on\&quot;&apos; or &apos;#time \&quot;off\&quot;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:71)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashrDirective">
<summary>
 Invalid directive. Expected &apos;#r \&quot;&lt;file-or-assembly&gt;\&quot;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:69)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashloadDirective">
<summary>
 Invalid directive. Expected &apos;#load \&quot;&lt;file&gt;\&quot; ... \&quot;&lt;file&gt;\&quot;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:70)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidHashIDirective">
<summary>
 Invalid directive. Expected &apos;#I \&quot;&lt;path&gt;\&quot;&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:68)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidFilename(System.String)">
<summary>
 &apos;%s&apos; is not a valid filename
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:51)
</summary>
</member>
<member name="M:FSComp.SR.buildInvalidAssemblyName(System.String)">
<summary>
 &apos;%s&apos; is not a valid assembly name
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:52)
</summary>
</member>
<member name="M:FSComp.SR.buildImplicitModuleIsNotLegalIdentifier(System.String,System.String)">
<summary>
 The declarations in this file will be placed in an implicit module &apos;%s&apos; based on the file name &apos;%s&apos;. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a &apos;module&apos; or &apos;namespace&apos; declaration at the top of the file.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:56)
</summary>
</member>
<member name="M:FSComp.SR.buildImplementationAlreadyGivenDetail(System.String)">
<summary>
 An implementation of file or module &apos;%s&apos; has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:74)
</summary>
</member>
<member name="M:FSComp.SR.buildImplementationAlreadyGiven(System.String)">
<summary>
 An implementation of the file or module &apos;%s&apos; has already been given
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:75)
</summary>
</member>
<member name="M:FSComp.SR.buildExpectedSigdataFile(System.String)">
<summary>
 FSharp.Core.sigdata not found alongside FSharp.Core. File expected in %s. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1115)
</summary>
</member>
<member name="M:FSComp.SR.buildExpectedFileAlongSideFSharpCore(System.String,System.String)">
<summary>
 File &apos;%s&apos; not found alongside FSharp.Core. File expected in %s. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1116)
</summary>
</member>
<member name="M:FSComp.SR.buildErrorOpeningBinaryFile(System.String,System.String)">
<summary>
 Error opening binary file &apos;%s&apos;: %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:66)
</summary>
</member>
<member name="M:FSComp.SR.buildDuplicateFile(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
<summary>
 The source file &apos;%s&apos; (at position %d/%d) already appeared in the compilation list (at position %d/%d). Please verify that it is included only once in the project file.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1727)
</summary>
</member>
<member name="M:FSComp.SR.buildDirectivesInModulesAreIgnored">
<summary>
 Directives inside modules are ignored
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:72)
</summary>
</member>
<member name="M:FSComp.SR.buildDifferentVersionMustRecompile(System.String)">
<summary>
 The F#-compiled DLL &apos;%s&apos; needs to be recompiled to be used with this version of F#
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:67)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotResolveAssembly(System.String)">
<summary>
 Could not resolve assembly &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:65)
</summary>
</member>
<member name="M:FSComp.SR.buildCouldNotFindSourceFile(System.String)">
<summary>
 Source file &apos;%s&apos; could not be found
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:61)
</summary>
</member>
<member name="M:FSComp.SR.buildCompilingExtensionIsForML">
<summary>
 The file extensions &apos;.ml&apos; and &apos;.mli&apos; are for ML compatibility
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1103)
</summary>
</member>
<member name="M:FSComp.SR.buildCannotReadAssembly(System.String)">
<summary>
 Unable to read assembly &apos;%s&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:54)
</summary>
</member>
<member name="M:FSComp.SR.buildAssemblyResolutionFailed">
<summary>
 Assembly resolution failure at or near this location
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:55)
</summary>
</member>
<member name="M:FSComp.SR.buildArgInvalidInt(System.String)">
<summary>
 &apos;%s&apos; is not a valid integer argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:77)
</summary>
</member>
<member name="M:FSComp.SR.buildArgInvalidFloat(System.String)">
<summary>
 &apos;%s&apos; is not a valid floating point argument
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:78)
</summary>
</member>
<member name="M:FSComp.SR.augTypeCantHaveRefEqAndStructAttrs">
<summary>
 A type cannot have both the &apos;ReferenceEquality&apos; and &apos;StructuralEquality&apos; or &apos;StructuralComparison&apos; attributes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:221)
</summary>
</member>
<member name="M:FSComp.SR.augStructEqNeedsNoCompOrStructComp">
<summary>
 The &apos;StructuralEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; or &apos;StructuralComparison&apos; attributes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:220)
</summary>
</member>
<member name="M:FSComp.SR.augStructCompNeedsStructEquality">
<summary>
 The &apos;StructuralComparison&apos; attribute must be used in conjunction with the &apos;StructuralEquality&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:219)
</summary>
</member>
<member name="M:FSComp.SR.augRefEqCantHaveObjEquals">
<summary>
 A type with attribute &apos;ReferenceEquality&apos; cannot have an explicit implementation of &apos;Object.Equals(obj)&apos;, &apos;System.IEquatable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralEquatable&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:223)
</summary>
</member>
<member name="M:FSComp.SR.augOnlyCertainTypesCanHaveAttrs">
<summary>
 Only record, union, exception and struct types may be augmented with the &apos;ReferenceEquality&apos;, &apos;StructuralEquality&apos; and &apos;StructuralComparison&apos; attributes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:222)
</summary>
</member>
<member name="M:FSComp.SR.augNoRefEqualsOnStruct">
<summary>
 The &apos;ReferenceEquality&apos; attribute cannot be used on structs. Consider using the &apos;StructuralEquality&apos; attribute instead, or implement an override for &apos;System.Object.Equals(obj)&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:216)
</summary>
</member>
<member name="M:FSComp.SR.augNoEqualityNeedsNoComparison">
<summary>
 The &apos;NoEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; attribute
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:218)
</summary>
</member>
<member name="M:FSComp.SR.augNoEqNeedsNoObjEquals">
<summary>
 A type with attribute &apos;NoEquality&apos; should not usually have an explicit implementation of &apos;Object.Equals(obj)&apos;. Disable this warning if this is intentional for interoperability purposes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:226)
</summary>
</member>
<member name="M:FSComp.SR.augNoCompCantImpIComp">
<summary>
 A type with attribute &apos;NoComparison&apos; should not usually have an explicit implementation of &apos;System.IComparable&apos;, &apos;System.IComparable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralComparable&apos;. Disable this warning if this is intentional for interoperability purposes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:227)
</summary>
</member>
<member name="M:FSComp.SR.augInvalidAttrs">
<summary>
 This type uses an invalid mix of the attributes &apos;NoEquality&apos;, &apos;ReferenceEquality&apos;, &apos;StructuralEquality&apos;, &apos;NoComparison&apos; and &apos;StructuralComparison&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:217)
</summary>
</member>
<member name="M:FSComp.SR.augCustomEqNeedsObjEquals">
<summary>
 A type with attribute &apos;CustomEquality&apos; must have an explicit implementation of at least one of &apos;Object.Equals(obj)&apos;, &apos;System.IEquatable&lt;_&gt;&apos; or &apos;System.Collections.IStructuralEquatable&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:224)
</summary>
</member>
<member name="M:FSComp.SR.augCustomEqNeedsNoCompOrCustomComp">
<summary>
 The &apos;CustomEquality&apos; attribute must be used in conjunction with the &apos;NoComparison&apos; or &apos;CustomComparison&apos; attributes
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:228)
</summary>
</member>
<member name="M:FSComp.SR.augCustomCompareNeedsIComp">
<summary>
 A type with attribute &apos;CustomComparison&apos; must have an explicit implementation of at least one of &apos;System.IComparable&apos; or &apos;System.Collections.IStructuralComparable&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:225)
</summary>
</member>
<member name="M:FSComp.SR.astParseEmbeddedILTypeError">
<summary>
 Error while parsing embedded IL type
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:213)
</summary>
</member>
<member name="M:FSComp.SR.astParseEmbeddedILError">
<summary>
 Error while parsing embedded IL
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:212)
</summary>
</member>
<member name="M:FSComp.SR.astInvalidExprLeftHandOfAssignment">
<summary>
 Invalid expression on left of assignment
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:215)
</summary>
</member>
<member name="M:FSComp.SR.astDeprecatedIndexerNotation">
<summary>
 This indexer notation has been removed from the F# language
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:214)
</summary>
</member>
<member name="M:FSComp.SR.arrayElementHasWrongTypeTuple(System.Int32,System.String,System.Int32,System.String)">
<summary>
 All elements of an array must be implicitly convertible to the type of the first element, which here is a tuple of length %d of type\n    %s    \nThis element is a tuple of length %d of type\n    %s    \n
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:25)
</summary>
</member>
<member name="M:FSComp.SR.arrayElementHasWrongType(System.String,System.String)">
<summary>
 All elements of an array must be implicitly convertible to the type of the first element, which here is &apos;%s&apos;. This element has type &apos;%s&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:24)
</summary>
</member>
<member name="M:FSComp.SR.alwaysUseTypedStringInterpolation">
<summary>
 Interpolated string contains untyped identifiers. Adding typed format specifiers is recommended.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1756)
</summary>
</member>
<member name="M:FSComp.SR.addIndexerDot">
<summary>
 Add . for indexer access.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:21)
</summary>
</member>
<member name="M:FSComp.SR.activePatternIdentIsNotFunctionTyped(System.String)">
<summary>
 Active pattern &apos;%s&apos; is not a function
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1106)
</summary>
</member>
<member name="M:FSComp.SR.activePatternChoiceHasFreeTypars(System.String)">
<summary>
 Active pattern &apos;%s&apos; has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. &apos;let (|A|B|) (x:int) = A x&apos;. This can be fixed with a type constraint, e.g. &apos;let (|A|B|) (x:int) : Choice&lt;int,unit&gt; = A x&apos;
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1107)
</summary>
</member>
<member name="M:FSComp.SR.abImplicitHeapAllocation(System.String)">
<summary>
 The mutable local &apos;%s&apos; is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1361)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityVirtualsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is virtual and the other isn&apos;t
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:122)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityTypesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe types differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:114)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityStaticsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is static and the other isn&apos;t
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:121)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityStaticButInstance(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:127)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityParameterCountsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe respective type parameter counts differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:113)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOverridesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is marked as an override and the other isn&apos;t
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:125)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOneIsTypeFunction(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:112)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityOneIsConstructor(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a constructor/property and the other is not
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:126)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:106)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityLiteralConstantValuesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe literal constant values and/or attributes differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:111)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityInstanceButStatic(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:128)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityInlineFlagsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe inline flags differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:110)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityGenericParametersDiffer(System.String,System.String,System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe number of generic parameters in the signature and implementation differ (the signature declares %s but the implementation declares %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:117)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityGenericParametersAreDifferentKinds(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [&lt;Measure&gt;] attribute.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:118)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityFinalsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is final and the other isn&apos;t
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:124)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityExtensionsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is an extension member and the other is not
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:115)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityDotNetNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe CLI member names differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:120)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityDisplayNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe display names differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:108)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityCompiledNamesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled names differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:107)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAttributesDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe mutability attributes differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:105)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityArityNotInferred(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nAn arity was not inferred for this value
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:116)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAritiesDiffer(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe arities in the signature and implementation differ. The signature specifies that &apos;%s&apos; is function definition or lambda expression accepting at least %s argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval %s: int -&gt; (int -&gt; int)\ninstead of\n\tval %s: int -&gt; int -&gt; int.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:119)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAccessibilityMore(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nThe accessibility specified in the signature is more than that specified in the implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:109)
</summary>
</member>
<member name="M:FSComp.SR.ValueNotContainedMutabilityAbstractsDiffer(System.String,System.String,System.String)">
<summary>
 Module &apos;%s&apos; contains\n    %s    \nbut its signature specifies\n    %s    \nOne is abstract and the other isn&apos;t
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:123)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButTypesOfFieldsDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe types of the fields differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:162)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButNamesDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:160)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButDataFieldsDiffer(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe respective number of data fields differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:161)
</summary>
</member>
<member name="M:FSComp.SR.ModuleContainsConstructorButAccessibilityDiffers(System.String,System.String)">
<summary>
 The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:163)
</summary>
</member>
<member name="M:FSComp.SR.InvalidRecursiveReferenceToAbstractSlot">
<summary>
 Invalid recursive reference to an abstract slot
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:972)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedTypesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe types differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:169)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedStaticsDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;static&apos; modifiers differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:166)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedNamesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe names differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:164)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedMutablesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;mutable&apos; modifiers differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:167)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedLiteralsDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe &apos;literal&apos; modifiers differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:168)
</summary>
</member>
<member name="M:FSComp.SR.FieldNotContainedAccessibilitiesDiffer(System.String,System.String)">
<summary>
 The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:165)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleSignaturesDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:187)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleHiddenBySignature(System.String,System.String)">
<summary>
 The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:184)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldOrderDiffers(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:191)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldInSigButNotImpl(System.String,System.String,System.String)">
<summary>
 The exception definitions are not compatible because the field &apos;%s&apos; was required by the signature but was not specified by the implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:189)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleFieldInImplButNotSig(System.String,System.String,System.String)">
<summary>
 The exception definitions are not compatible because the field &apos;%s&apos; was present in the implementation but not in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:190)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleExceptionDeclarationsDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:188)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleDotNetRepresentationsDiffer(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:185)
</summary>
</member>
<member name="M:FSComp.SR.ExceptionDefsNotCompatibleAbbreviationHiddenBySignature(System.String,System.String)">
<summary>
 The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:186)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the types have different base types
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:141)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypeIsHidden(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because a type representation is being hidden by a signature
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:147)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the types are of different kinds
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:148)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:136)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureSaysNull(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:135)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the implementation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:140)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot(System.String,System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature defines the %s &apos;%s&apos; but the implementation does not (or does, but not in the same order)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:143)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer(System.String,System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature declares a %s while the implementation declares a %s
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:157)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:159)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the representations differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:150)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the respective type parameter counts differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:130)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleNumbersDiffer(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the number of %ss differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:142)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleNamesDiffer(System.String,System.String,System.String)">
<summary>
 The %s definitions in the signature and implementation are not compatible because the names differ. The type is called &apos;%s&apos; in the signature file but &apos;%s&apos; in implementation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:129)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleMissingInterface(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the signature requires that the type supports the interface %s but the interface has not been implemented
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:132)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSealed(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [&lt;Sealed&gt;] attribute to the signature.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:137)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:134)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationSaysNull(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:133)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [&lt;Sealed&gt;] attribute to the implementation.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:138)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [&lt;AbstractClass&gt;] attribute to the signature.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:139)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplDefinesStruct(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:145)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot(System.String,System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the implementation defines the %s &apos;%s&apos; but the signature does not (or does, but not in the same order)
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:144)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleILDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the IL representations differ
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:149)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldWasPresent(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the field %s was present in the implementation but not in the signature
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:151)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the field %s was required by the signature but was not specified by the implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:153)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:152)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the field &apos;%s&apos; was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled &apos;private&apos; or &apos;internal&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:154)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:146)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:131)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the abstract member &apos;%s&apos; was present in the implementation but not in the signature
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:156)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl(System.String,System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because the abstract member &apos;%s&apos; was required by the signature but was not specified by the implementation
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:155)
</summary>
</member>
<member name="M:FSComp.SR.DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig(System.String,System.String)">
<summary>
 The %s definitions for type &apos;%s&apos; in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:158)
</summary>
</member>
<member name="M:FSComp.SR.DefaultParameterValueNotAppropriateForArgument">
<summary>
 The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: &apos;null&apos; needs to be annotated with the correct type, e.g. &apos;DefaultParameterValue(null:obj)&apos;.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1394)
</summary>
</member>
<member name="M:FSComp.SR.CallerMemberNameIsOverridden(System.String)">
<summary>
 The CallerMemberNameAttribute applied to parameter &apos;%s&apos; will have no effect. It is overridden by the CallerFilePathAttribute.
 (Originally from ..\..\.deps\e668b90e3c087e5fba8a855e502af60bf35be45e\src\Compiler\FSComp.txt:1389)
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.unzip``2(System.Collections.Generic.List{System.Tuple{``0,``1}})">
<summary>
 Split an array of pairs into two arrays.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.zip``2(System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Combine the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised..
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFindIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.singleton``1(``0)">
<summary>
 Return an array containing the given element.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.scanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Like &lt;c&gt;foldBack&lt;/c&gt;, but return both the intermediary and final results.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Like &lt;c&gt;fold&lt;/c&gt;, but return the intermediary and final results.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iteri2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Apply the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths,
 otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.isEmpty``1(System.Collections.Generic.List{``0})">
<summary>
 Return True if the given array is empty, otherwise False.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.forall2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if all pairs of elements satisfy the given predicate.
 Raise &lt;c&gt;ArgumentException&lt;/c&gt; if the arrays have different lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.foldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1},``2)">
<summary>
 Apply a function to pairs of elements drawn from the two collections, right-to-left,
 threading an accumulator argument through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fold2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},``0,System.Collections.Generic.List{``1},System.Collections.Generic.List{``2})">
<summary>
 Apply a function to pairs of elements drawn from the two collections,
 left-to-right, threading an accumulator argument
 through the computation.  The two input
 arrays must have the same lengths, otherwise an &lt;c&gt;ArgumentException&lt;/c&gt; is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.reduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then
 computes &lt;c&gt;f i0 (...(f iN-1 iN))&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.List{``0})">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt;
 then computes &lt;c&gt;f (... (f i0 i1)...) iN&lt;/c&gt;. Raises ArgumentException if the array has size zero.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.findIndexi``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.findIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the index of the first element in the array
 that satisfies the given predicate. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if
 none of the elements satisfy the predicate.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Test elements of the two arrays pairwise to see if any pair of element satisfies the given predicate.
 Raise ArgumentException if the arrays have different lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toSeq``1(System.Collections.Generic.List{``0})">
<summary>
 Return a view of the array as an enumerable object.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.ofArray``1(``0[])">
<summary>
 Build a &lt;c&gt;ResizeArray&lt;/c&gt; from the given elements.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toArray``1(System.Collections.Generic.List{``0})">
<summary>
 Return a fixed-length array containing the elements of the input &lt;c&gt;ResizeArray&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the key extractor and generic comparison on the keys.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sort``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.List{``0})">
<summary>
 Sort the elements using the given comparison function.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.rev``1(System.Collections.Generic.List{``0})">
<summary>
 Return a new array with the elements in reverse order.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to successive elements, returning the first
 result where function returns Some(x) for some x.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.tryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the first element for which the given function returns True.
 Return None if no such element exists.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return the first element for which the given function returns True.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to each element of the array. Return
 the array comprised of the results &quot;x&quot; for each element where
 the function returns &lt;c&gt;Some(x)&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Split the collection into two collections, containing the
 elements for which the given predicate returns True and False
 respectively.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns True.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.forall``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if all elements of the array satisfy the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; and &quot;j0...jN&quot;
 then computes &lt;c&gt;p i0 &amp;&amp; ... &amp;&amp; p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.List{``0})">
<summary>
 Test if any element of the array satisfies the given predicate.
 If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt;
 then computes &lt;c&gt;p i0 or ... or p iN&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.List{``0})">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iteri``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to each element of the array.  The integer passed to the
 function indicates the index of element.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.  The two input
 arrays must have the same lengths.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iter2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.List{``0},System.Collections.Generic.List{``1})">
<summary>
 Apply the given function to two arrays simultaneously. The
 two arrays must have the same lengths, otherwise an Invalid_argument exception is
 raised.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Build a new array whose elements are the results of applying the given function
 to each of the elements of the array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.List{``0})">
<summary>
 Apply the given function to each element of the array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.List{``0},``1)">
<summary>
 Apply a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt; then
 computes &lt;c&gt;f i0 (...(f iN s))&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.List{``1})">
<summary>
 Apply a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is &lt;c&gt;f&lt;/c&gt; and the elements are &lt;c&gt;i0...iN&lt;/c&gt;
 then computes &lt;c&gt;f (... (f s i0)...) iN&lt;/c&gt;
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Build an array from the given list.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.toList``1(System.Collections.Generic.List{``0})">
<summary>
 Build a list from the given array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.blit``1(System.Collections.Generic.List{``0},System.Int32,System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
 Read a range of elements from the first array and write them into the second.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.fill``1(System.Collections.Generic.List{``0},System.Int32,System.Int32,``0)">
<summary>
 Fill a range of the collection with the given element.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.copy``1(System.Collections.Generic.List{``0})">
<summary>
 Build a new array that contains the elements of the given array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.sub``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
<summary>
 Build a new array that contains the given subrange specified by
 starting index and length.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.concat``1(Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.List{``0}})">
<summary>
 Build a new array that contains the elements of each of the given list of arrays.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.append``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
<summary>
 Build a new array that contains the elements of the first array followed by the elements of the second array.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.init``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 Create an array by calling the given generator on each index.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.create``1(System.Int32,``0)">
<summary>
 Create an array whose elements are all initially the given value.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.set``1(System.Collections.Generic.List{``0},System.Int32,``0)">
<summary>
 Set the value of an element in the collection. You can also use the syntax &lt;c&gt;arr.[idx] &lt;- e&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.get``1(System.Collections.Generic.List{``0},System.Int32)">
<summary>
 Fetch an element from the collection.  You can also use the syntax &lt;c&gt;arr.[idx]&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.ResizeArrayModule.length``1(System.Collections.Generic.List{``0})">
<summary>
 Return the length of the collection.  You can also use property &lt;c&gt;arr.Length&lt;/c&gt;.
</summary>
</member>
<member name="T:Internal.Utilities.ResizeArrayModule">
<summary>
 Generic operations on the type System.Collections.Generic.List, which is called ResizeArray in the F# libraries.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Item(`0,`1)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Item(`0)">
<summary>
 Lookup or set the given element in the table. Set replaces all existing bindings for a value with a single
 bindings. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if the element is not found.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.HashMultiMap`2.Count">
<summary>
 The total number of keys in the hash table.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.TryFind(`0)">
<summary>
 Lookup the given element in the table, returning the result as an Option.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Replace(`0,`1)">
<summary>
 Replace the latest binding if any for the given element.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Remove(`0)">
<summary>
 Remove the latest binding if any for the given element from the table.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply the given function to each binding in the hash table.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Apply the given function to each element in the collection threading the accumulating parameter
 through the sequence of function applications.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.FindAll(`0)">
<summary>
 Find all bindings for the given element in the table, if any.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Copy">
<summary>
 Make a shallow copy of the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.ContainsKey(`0)">
<summary>
 Test if the collection contains any bindings for the given element.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Clear">
<summary>
 Clear all elements from the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.Add(`0,`1)">
<summary>
 Add a binding for the element to the table.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}},System.Collections.Generic.IEqualityComparer{`0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Build a map that contains the bindings of the given IEnumerable.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new empty mutable HashMultiMap with an internal bucket array of the given approximate size
 and with the given key hash/equality functions.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.HashMultiMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new empty mutable HashMultiMap with the given key hash/equality functions.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.HashMultiMap`2">
<summary>
 Hash tables, by default based on F# structural &quot;hash&quot; and (=) functions.
 The table may map a single key to multiple bindings.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Zmap`2">
<summary>
 Maps with a specific comparison function
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Zset`1">
<summary>
 Sets with a specific comparison function
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.TryGetSimilarAny(`0,`1)">
<summary>
 Get the value for the given key or &lt;c&gt;None&lt;/c&gt; if not still valid. Skips `areSame` checking unless `areSimilar` is not provided.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.TryGetSimilar(`0,`1)">
<summary>
 Get the value for the given key or None, but only if entry is still valid. Skips `areSame` checking unless `areSimilar` is not provided.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.TryGetAny(`0,`1)">
<summary>
 Get the value for the given key or &lt;c&gt;None&lt;/c&gt; if not still valid.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.TryGet(`0,`1)">
<summary>
 Get the value for the given key or None, but only if entry is still valid
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.Set(`0,`1,`2)">
<summary>
 Set the given key.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.Resize(`0,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Resize
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.RemoveAnySimilar(`0,`1)">
<summary>
 Remove the given value from the mru cache.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.ContainsSimilarKey(`0,`1)">
<summary>
 Get the similar (subsumable) value for the given key or &lt;c&gt;None&lt;/c&gt; if not already available.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.MruCache`3.Clear(`0)">
<summary>
 Clear out the cache.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.MruCache`3">
<summary>
 Simple priority caching for a small number of key/value associations.
 This cache may age-out results that have been Set by the caller.
 Because of this, the caller must be able to tolerate values
 that aren&apos;t what was originally passed to the Set function.

 Concurrency: This collection is thread-safe, though concurrent use may result in different
 threads seeing different live sets of cached items.

  - areSimilar: Keep at most once association for two similar keys (as given by areSimilar)
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.TryPeekKeyValue(`0,`1)">
<summary>
 Lookup the value without making it the most recent.
 Returns the original key value because the areSame function
 may have unified two different keys.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.TryGetKeyValue(`0,`1)">
<summary>
 Lookup a value and make it the most recent.
 Returns the original key value because the areSame function
 may have unified two different keys.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.TryGet(`0,`1)">
<summary>
 Lookup a value and make it the most recent. Return &lt;c&gt;None&lt;/c&gt; if it wasn&apos;t there.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.Resize(`0,System.Int32,Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Resize
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.Remove(`0,`1)">
<summary>
 Remove the given value from the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.Put(`0,`1,`2)">
<summary>
 Add an element to the collection. Make it the most recent.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.AgedLookup`3.Clear(`0)">
<summary>
 Remove all elements.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.AgedLookup`3">
<summary>
 Simple aging lookup table. When a member is accessed it&apos;s
 moved to the top of the list and when there are too many elements
 the least-recently-accessed element falls of the end.

  - areSimilar: Keep at most once association for two similar keys (as given by areSimilar)
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.Item(`0)">
<summary>
 Lookup an element in the map. Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no binding
 exists in the map.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.IsEmpty">
<summary>
 Return True if there are no bindings in the map.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Map`3.Count">
<summary>
 The number of bindings in the map.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.TryFind(`0)">
<summary>
 Lookup an element in the map, returning a Some value if the element is in the domain 
 of the map and None if not.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ToArray">
<summary>
 The elements of the set as an array.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Remove(`0)">
<summary>
 Remove an element from the domain of the map.  No exception is raised if the element is not present.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Partition(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Build two new maps, one containing the bindings for which the given predicate returns True,
 and another for the remaining bindings.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.MapRange``1(Microsoft.FSharp.Core.FSharpFunc{`1,``0})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Map``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The index passed to the
 function indicates the index of element being transformed.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.Unit}})">
<summary>
 Apply the given function to each binding in the dictionary.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ForAll(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Return True if the given predicate returns true for all of the
 bindings in the map. Always returns true if the map is empty.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.FoldSection``1(`0,`0,Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Given the start and end points of a key range,
 Fold over the bindings in the map that are in the range,
 and the end points are included if present (the range is considered a closed interval).
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.FoldAndMap``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``1,``0}}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}},``0)">
<summary>
 Fold over the bindings in the map.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.First``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 Search the map looking for the first element where the given function returns a Some value.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Build a new map containing the bindings for which the given predicate returns True.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,System.Boolean}})">
<summary>
 Return True if the given predicate returns true for one of the
 bindings in the map. Always returns false if the map is empty.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Empty(`2)">
<summary>
 The empty map, and use the given comparer comparison function for all operations associated
 with any maps built from this map.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Create(`2,System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
<summary>
 Build a map that contains the bindings of the given &lt;c&gt;IEnumerable&lt;/c&gt;
 and where comparison of elements is based on the given comparison function.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.ContainsKey(`0)">
<summary>
 Test is an element is in the domain of the map.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Map`3.Add(`0,`1)">
<summary>
 Return a new map with the binding added to the given map.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Tagged.Map`3">
<summary>
 Immutable maps.  Keys are ordered by construction function specified
 when creating empty maps or by F# structural comparison if no
 construction function is specified.

 &lt;performance&gt; 
   Maps based on structural comparison are  
   efficient for small keys. They are not a suitable choice if keys are recursive data structures 
   or require non-structural comparison semantics.
 &lt;/performance&gt;
 Immutable maps.  A constraint tag carries information about the class of key-comparers being used.  
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.op_Subtraction(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.op_Addition(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.MinimumElement">
<summary>
 Returns the lowest element in the set according to the ordering being used for the set.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.MaximumElement">
<summary>
 Returns the highest element in the set according to the ordering being used for the set.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.IsEmpty">
<summary>
 A useful shortcut for &lt;c&gt;Set.isEmpty&lt;/c&gt;.  See the &lt;c&gt;Set&lt;/c&gt; module for further operations on sets.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.Count">
<summary>
 Return the number of elements in the set.
</summary>
</member>
<member name="P:Internal.Utilities.Collections.Tagged.Set`2.Choose">
<summary>
 The number of elements in the set.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Union(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the union of the two sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ToList">
<summary>
 The elements of the set as a list.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ToArray">
<summary>
 The elements of the set as an array.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Singleton(`1,`0)">
<summary>
 A singleton set based on the given comparison operator.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Remove(`0)">
<summary>
 A useful shortcut for &lt;c&gt;Set.remove&lt;/c&gt;.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the &lt;c&gt;Set&lt;/c&gt; module for further operations on sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Partition(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Build two new sets, one containing the elements for which the given predicate returns True,
 and another with the remaining elements.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Iterate(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit})">
<summary>
 Apply the given function to each binding in the collection.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.IsSupersetOf(Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to True if all elements of the first set are in the second.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.IsSubsetOf(Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Evaluates to True if all elements of the second set are in the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Intersection(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compute the intersection of the two sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.ForAll(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Test if all elements of the collection satisfy the given predicate.
 If the input function is f and the elements are i0...iN and j0...jN then 
 computes p i0 &amp;&amp; ... &amp;&amp; p iN.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Fold``1(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0)">
<summary>
 Apply the given accumulating function to all the elements of the set.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Filter(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Return a new collection containing only the elements of the collection
 for which the given predicate returns True.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Exists(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean})">
<summary>
 Test if any element of the collection satisfies the given predicate.
 If the input function is f and the elements are i0...iN then computes 
 p i0 or ... or p iN.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Equality(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares two sets and returns True if they are equal or False otherwise.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Empty(`1)">
<summary>
 The empty set based on the given comparer.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Difference(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Return a new set with the elements of the second set removed from the first.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Create(`1,System.Collections.Generic.IEnumerable{`0})">
<summary>
 A set based on the given comparer containing the given initial elements.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Contains(`0)">
<summary>
 A useful shortcut for &lt;c&gt;Set.contains&lt;/c&gt;.  See the &lt;c&gt;Set&lt;/c&gt; module for further operations on sets.
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Compare(Internal.Utilities.Collections.Tagged.Set{`0,`1},Internal.Utilities.Collections.Tagged.Set{`0,`1})">
<summary>
 Compares a and b and returns 1 if a &gt; b, -1 if b &lt; a and 0 if a = b.       
</summary>
</member>
<member name="M:Internal.Utilities.Collections.Tagged.Set`2.Add(`0)">
<summary>
 A useful shortcut for &lt;c&gt;Set.add&lt;/c&gt;.  Note this operation produces a new set
 and does not mutate the original set.  The new set will share many storage
 nodes with the original.  See the &lt;c&gt;Set&lt;/c&gt; module for further operations on sets.
</summary>
</member>
<member name="T:Internal.Utilities.Collections.Tagged.Set`2">
<summary>
 Immutable sets based on binary trees, default tag
 Immutable sets where a constraint tag carries information about the class of key-comparer being used.  
</summary>
</member>
<member name="T:Internal.Utilities.Library.LayeredMultiMap`2">
<summary>
 Immutable map collection, with explicit flattening to a backing dictionary
</summary>
</member>
<member name="T:Internal.Utilities.Library.IPartialEqualityComparer`1">
<summary>
 Interface that defines methods for comparing objects using partial equality relation
</summary>
</member>
<member name="T:Internal.Utilities.Library.LazyWithContext`2">
<summary>
 Just like &quot;Lazy&quot; but EVERY forcer must provide an instance of &quot;ctxt&quot;, e.g. to help track errors
 on forcing back to at least one sensible user location
</summary>
</member>
<member name="T:Internal.Utilities.Library.StampedDictionary`2">
<summary>
 A thread-safe lookup table which is assigning an auto-increment stamp with each insert
</summary>
</member>
<member name="T:Internal.Utilities.Library.MemoizationTable`2">
<summary>
 Memoize tables (all entries cached, never collected unless whole table is collected)
</summary>
</member>
<member name="T:Internal.Utilities.Library.UniqueStampGenerator`1">
<summary>
 Generates unique stamps
</summary>
</member>
<member name="T:Internal.Utilities.Library.Lock`1">
<summary>
 Encapsulates a lock associated with a particular token-type representing the acquisition of that lock.
</summary>
</member>
<member name="T:Internal.Utilities.Library.LockToken">
<summary>
 A base type for various types of tokens that must be passed when a lock is taken.
 Each different static lock should declare a new subtype of this type.
</summary>
</member>
<member name="T:Internal.Utilities.Library.AnyCallerThreadToken">
<summary>
 Represents a token that indicates execution on any of several potential user threads calling the F# compiler services.
</summary>
</member>
<member name="T:Internal.Utilities.Library.CompilationThreadToken">
<summary>
 Represents a token that indicates execution on the compilation thread, i.e.
   - we have full access to the (partially mutable) TAST and TcImports data structures
   - compiler execution may result in type provider invocations when resolving types and members
   - we can access various caches in the SourceCodeServices

 Like other execution tokens this should be passed via argument passing and not captured/stored beyond
 the lifetime of stack-based calls. This is not checked, it is a discipline within the compiler code.
</summary>
</member>
<member name="T:Internal.Utilities.Library.ExecutionToken">
<summary>
 Represents a permission active at this point in execution
</summary>
</member>
<member name="T:Internal.Utilities.Library.Cancellable`1">
<summary>
 Represents a synchronous, cold-start, cancellable computation with explicit representation of a cancelled result.

 A cancellable computation may be cancelled via a CancellationToken, which is propagated implicitly.
 If cancellation occurs, it is propagated as data rather than by raising an OperationCanceledException.
</summary>
</member>
<member name="M:Internal.Utilities.Library.NameMap.subfold2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}}},Microsoft.FSharp.Collections.FSharpMap{``0,``3},Microsoft.FSharp.Collections.FSharpMap{``0,``1},``2)">
<summary>
 For every entry in m2 find an entry in m1 and fold
</summary>
</member>
<member name="M:Internal.Utilities.Library.NameMap.union``2(Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``0},``1},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpMap{System.String,``0}})">
<summary>
 Union entries by identical key, using the provided function to union sets of values
</summary>
</member>
<member name="M:Internal.Utilities.Library.NameMap.layerAdditive``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Collections.FSharpList{``0}}},Microsoft.FSharp.Collections.FSharpMap{``2,``1},Microsoft.FSharp.Collections.FSharpMap{``2,Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Not a very useful function - only called in one place - should be changed
</summary>
</member>
<member name="M:Internal.Utilities.Library.IPartialEqualityComparer.partialDistinctBy``1(Internal.Utilities.Library.IPartialEqualityComparer{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Like Seq.distinctBy but only filters out duplicates for some of the elements
</summary>
</member>
<member name="T:Internal.Utilities.Library.IPartialEqualityComparer">
<summary>
 Interface that defines methods for comparing objects using partial equality relation
</summary>
</member>
<member name="T:Internal.Utilities.Library.Tables">
<summary>
 Intern tables to save space.
</summary>
</member>
<member name="M:Internal.Utilities.Library.LockAutoOpens.AssumeCompilationThreadWithoutEvidence">
<summary>
 Represents a place in the compiler codebase where we assume we are executing on a compilation thread
</summary>
</member>
<member name="M:Internal.Utilities.Library.LockAutoOpens.DoesNotRequireCompilerThreadTokenAndCouldPossiblyBeMadeConcurrent(Internal.Utilities.Library.CompilationThreadToken)">
<summary>
 Represents a place in the compiler codebase where we are passed a CompilationThreadToken unnecessarily.
 This represents code that may potentially not need to be executed on the compilation thread.
</summary>
</member>
<member name="M:Internal.Utilities.Library.LockAutoOpens.RequireCompilationThread(Internal.Utilities.Library.CompilationThreadToken)">
<summary>
 Represents a place where we are stating that execution on the compilation thread is required. The
 reason why will be documented in a comment in the code at the callsite.
</summary>
</member>
<member name="M:Internal.Utilities.Library.String.split(System.StringSplitOptions,System.String[],System.String)">
<summary>
 Splits a string into substrings based on the strings in the array separators
</summary>
</member>
<member name="M:Internal.Utilities.Library.ResizeArray.mapToSmallArrayChunks``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Split a large ResizeArray into a series of array chunks that are each under the Large Object Heap limit.
 This is done to help prevent a stop-the-world collection of the single large array, instead allowing for a greater
 probability of smaller collections. Stop-the-world is still possible, just less likely.
</summary>
</member>
<member name="M:Internal.Utilities.Library.ResizeArray.chunkBySize``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.List{``0})">
<summary>
 Split a ResizeArray into an array of smaller chunks.
 This requires `items/chunkSize` Array copies of length `chunkSize` if `items/chunkSize % 0 = 0`,
 otherwise `items/chunkSize + 1` Array copies.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.endsWith``1(``0[],``0[])">
<summary>
 Returns true if one array has trailing elements equal to another&apos;s.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.startsWith``1(``0[],``0[])">
<summary>
 Returns true if one array has another as its subset from index 0.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.isSubArray``1(``0[],``0[],System.Int32)">
<summary>
 Check if subArray is found in the wholeArray starting at the provided index
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.heads``1(``0[])">
<summary>
 Returns all heads of a given array.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.areEqual``1(``0[],``0[])">
<summary>
 Optimized arrays equality. ~100x faster than `array1 = array2` on strings.
 ~2x faster for floats
 ~0.8x slower for ints
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.replace``1(System.Int32,``0,``0[])">
<summary>
 Returns a new array with an element replaced with a given value.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.mapAsync``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},``0[])">
<summary>
 Async implementation of Array.map.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Array.revInPlace``1(``0[])">
<summary>
 pass an array byref to reverse it in place
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.Async.RunImmediate.Static``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Runs the computation synchronously, always starting on the current thread.
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.getHole``1(Microsoft.FSharp.Core.FSharpRef{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Get an initialization hole
</summary>
</member>
<member name="P:Internal.Utilities.Library.PervasiveAutoOpens.LOH_SIZE_THRESHOLD_BYTES">
<summary>
 Per the docs the threshold for the Large Object Heap is 85000 bytes: https://learn.microsoft.com/dotnet/standard/garbage-collection/large-object-heap#how-an-object-ends-up-on-the-large-object-heap-and-how-gc-handles-them
 We set the limit to be 80k to account for larger pointer sizes for when F# is running 64-bit.
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.isSingleton``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns true if the list contains exactly 1 element. Otherwise false.
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.isNilOrSingleton``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Returns true if the list has less than 2 elements. Otherwise false.
</summary>
</member>
<member name="M:Internal.Utilities.Library.PervasiveAutoOpens.op_GreaterGreaterGreaterAmp(System.Int32,System.Int32)">
<summary>
 Logical shift right treating int32 as unsigned integer.
 Code that uses this should probably be adjusted to use unsigned integer types.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Cancellable.token">
<summary>
 Bind the cancellation token associated with the computation
</summary>
</member>
<member name="M:Internal.Utilities.Library.Cancellable.runWithoutCancellation``1(Internal.Utilities.Library.Cancellable{``0})">
<summary>
 Run the computation in a mode where it may not be cancelled. The computation never results in a
 ValueOrCancelled.Cancelled.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Cancellable.run``1(System.Threading.CancellationToken,Internal.Utilities.Library.Cancellable{``0})">
<summary>
 Run a cancellable computation using the given cancellation token
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.DisposablesTracker.Register(System.IDisposable)">
<summary>
 Register some items to dispose
</summary>
</member>
<member name="T:Internal.Utilities.Library.Extras.DisposablesTracker">
<summary>
 Track a set of resources to cleanup
</summary>
</member>
<member name="T:Internal.Utilities.Library.Extras.cache`1">
<summary>
 Caches, mainly for free variables
</summary>
</member>
<member name="T:Internal.Utilities.Library.Extras.NonNullSlot`1">
<summary>
 In some cases we play games where we use &apos;null&apos; as a more efficient representation
 in F#. The functions below are used to give initial values to mutable fields.
 This is an unsafe trick, as it relies on the fact that the type of values
 being placed into the slot never utilizes &quot;null&quot; as a representation. To be used with
 with care.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.StringBuilder.AppendString(System.Text.StringBuilder,System.String)">
<summary>
 Like Append, but returns unit
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.writeViaBuffer(System.IO.TextWriter,Microsoft.FSharp.Core.FSharpFunc{System.Text.StringBuilder,Microsoft.FSharp.Core.Unit})">
<summary>
 Writing to output stream via a string buffer.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.buildString(Microsoft.FSharp.Core.FSharpFunc{System.Text.StringBuilder,Microsoft.FSharp.Core.Unit})">
<summary>
 Buffer printing utility
</summary>
</member>
<member name="T:Internal.Utilities.Library.Extras.ArrayParallel">
<summary>
 Specialized parallel functions for an array.
 Different from Array.Parallel as it will try to minimize the max degree of parallelism.
 Will flatten aggregate exceptions that contain one exception.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.setify``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Note: if duplicates appear, keep the ones toward the _front_ of the list
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.intersect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 NOTE: not tail recursive!
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.subtract``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 NOTE: quadratic!
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.findIndex``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``1,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 NOTE: O(n)!
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListSet.insert``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 NOTE: O(n)!
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListAssoc.tryFind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Treat a list of key-value pairs as a lookup collection.
 This function looks up a value based on a match from the supplied
 predicate function and returns None if value does not exist.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.ListAssoc.find``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``1,``2}})">
<summary>
 Treat a list of key-value pairs as a lookup collection.
 This function looks up a value based on a match from the supplied predicate function.
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.Bits.b3(System.Int32)">
<summary>
 Get the most significant byte of a 32-bit integer
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.Bits.b2(System.Int32)">
<summary>
 Get the 3rd least significant byte of a 32-bit integer
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.Bits.b1(System.Int32)">
<summary>
 Get the 2nd least significant byte of a 32-bit integer
</summary>
</member>
<member name="M:Internal.Utilities.Library.Extras.Bits.b0(System.Int32)">
<summary>
 Get the least significant byte of a 32-bit integer
</summary>
</member>
<member name="M:Internal.Utilities.PathMapModule.applyDir(Internal.Utilities.PathMap,System.String)">
<summary>
 Map a directory name with its replacement.
 Prefixes are compared case sensitively.
</summary>
</member>
<member name="M:Internal.Utilities.PathMapModule.apply(Internal.Utilities.PathMap,System.String)">
<summary>
 Map a file path with its replacement.
 Prefixes are compared case sensitively.
</summary>
</member>
<member name="M:Internal.Utilities.PathMapModule.addMapping(System.String,System.String,Internal.Utilities.PathMap)">
<summary>
 Add a path mapping to the map.
</summary>
</member>
<member name="T:Internal.Utilities.Hashing.Md5StringHasher">
<summary>
 Tools for hashing things with MD5 into a string that can be used as a cache key.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.UnicodeTables.Interpret(System.Int32,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Interpret tables for a unicode lexer generated by &lt;c&gt;fslex.exe&lt;/c&gt;.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.UnicodeTables.Create(System.UInt16[][],System.UInt16[])">
<summary>
 Create the tables from raw data
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.UnicodeTables">
<summary>
 The type of tables for an unicode lexer generated by &lt;c&gt;fslex.exe&lt;/c&gt;.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The start position for the lexeme.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream(System.Boolean)">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to True.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos(Internal.Utilities.Text.Lexing.Position)">
<summary>
 The end position for the lexeme.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.StartPos">
<summary>
 The start position for the lexeme.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.ReportLibraryOnlyFeatures">
<summary>
 Determines if the parser can report FSharpCore library-only features.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeView">
<summary>
 The currently matched text as a Span, it is only valid until the lexer is advanced
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.LanguageVersion">
<summary>
 Get the language version being supported
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.IsPastEndOfStream">
<summary>
 True if the refill of the buffer ever failed , or if explicitly set to True.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.EndPos">
<summary>
 The end position for the lexeme.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.LexBuffer`1.BufferLocalStore">
<summary>
 Dynamically typed, non-lexically scoped parameter table.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.SupportsFeature(Fantomas.FCS.Features.LanguageFeature)">
<summary>
 True if the specified language feature is supported.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeString(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Fast helper to turn the matched characters into a string, avoiding an intermediate array.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeContains(`0)">
<summary>
 Determine if Lexeme contains a specific character
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.LexemeChar(System.Int32)">
<summary>
 Get single character of matched string
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromSourceText(System.Boolean,Fantomas.FCS.Features.LanguageVersion,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Fantomas.FCS.Text.ISourceText)">
<summary>
 Create a lex buffer backed by source text.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromFunction(System.Boolean,Fantomas.FCS.Features.LanguageVersion,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{`0[],System.Int32,System.Int32},System.Int32})">
<summary>
 Create a lex buffer that reads character or byte inputs by using the given function.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.FromChars(System.Boolean,Fantomas.FCS.Features.LanguageVersion,Microsoft.FSharp.Core.FSharpOption{System.Boolean},System.Char[])">
<summary>
 Create a lex buffer suitable for Unicode lexing that reads characters from the given array.
 Important: does take ownership of the array.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.LexBuffer`1.CheckLanguageFeatureAndRecover(Fantomas.FCS.Features.LanguageFeature,Fantomas.FCS.Text.Range)">
<summary>
 Logs a recoverable error if a language feature is unsupported, at the specified range.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.LexBuffer`1">
<summary>
 Input buffers consumed by lexers generated by &lt;c&gt;fslex.exe&lt;/c&gt;.
 The type must be generic to match the code generated by FsLex and FsYacc (if you would like to
 fix this, please submit a PR to the FsLexYacc repository allowing for optional emit of a non-generic type reference).
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.StartOfLineAbsoluteOffset">
<summary>
 Return absolute offset of the start of the line marked by the position.
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.AbsoluteOffset">
<summary>
 The character number in the input stream.
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.OriginalLine">
<summary>
 The line number for the position in the input stream, assuming fresh positions have been updated
 using for the new line.
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.Line">
<summary>
 The line number in the input stream, assuming fresh positions have been updated
 for the new line by modifying the EndPos property of the LexBuffer.
</summary>
</member>
<member name="F:Internal.Utilities.Text.Lexing.Position.FileIndex">
<summary>
 The file index for the file associated with the input stream, use &lt;c&gt;fileOfFileIndex&lt;/c&gt; to decode
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.NextLine">
<summary>
 Given a position just beyond the end of a line, return a position at the start of the next line.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Empty">
<summary>
 Get an arbitrary position, with the empty string as file name.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.ColumnMinusOne">
<summary>
 Same line, column -1.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Lexing.Position.Column">
<summary>
 Return the column number marked by the position,
 i.e. the difference between the &lt;c&gt;AbsoluteOffset&lt;/c&gt; and the &lt;c&gt;StartOfLineAbsoluteOffset&lt;/c&gt;
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.ShiftColumnBy(System.Int32)">
<summary>
 Gives a position shifted by specified number of characters.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.EndOfToken(System.Int32)">
<summary>
 Given a position at the start of a token of length n, return a position just beyond the end of the token.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Lexing.Position.ApplyLineDirective(System.Int32,System.Int32)">
<summary>
 Apply a #line directive.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Lexing.Position">
<summary>
 Position information stored for lexing tokens
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.tagOfErrorTerminal">
<summary>
 The tag of the error terminal.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.numTerminals">
<summary>
 The total number of terminals.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.parseError">
<summary>
 This function is used to hold the user specified &quot;parse_error&quot; or &quot;parse_error_rich&quot; functions.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.productionToNonTerminalTable">
<summary>
 This table is logically part of the Goto table.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.stateToProdIdxsTableRowOffsets">
<summary>
 The sparse table offsets for the productions active for each state.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.stateToProdIdxsTableElements">
<summary>
 The sparse table for the productions active for each state.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.sparseGotoTableRowOffsets">
<summary>
 The sparse goto table row offsets.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.gotos">
<summary>
 The sparse goto table.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.immediateActions">
<summary>
 The immediate action table.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.reductionSymbolCounts">
<summary>
 The number of symbols for each reduction.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.actionTableRowOffsets">
<summary>
 The sparse action table row offsets.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.actionTableElements">
<summary>
 The sparse action table elements.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.dataOfToken">
<summary>
 A function to compute the data carried by a token.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.tagOfToken">
<summary>
 A function to compute the tag of a token.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.endOfInputTag">
<summary>
 The token number indicating the end of input.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.Tables`1.reductions">
<summary>
 The reduction table.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.Tables`1.Interpret(Microsoft.FSharp.Core.FSharpFunc{Internal.Utilities.Text.Lexing.LexBuffer{System.Char},`0},Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Int32)">
<summary>
 Interpret the parser table taking input from the given lexer, using the given lex buffer, and the given start state.
 Returns an object indicating the final synthesized value for the parse.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.Tables`1">
<summary>
 Tables generated by fsyacc
 The type of the tables contained in a file produced by the &lt;c&gt;fsyacc.exe&lt;/c&gt; parser generator.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.StateStack">
<summary>
 The stack of state indexes active at the parse error .
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ShiftTokens">
<summary>
 The token that would cause a shift at the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReducibleProductions">
<summary>
 The stack of productions that would be reduced at the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ReduceTokens">
<summary>
 The tokens that would cause a reduction at the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.ParseState">
<summary>
 The state active at the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.Message">
<summary>
 The message associated with the parse error.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.ParseErrorContext`1.CurrentToken">
<summary>
 The token that caused the parse error.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseErrorContext`1">
<summary>
 The context provided when a parse error occurs.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultStartPosition">
<summary>
 Get the start of the range of positions matched by the production.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultRange">
<summary>
 Get the full range of positions matched by the production.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.ResultEndPosition">
<summary>
 Get the end of the range of positions matched by the production.
</summary>
</member>
<member name="P:Internal.Utilities.Text.Parsing.IParseState.LexBuffer">
<summary>
 Return the LexBuffer for this parser instance.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.RaiseError``1">
<summary>
 Raise an error in this parse context.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputStartPosition(System.Int32)">
<summary>
 Get the start position for the terminal or non-terminal at a given index matched by the production.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputRange(System.Int32)">
<summary>
 Get the start and end position for the terminal or non-terminal at a given index matched by the production.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.InputEndPosition(System.Int32)">
<summary>
 Get the end position for the terminal or non-terminal at a given index matched by the production.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.IParseState.GetInput(System.Int32)">
<summary>
 Get the value produced by the terminal or non-terminal at the given position.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.RecoverableParseError">
<summary>
 Indicates a parse error has occurred and parse recovery is in progress.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.Accept">
<summary>
 Indicates an accept action has occurred.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error(System.String)">
<summary>
 The default implementation of the parse_error function.
</summary>
</member>
<member name="M:Internal.Utilities.Text.Parsing.ParseHelpers.parse_error_rich``1">
<summary>
 The default implementation of the parse_error_rich function.
</summary>
</member>
<member name="T:Internal.Utilities.Text.Parsing.ParseHelpers">
<summary>
 Helpers used by generated parsers.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteStorage.FromMemoryAndCopy(System.ReadOnlyMemory{System.Byte},System.Boolean)">
<summary>
 Creates a ByteStorage that has a copy of the given Memory&lt;byte&gt;.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteStorage.FromByteMemoryAndCopy(Fantomas.FCS.IO.ReadOnlyByteMemory,System.Boolean)">
<summary>
 Creates a ByteStorage that has a copy of the given ByteMemory.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteStorage.FromByteMemory(Fantomas.FCS.IO.ReadOnlyByteMemory)">
<summary>
 Creates a ByteStorage whose backing bytes are the given ByteMemory. Does not make a copy.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteStorage.FromByteArrayAndCopy(System.Byte[],System.Boolean)">
<summary>
 Creates a ByteStorage that has a copy of the given byte array.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteStorage.FromByteArray(System.Byte[])">
<summary>
 Creates a ByteStorage whose backing bytes are the given byte array. Does not make a copy.
</summary>
</member>
<member name="T:Fantomas.FCS.IO.ByteBuffer">
<summary>
 Imperative buffers and streams of byte[]
 Not thread safe.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.DefaultFileSystem.#ctor">
<summary>
 Create a default implementation of the file system
</summary>
</member>
<member name="T:Fantomas.FCS.IO.DefaultFileSystem">
<summary>
 Represents a default (memory-mapped) implementation of the file system
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.OpenFileForWriteShim(System.String,Microsoft.FSharp.Core.FSharpOption{System.IO.FileMode},Microsoft.FSharp.Core.FSharpOption{System.IO.FileAccess},Microsoft.FSharp.Core.FSharpOption{System.IO.FileShare})">
<summary>
 Open the file for writing. Returns a Stream.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.OpenFileForReadShim(System.String,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Open the file for read, returns ByteMemory, uses either FileStream (for smaller files) or MemoryMappedFile (for potentially big files, such as dlls).
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.NormalizePathShim(System.String)">
<summary>
 Removes relative parts from any full paths
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.IsStableFileHeuristic(System.String)">
<summary>
 Used to determine if a file will not be subject to deletion during the lifetime of a typical client process.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.IsPathRootedShim(System.String)">
<summary>
 A shim over Path.IsPathRooted
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.IsInvalidPathShim(System.String)">
<summary>
 A shim over Path.IsInvalidPath
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.GetTempPathShim">
<summary>
 A shim over Path.GetTempPath
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.GetLastWriteTimeShim(System.String)">
<summary>
 Utc time of the last modification
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.GetFullPathShim(System.String)">
<summary>
 Take in a file name with an absolute path, and return the same file name
 but canonicalized with respect to extra path separators (e.g. C:\\\\foo.txt)
 and &apos;..&apos; portions
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.GetFullFilePathInDirectoryShim(System.String,System.String)">
<summary>
 Take in a directory, filename, and return canonicalized path to the file name in directory.
 If file name path is rooted, ignores directory and returns file name path.
 Otherwise, combines directory with file name and gets full path via GetFullPathShim(string).
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.GetDirectoryNameShim(System.String)">
<summary>
 A shim for getting directory name from path
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.FileExistsShim(System.String)">
<summary>
 A shim over File.Exists
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.FileDeleteShim(System.String)">
<summary>
 A shim over File.Delete
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.EnumerateFilesShim(System.String,System.String)">
<summary>
 A shim over Directory.EnumerateFiles
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.EnumerateDirectoriesShim(System.String)">
<summary>
 A shim over Directory.EnumerateDirectories
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.DirectoryExistsShim(System.String)">
<summary>
 A shim over Directory.Exists
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.DirectoryDeleteShim(System.String)">
<summary>
 A shim over Directory.Delete
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.DirectoryCreateShim(System.String)">
<summary>
 A shim over Directory.Exists, but returns a string, the FullName of the resulting
 DirectoryInfo.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IFileSystem.ChangeExtensionShim(System.String,System.String)">
<summary>
 A shim over Path.ChangeExtension
</summary>
</member>
<member name="T:Fantomas.FCS.IO.IFileSystem">
<summary>
 Represents a shim for the file system
</summary>
</member>
<member name="T:Fantomas.FCS.IO.DefaultAssemblyLoader">
<summary>
 Default implementation for IAssemblyLoader
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IAssemblyLoader.AssemblyLoadFrom(System.String)">
<summary>
 Used to load type providers and located assemblies in F# Interactive
</summary>
</member>
<member name="M:Fantomas.FCS.IO.IAssemblyLoader.AssemblyLoad(System.Reflection.AssemblyName)">
<summary>
 Used to load a dependency for F# Interactive and in an unused corner-case of type provider loading
</summary>
</member>
<member name="T:Fantomas.FCS.IO.IAssemblyLoader">
<summary>
 Type which we use to load assemblies.
</summary>
</member>
<member name="P:Fantomas.FCS.IO.ByteMemory.Empty">
<summary>
 Gets a ByteMemory object that is empty
</summary>
</member>
<member name="P:Fantomas.FCS.IO.ByteMemory.Empty">
<summary>
 Empty byte memory.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteMemory.FromUnsafePointer(System.IntPtr,System.Int32,System.Object)">
<summary>
 Creates a ByteMemory object that is backed by a raw pointer.
 Use with care.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteMemory.FromMemoryMappedFile(System.IO.MemoryMappedFiles.MemoryMappedFile)">
<summary>
 Create a ByteMemory object that has a backing memory mapped file.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteMemory.FromArray(System.Byte[])">
<summary>
 Creates a ByteMemory object that is backed by a byte array.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteMemory.FromArray(System.Byte[],System.Int32,System.Int32)">
<summary>
 Creates a ByteMemory object that is backed by a byte array with the specified offset and length.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteMemory.AsStream">
<summary>
 Get a stream representation of the backing memory.
 Disposing this will not free up any of the backing memory.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.ByteMemory.AsReadOnlyStream">
<summary>
 Get a stream representation of the backing memory.
 Disposing this will not free up any of the backing memory.
 Stream cannot be written to.
</summary>
</member>
<member name="T:Fantomas.FCS.IO.ByteMemory">
<summary>
 A view over bytes.
 May be backed by managed or unmanaged memory, or memory mapped file.
</summary>
</member>
<member name="P:Fantomas.FCS.IO.FileSystemAutoOpens.FileSystem">
<summary>
 The global hook into the file system
</summary>
</member>
<member name="M:Fantomas.FCS.IO.FileSystemUtils.isDll(System.String)">
<summary>
 Checks whether file is dll (ends in .dll)
</summary>
</member>
<member name="M:Fantomas.FCS.IO.FileSystemUtils.trimQuotes(System.String)">
<summary>
 Trim the quotes and spaces from either end of a string
</summary>
</member>
<member name="M:Fantomas.FCS.IO.FileSystemUtils.fileNameWithoutExtensionWithValidate(System.Boolean,System.String)">
<summary>
 Get the file name without extension of the given path.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.FileSystemUtils.fileNameOfPath(System.String)">
<summary>
 Get the file name of the given path.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.FileSystemUtils.hasExtension(System.String)">
<summary>
 Return True if the path has a &quot;.&quot; extension.
</summary>
</member>
<member name="M:Fantomas.FCS.IO.FileSystemUtils.chopExtension(System.String)">
 <c>chopExtension f</c> removes the extension from the given
 file name. Raises <c>ArgumentException</c> if no extension is present.
</member>
<member name="M:Fantomas.FCS.IO.FileSystemUtils.checkSuffix(System.String,System.String)">
 <c>checkSuffix f s</c> returns True if file name "f" ends in suffix "s",
 e.g. checkSuffix "abc.fs" ".fs" returns true.
 Disregards casing, e.g. checkSuffix "abc.Fs" ".fs" returns true.
</member>
<member name="T:Fantomas.FCS.IO.FileSystemUtils">
<summary>
 Filesystem helpers
</summary>
</member>
<member name="T:Fantomas.FCS.IO.MemoryMappedFileExtensions">
<summary>
 MemoryMapped extensions
</summary>
</member>
<member name="M:Fantomas.FCS.IO.Bytes.blit(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
<summary>
 each int will be 0 &lt;= x &lt;= 255
</summary>
</member>
<member name="M:Fantomas.FCS.IO.Bytes.ofInt32Array(System.Int32[])">
<summary>
 each int must be 0 &lt;= x &lt;= 255
</summary>
</member>
<member name="M:Fantomas.FCS.IO.Bytes.get(System.Byte[],System.Int32)">
<summary>
 returned int will be 0 &lt;= x &lt;= 255
</summary>
</member>
<member name="P:Fantomas.FCS.Features.LanguageVersion.VersionText">
<summary>
 Get the text used to specify the version, several of which may map to the same version
</summary>
</member>
<member name="P:Fantomas.FCS.Features.LanguageVersion.ValidVersions">
<summary>
 Get the list of valid versions
</summary>
</member>
<member name="P:Fantomas.FCS.Features.LanguageVersion.ValidOptions">
<summary>
 Get the list of valid options
</summary>
</member>
<member name="P:Fantomas.FCS.Features.LanguageVersion.SpecifiedVersionString">
<summary>
 Get the specified LanguageVersion as a string
</summary>
</member>
<member name="P:Fantomas.FCS.Features.LanguageVersion.SpecifiedVersion">
<summary>
 Get the specified LanguageVersion
</summary>
</member>
<member name="P:Fantomas.FCS.Features.LanguageVersion.IsPreviewEnabled">
<summary>
 Has preview been explicitly specified
</summary>
</member>
<member name="M:Fantomas.FCS.Features.LanguageVersion.SupportsFeature(Fantomas.FCS.Features.LanguageFeature)">
<summary>
 Does the selected LanguageVersion support the specified feature
</summary>
</member>
<member name="M:Fantomas.FCS.Features.LanguageVersion.IsExplicitlySpecifiedAs50OrBefore">
<summary>
 Has been explicitly specified as 4.6, 4.7 or 5.0
</summary>
</member>
<member name="M:Fantomas.FCS.Features.LanguageVersion.GetFeatureVersionString(Fantomas.FCS.Features.LanguageFeature)">
<summary>
 Get a version string associated with the given feature.
</summary>
</member>
<member name="M:Fantomas.FCS.Features.LanguageVersion.GetFeatureString(Fantomas.FCS.Features.LanguageFeature)">
<summary>
 Get a string name for the given feature.
</summary>
</member>
<member name="M:Fantomas.FCS.Features.LanguageVersion.ContainsVersion(System.String)">
<summary>
 Get the list of valid versions
</summary>
</member>
<member name="M:Fantomas.FCS.Features.LanguageVersion.#ctor(System.String)">
<summary>
 Create a LanguageVersion management object
</summary>
</member>
<member name="T:Fantomas.FCS.Features.LanguageVersion">
<summary>
 LanguageVersion management
</summary>
</member>
<member name="T:Fantomas.FCS.Features.LanguageFeature.PreferExtensionMethodOverPlainProperty">
<summary>
 RFC-1137
</summary>
</member>
<member name="T:Fantomas.FCS.Features.LanguageFeature">
<summary>
 LanguageFeature enumeration
</summary>
</member>
<member name="T:Fantomas.FCS.Features">
<summary>
 Coordinating compiler operations - configuration, loading initial context, reporting errors etc.
</summary>
</member>
<member name="T:Fantomas.FCS.Diagnostics.Activity">
<summary>
 For activities following the dotnet distributed tracing concept
 https://learn.microsoft.com/dotnet/core/diagnostics/distributed-tracing-concepts?source=recommendations
</summary>
</member>
<member name="T:Fantomas.FCS.Diagnostics.ActivityNames">
<summary>
 For activities following the dotnet distributed tracing concept
 https://learn.microsoft.com/dotnet/core/diagnostics/distributed-tracing-concepts?source=recommendations
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.CompilationGlobalsScope.#ctor">
<summary>
 When disposed, restores caller&apos;s diagnostics logger and build phase.
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.CompilationGlobalsScope">
<summary>
 This represents the global state established as each task function runs as part of the build.

 Use to reset error and warning handlers.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.StackGuard.Guard``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.String,System.String,System.Int32)">
<summary>
 Execute the new function, on a new thread if necessary
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.SuppressLanguageFeatureCheck">
<summary>
 Indicates whether a language feature check should be skipped. Typically used in recursive functions
 where we don&apos;t want repeated recursive calls to raise the same diagnostic multiple times.
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.OperationResult`1">
<summary>
 The result type of a computational modality to collect warnings and possibly fail
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.DiagnosticsThreadStatics">
<summary>
 Thread statics for the installed diagnostic logger
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.CapturingDiagnosticsLogger">
<summary>
 Represents a DiagnosticsLogger that captures all diagnostics, optionally formatting them
 eagerly.
</summary>
</member>
<member name="P:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger.ErrorCount">
<summary>
 Get the number of error diagnostics reported
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger.DiagnosticSink(Fantomas.FCS.DiagnosticsLogger.PhasedDiagnostic,Fantomas.FCS.Diagnostics.FSharpDiagnosticSeverity)">
<summary>
 Emit a diagnostic to the logger
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger.CheckForErrors">
<summary>
 Checks if ErrorCount &gt; 0
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger">
<summary>
 Represents a capability to log diagnostics
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.PhasedDiagnostic.Subcategory">
<summary>
 This is the textual subcategory to display in error and warning messages (shows only under --vserrors):

     file1.fs(72): subcategory warning FS0072: This is a warning message

</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.PhasedDiagnostic.IsSubcategoryOfCompile(System.String)">
<summary>
 Return true if the textual phase given is from the compile part of the build process.
 This set needs to be equal to the set of subcategories that the language service can produce.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.PhasedDiagnostic.IsPhaseInCompile">
<summary>
 Return true if this phase is one that&apos;s known to be part of the &apos;compile&apos;. This is the initial phase of the entire compilation that
 the language service knows about.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.PhasedDiagnostic.Create(System.Exception,Fantomas.FCS.DiagnosticsLogger.BuildPhase)">
<summary>
 Construct a phased error
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.BuildPhase">
<summary>
 Closed enumeration of build phases.
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.StopProcessingExiter">
<summary>
 An exiter that raises StopProcessingException if Exit is called, saving the exit code in ExitCode.
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.Exiter">
<summary>
 Represents an early exit from parsing, checking etc, for example because &apos;maxerrors&apos; has been reached.
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.DiagnosticStyle">
<summary>
 Represents the style being used to format errors
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.NormalizeErrorString(System.String)">
<summary>
 fixes given string by replacing all control chars with spaces.
 NOTE: newlines are recognized and replaced with stringThatIsAProxyForANewlineInFlatErrors (ASCII 29, the &apos;group separator&apos;),
 which is decoded by the IDE with &apos;NewlineifyErrorString&apos; back into newlines, so that multi-line errors can be displayed in QuickInfo
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.Iterate2D``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Fantomas.FCS.DiagnosticsLogger.OperationResult{Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})">
<summary>
 Stop on first error. Accumulate warnings and continue.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.IterateD``1(Microsoft.FSharp.Core.FSharpFunc{``0,Fantomas.FCS.DiagnosticsLogger.OperationResult{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Stop on first error. Accumulate warnings and continue.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Fantomas.FCS.DiagnosticsLogger.OperationResult{``1}},Fantomas.FCS.DiagnosticsLogger.OperationResult{``0})">
<summary>
 The bind in the monad. Stop on first error. Accumulate warnings and continue.
 &lt;remarks&gt;Not meant for direct usage. Used in other inlined functions&lt;/remarks&gt;
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.informationalWarning(System.Exception)">
<summary>
 Reports an informational diagnostic
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.error``1(System.Exception)">
<summary>
 Reports an error and raises a ReportedError exception
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.warning(System.Exception)">
<summary>
 Reports a warning diagnostic
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.errorR(System.Exception)">
<summary>
 Reports an error diagnostic and continues
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.UseTransformedDiagnosticsLogger(Microsoft.FSharp.Core.FSharpFunc{Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger,Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger})">
<summary>
 NOTE: The change will be undone when the returned &quot;unwind&quot; object disposes
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.UseBuildPhase(Fantomas.FCS.DiagnosticsLogger.BuildPhase)">
<summary>
 NOTE: The change will be undone when the returned &quot;unwind&quot; object disposes
</summary>
</member>
<member name="P:Fantomas.FCS.DiagnosticsLogger.AssertFalseDiagnosticsLogger">
<summary>
 Represents a DiagnosticsLogger that ignores diagnostics and asserts
</summary>
</member>
<member name="P:Fantomas.FCS.DiagnosticsLogger.DiscardErrorsLogger">
<summary>
 Represents a DiagnosticsLogger that discards diagnostics
</summary>
</member>
<member name="P:Fantomas.FCS.DiagnosticsLogger.QuitProcessExiter">
<summary>
 An exiter that quits the process if Exit is called.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.ErrorEnabledWithLanguageFeature(System.Tuple{System.Int32,System.String},Fantomas.FCS.Text.Range,System.Boolean)">
<summary>
 Creates a DiagnosticEnabledWithLanguageFeature whose text comes via SR.*
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.ErrorWithSuggestions(System.Tuple{System.Int32,System.String},Fantomas.FCS.Text.Range,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a DiagnosticWithSuggestions whose text comes via SR.*
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.Error(System.Tuple{System.Int32,System.String},Fantomas.FCS.Text.Range)">
<summary>
 Creates a diagnostic exception whose text comes via SR.*
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.DiagnosticEnabledWithLanguageFeature">
<summary>
 A diagnostic that is raised when enabled manually, or by default with a language feature
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.DiagnosticWithText">
<summary>
 Represents a diagnostic exception whose text comes via SR.*
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.StopProcessingExn">
<summary>
 Thrown when we stop processing the F# Interactive entry or #load.
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.ReportedError">
<summary>
 Thrown when immediate, local error recovery is not possible. This indicates
 we&apos;ve reported an error but need to make a non-local transfer of control.
 Error recovery may catch this and continue (see &apos;errorRecovery&apos;)

 The exception that caused the report is carried as data because in some
 situations (LazyWithContext) we may need to re-report the original error
 when a lazy thunk is re-evaluated.
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.WrappedError">
<summary>
 Thrown when we want to add some range information to a .NET exception
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.MultipleDiagnosticsLoggers.Sequential``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Run computations sequentially starting immediately on the current thread.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.MultipleDiagnosticsLoggers.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Control.FSharpAsync{``0}})">
<summary>
 Run computations using Async.Parallel.
 Captures the diagnostics from each computation and commits them to the caller&apos;s logger preserving their order.
 When done, restores caller&apos;s build phase and diagnostics logger.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.ErrorRecoveryNoRange(Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger,System.Exception)">
<summary>
 Like ErrorRecover by no range is attached to System.Exception and ArgumentException.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.StopProcessingRecovery(Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger,System.Exception,Fantomas.FCS.Text.Range)">
<summary>
 Perform error recovery from an exception if possible, including catching StopProcessingExn
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.ErrorRecovery(Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger,System.Exception,Fantomas.FCS.Text.Range)">
<summary>
 Perform error recovery from an exception if possible.
 - StopProcessingExn is not caught.
 - ReportedError is caught and ignored.
 - TargetInvocationException is unwrapped
 - If precisely a System.Exception or ArgumentException then the range is attached as InternalError.
 - Other exceptions are unchanged

 All are reported via the installed diagnostics logger
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.SimulateError``1(Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger,Fantomas.FCS.DiagnosticsLogger.PhasedDiagnostic)">
<summary>
 Simulates a diagnostic. For test purposes only.
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.Error``1(Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger,System.Exception)">
<summary>
 Report a diagnostic as an error and raise `ReportedError`
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.Warning(Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger,System.Exception)">
<summary>
 Report a diagnostic as a warning and recover
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLoggerExtensions.DiagnosticsLogger.ErrorR(Fantomas.FCS.DiagnosticsLogger.DiagnosticsLogger,System.Exception)">
<summary>
 Report a diagnostic as an error and recover
</summary>
</member>
<member name="M:Fantomas.FCS.DiagnosticsLogger.DiagnosticsLoggerExtensions.PreserveStackTrace``1(``0)">
<summary>
 Instruct the exception not to reset itself when thrown again.
</summary>
</member>
<member name="T:Fantomas.FCS.DiagnosticsLogger.BuildPhaseSubcategory">
<summary>
 Literal build phase subcategory strings.
</summary>
</member>
<member name="T:Fantomas.FCS.Text.FormatOptions">
<summary>
 A record of options to control structural formatting.
 For F# Interactive properties matching those of this value can be accessed via the &apos;fsi&apos;
 value.

 Floating Point format given in the same format accepted by System.Double.ToString,
 e.g. f6 or g15.

 If ShowProperties is set the printing process will evaluate properties of the values being
 displayed.  This may cause additional computation.

 The ShowIEnumerable is set the printing process will force the evaluation of IEnumerable objects
 to a small, finite depth, as determined by the printing parameters.
 This may lead to additional computation being performed during printing.
</summary>
</member>
<member name="P:Fantomas.FCS.Text.IEnvironment.MaxRows">
<summary>
 The maximum number of rows for which to generate layout for table-like
 structures.  -1 if no maximum.
</summary>
</member>
<member name="P:Fantomas.FCS.Text.IEnvironment.MaxColumns">
<summary>
 The maximum number of elements for which to generate layout for
 list-like structures, or columns in table-like
 structures.  -1 if no maximum.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.IEnvironment.GetLayout(System.Object)">
<summary>
 Return to the layout-generation
 environment to layout any otherwise uninterpreted object
</summary>
</member>
<member name="T:Fantomas.FCS.Text.Layout">
<summary>
 Data representing structured layouts of terms.
</summary>
</member>
<member name="P:Fantomas.FCS.Text.TaggedText.Text">
<summary>
 Gets the text
</summary>
</member>
<member name="P:Fantomas.FCS.Text.TaggedText.Tag">
<summary>
 Gets the tag
</summary>
</member>
<member name="M:Fantomas.FCS.Text.TaggedText.#ctor(Fantomas.FCS.Text.TextTag,System.String)">
<summary>
 Creates text with a tag
</summary>
</member>
<member name="T:Fantomas.FCS.Text.TaggedText">
<summary>
 Represents text with a tag
</summary>
</member>
<member name="T:Fantomas.FCS.Text.TextTag">
<summary>
 Represents the tag of some tagged text
</summary>
</member>
<member name="T:Fantomas.FCS.Text.Joint">
<summary>
 Data representing joints in structured layouts of terms.  The representation
 of this data type is only for the consumption of formatting engines.
</summary>
</member>
<member name="T:Fantomas.FCS.Text.Range01">
<summary>
 Represents a range using zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="T:Fantomas.FCS.Text.Position01">
<summary>
 Represents a position using zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="T:Fantomas.FCS.Text.Line0">
<summary>
 Represents a line number when using zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="T:Fantomas.FCS.Text.range">
<summary>
 Represents a range within a file
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.Zero">
<summary>
 The range where all values are zero
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.StartRange">
<summary>
 The empty range that is located at the start position of the range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.StartLine">
<summary>
 The start line of the range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.StartColumn">
<summary>
 The start column of the range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.Start">
<summary>
 The start position of the range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.NotedSourceConstruct">
<summary>
 When de-sugaring computation expressions we convert a debug point into a plain range, and then later
 recover that the range definitely indicates a debug point.
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.IsSynthetic">
<summary>
 Synthetic marks ranges which are produced by intermediate compilation phases. This
 bit signifies that the range covers something that should not be visible to language
 service operations like dot-completion.
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.FileName">
<summary>
 The file name for the file of the range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.FileIndex">
<summary>
 The file index for the range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.EndRange">
<summary>
 The empty range that is located at the end position of the range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.EndLine">
<summary>
 The line number for the end position of the range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.EndColumn">
<summary>
 The column number for the end position of the range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Range.End">
<summary>
 The end position of the range
</summary>
</member>
<member name="M:Fantomas.FCS.Text.Range.NoteSourceConstruct(Fantomas.FCS.Text.NotedSourceConstruct)">
<summary>
 Note that a range indicates a debug point
</summary>
</member>
<member name="M:Fantomas.FCS.Text.Range.MakeSynthetic">
<summary>
 Convert a range to be synthetic
</summary>
</member>
<member name="M:Fantomas.FCS.Text.Range.IsAdjacentTo(Fantomas.FCS.Text.Range)">
<summary>
 Check if the range is adjacent to another range
</summary>
</member>
<member name="T:Fantomas.FCS.Text.Range">
<summary>
 Represents a range within a file
</summary>
</member>
<member name="T:Fantomas.FCS.Text.pos">
<summary>
 Represents a position in a file
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Position.Line">
<summary>
 The line number for the position
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Position.EncodingSize">
<summary>
 The maximum number of bits needed to store an encoded position 
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Position.Encoding">
<summary>
 The encoding of the position as a 64-bit integer
</summary>
</member>
<member name="P:Fantomas.FCS.Text.Position.Column">
<summary>
 The column number for the position
</summary>
</member>
<member name="M:Fantomas.FCS.Text.Position.IsAdjacentTo(Fantomas.FCS.Text.Position)">
<summary>
 Check if the position is adjacent to another position
</summary>
</member>
<member name="M:Fantomas.FCS.Text.Position.Decode(System.Int64)">
<summary>
 Decode a position fro a 64-bit integer
</summary>
</member>
<member name="T:Fantomas.FCS.Text.Position">
<summary>
 Represents a position in a file
</summary>
</member>
<member name="T:Fantomas.FCS.Text.NotedSourceConstruct.DelayOrQuoteOrRun">
<summary>
 Notes that a range is related to an implied &quot;Delay&quot;m &quot;Quote&quot; or &quot;Run&quot; at the entry to a computation expression. This doesn&apos;t
 apply to the &quot;Delay&quot; calls added for try/with, try/finally, while or for constructs.
</summary>
</member>
<member name="T:Fantomas.FCS.Text.NotedSourceConstruct.Combine">
<summary>
 Notes that a range is related to a sequential &quot;a; b&quot; translated to a &quot;Combine&quot; call in a computation expression

 This doesn&apos;t include &quot;expr; cexpr&quot; sequentials where the &quot;expr&quot; is a side-effecting simple statement
 This does include &quot;expr; cexpr&quot; sequentials where the &quot;expr&quot; is interpreted as an implicit yield + Combine call
</summary>
</member>
<member name="T:Fantomas.FCS.Text.NotedSourceConstruct.With">
<summary>
 Notes that a range is related to a &quot;with&quot; in a &quot;try/with&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:Fantomas.FCS.Text.NotedSourceConstruct.Finally">
<summary>
 Notes that a range is related to a &quot;finally&quot; in a &quot;try/finally&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:Fantomas.FCS.Text.NotedSourceConstruct.Binding">
<summary>
 Notes that a range is related to a &quot;let&quot; or other binding range in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:Fantomas.FCS.Text.NotedSourceConstruct.Try">
<summary>
 Notes that a range is related to a &quot;try&quot; in a &quot;try/with&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:Fantomas.FCS.Text.NotedSourceConstruct.InOrTo">
<summary>
 Notes that a range is related to a &quot;in&quot; in a &quot;for .. in ... do&quot; or &quot;to&quot; in &quot;for .. = .. to .. do&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:Fantomas.FCS.Text.NotedSourceConstruct.For">
<summary>
 Notes that a range is related to a &quot;for&quot; in &quot;for .. do&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:Fantomas.FCS.Text.NotedSourceConstruct.While">
<summary>
 Notes that a range is related to a &quot;while&quot; in &quot;while .. do&quot; in a computation, list, array or sequence expression
</summary>
</member>
<member name="T:Fantomas.FCS.Text.FileIndex">
<summary>
 An index into a global tables of filenames
</summary>
</member>
<member name="T:Fantomas.FCS.Text.ISourceTextNew">
<summary>
 Just like ISourceText, but with a checksum. Added as a separate type to avoid breaking changes.
</summary>
</member>
<member name="P:Fantomas.FCS.Text.ISourceText.Length">
<summary>
 Gets the total length of the input in characters
</summary>
</member>
<member name="P:Fantomas.FCS.Text.ISourceText.Item(System.Int32)">
<summary>
 Gets a character in an input based on an index of characters from the start of the file
</summary>
</member>
<member name="M:Fantomas.FCS.Text.ISourceText.SubTextEquals(System.String,System.Int32)">
<summary>
 Checks if a section of the input is equal to the given string
</summary>
</member>
<member name="M:Fantomas.FCS.Text.ISourceText.GetSubTextString(System.Int32,System.Int32)">
<summary>
 Gets a section of the input
</summary>
</member>
<member name="M:Fantomas.FCS.Text.ISourceText.GetSubTextFromRange(Fantomas.FCS.Text.Range)">
<summary>
 Gets a section of the input based on a given range.
 &lt;exception cref=&quot;System.ArgumentException&quot;&gt;Throws an exception when the input range is outside the file boundaries.&lt;/exception&gt;
</summary>
</member>
<member name="M:Fantomas.FCS.Text.ISourceText.GetLineString(System.Int32)">
<summary>
 Gets a line of an input by index
</summary>
</member>
<member name="M:Fantomas.FCS.Text.ISourceText.GetLineCount">
<summary>
 Gets the count of lines in the input
</summary>
</member>
<member name="M:Fantomas.FCS.Text.ISourceText.GetLastCharacterPosition">
<summary>
 Gets the last character position in the input, returning line and column
</summary>
</member>
<member name="M:Fantomas.FCS.Text.ISourceText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
<summary>
 Copies a section of the input to the given destination ad the given index
</summary>
</member>
<member name="M:Fantomas.FCS.Text.ISourceText.ContentEquals(Fantomas.FCS.Text.ISourceText)">
<summary>
 Checks if one input is equal to another
</summary>
</member>
<member name="T:Fantomas.FCS.Text.ISourceText">
<summary>
 Represents an input to the F# compiler
</summary>
</member>
<member name="M:Fantomas.FCS.Text.Display.layout_to_string(Fantomas.FCS.Text.FormatOptions,Fantomas.FCS.Text.Layout)">
<summary>
 Convert any value to a layout using the given formatting options.  The
 layout can then be processed using formatting display engines such as
 those in the Layout module.  any_to_string and output_any are
 built using any_to_layout with default format options.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.unfoldL``2(Microsoft.FSharp.Core.FSharpFunc{``0,Fantomas.FCS.Text.Layout},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1,System.Int32)">
<summary>
 For limiting layout of list-like sequences (lists,arrays,etc).
 unfold a list of items using (project and z) making layout list via itemL.
 If reach maxLength (before exhausting) then truncate.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.tagAttrL(System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}},Fantomas.FCS.Text.Layout)">
<summary>
 See tagL
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.listL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Fantomas.FCS.Text.Layout},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Layout like an F# list.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.optionL``1(Microsoft.FSharp.Core.FSharpFunc{``0,Fantomas.FCS.Text.Layout},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Layout like an F# option.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.aboveListL(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Text.Layout})">
<summary>
 Layout list vertically.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.aboveL(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Layout two vertically.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.tupleL(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Text.Layout})">
<summary>
 Form tuple of layouts.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.braceL(Fantomas.FCS.Text.Layout)">
<summary>
 Wrap braces around layout.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.squareBracketL(Fantomas.FCS.Text.Layout)">
<summary>
 Wrap square brackets around layout.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.bracketL(Fantomas.FCS.Text.Layout)">
<summary>
 Wrap round brackets around Layout.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.sepListL(Fantomas.FCS.Text.Layout,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Text.Layout})">
<summary>
 Join layouts into a list separated using the given Layout.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.semiListL(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Text.Layout})">
<summary>
 Join layouts into a semi-colon separated list.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.spaceListL(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Text.Layout})">
<summary>
 Join layouts into a space separated list.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.commaListL(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Text.Layout})">
<summary>
 Join layouts into a comma separated list.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_AtAtMinusMinusMinusMinus(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Join broken with ident=4
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_AtAtMinusMinusMinus(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Join broken with ident=3
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_AtAtMinusMinus(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Join broken with ident=2
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_AtAtMinus(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Join broken with ident=1
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_AtAt(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Join broken with ident=0
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_MinusMinusMinusMinusMinus(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 optional break, indent=4
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_MinusMinusMinusMinus(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 optional break, indent=3
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_MinusMinusMinus(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Join, possible break with indent=2
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_MinusMinus(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Join, possible break with indent=1
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_PlusPlus(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Join, possible break with indent=0
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.op_HatHat(Fantomas.FCS.Text.Layout,Fantomas.FCS.Text.Layout)">
<summary>
 Join, unbreakable.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.leftL(Fantomas.FCS.Text.TaggedText)">
<summary>
 An string which is left  parenthesis (no space on the right).
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.rightL(Fantomas.FCS.Text.TaggedText)">
<summary>
 An string which is right parenthesis (no space on the left).
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.sepL(Fantomas.FCS.Text.TaggedText)">
<summary>
 An string which requires no spaces either side.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.wordL(Fantomas.FCS.Text.TaggedText)">
<summary>
 An string leaf
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.objL(System.Object)">
<summary>
 An uninterpreted leaf, to be interpreted into a string
 by the layout engine. This allows leaf layouts for numbers, strings and
 other atoms to be customized according to culture.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.endsWithL(System.String,Fantomas.FCS.Text.Layout)">
<summary>
 Check if the last character in the layout is the given character
</summary>
</member>
<member name="M:Fantomas.FCS.Text.LayoutModule.isEmptyL(Fantomas.FCS.Text.Layout)">
<summary>
 Is it the empty layout?
</summary>
</member>
<member name="P:Fantomas.FCS.Text.LayoutModule.emptyL">
<summary>
 The empty layout
</summary>
</member>
<member name="T:Fantomas.FCS.Text.LayoutModule">
<summary>
 A layout is a sequence of strings which have been joined together.
 The strings are classified as words, separators and left and right parenthesis.
 This classification determines where spaces are inserted.
 A joint is either unbreakable, breakable or broken.
 If a joint is broken the RHS layout occurs on the next line with optional indentation.
 A layout can be squashed to for given width which forces breaks as required.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.Line.toZ(System.Int32)">
<summary>
 Convert a line number from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="M:Fantomas.FCS.Text.Line.fromZ(System.Int32)">
<summary>
 Convert a line number from zero-based line counting (used by Visual Studio) to one-based line counting (used internally in the F# compiler and in F# error messages) 
</summary>
</member>
<member name="T:Fantomas.FCS.Text.Line">
<summary>
 Functions related to converting between lines indexed at 0 and 1
</summary>
</member>
<member name="P:Fantomas.FCS.Text.RangeModule.comparer">
<summary>
 Equality comparer for range.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.toFileZ(Fantomas.FCS.Text.Range)">
<summary>
 Convert a range from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.toZ(Fantomas.FCS.Text.Range)">
<summary>
 Convert a range from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.stringOfRange(Fantomas.FCS.Text.Range)">
<summary>
 Convert a range to a string
</summary>
</member>
<member name="P:Fantomas.FCS.Text.RangeModule.rangeCmdArgs">
<summary>
 A range associated with a dummy file for the command line arguments
</summary>
</member>
<member name="P:Fantomas.FCS.Text.RangeModule.rangeStartup">
<summary>
 A range associated with a dummy file called &quot;startup&quot;
</summary>
</member>
<member name="P:Fantomas.FCS.Text.RangeModule.range0">
<summary>
 The zero range
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.rangeN(System.String,System.Int32)">
<summary>
 Make a dummy range for a file
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.rangeBeforePos(Fantomas.FCS.Text.Range,Fantomas.FCS.Text.Position)">
<summary>
 Test to see if a range occurs fully before a position
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.rangeContainsPos(Fantomas.FCS.Text.Range,Fantomas.FCS.Text.Position)">
<summary>
 Test to see if a range contains a position
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.rangeContainsRange(Fantomas.FCS.Text.Range,Fantomas.FCS.Text.Range)">
<summary>
 Test to see if one range contains another range
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.unionRanges(Fantomas.FCS.Text.Range,Fantomas.FCS.Text.Range)">
<summary>
 Union two ranges, taking their first occurring start position and last occurring end position
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.outputRange(System.IO.TextWriter,Fantomas.FCS.Text.Range)">
<summary>
 Output a range
</summary>
</member>
<member name="P:Fantomas.FCS.Text.RangeModule.rangeOrder">
<summary>
 Order ranges (file, then start pos, then end pos)
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.trimRangeToLine(Fantomas.FCS.Text.Range)">
<summary>
 Reduce a range so it only covers a line
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.mkFirstLineOfFile(System.String)">
<summary>
 Make a range for the first non-whitespace line of the file if any. Otherwise use line 1 chars 0-80.
 This involves reading the file.
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.mkRange(System.String,Fantomas.FCS.Text.Position,Fantomas.FCS.Text.Position)">
<summary>
 This view hides the use of file indexes and just uses filenames 
</summary>
</member>
<member name="M:Fantomas.FCS.Text.RangeModule.mkFileIndexRange(System.Int32,Fantomas.FCS.Text.Position,Fantomas.FCS.Text.Position)">
<summary>
 This view of range marks uses file indexes explicitly 
</summary>
</member>
<member name="P:Fantomas.FCS.Text.RangeModule.posOrder">
<summary>
 Ordering on positions
</summary>
</member>
<member name="M:Fantomas.FCS.Text.FileIndexModule.fileOfFileIndex(System.Int32)">
<summary>
 Convert an index into a file path
</summary>
</member>
<member name="M:Fantomas.FCS.Text.FileIndexModule.fileIndexOfFile(System.String)">
<summary>
 Convert a file path to an index
</summary>
</member>
<member name="P:Fantomas.FCS.Text.PositionModule.pos0">
<summary>
 The zero position
</summary>
</member>
<member name="M:Fantomas.FCS.Text.PositionModule.stringOfPos(Fantomas.FCS.Text.Position)">
<summary>
 Convert a position to a string
</summary>
</member>
<member name="M:Fantomas.FCS.Text.PositionModule.outputPos(System.IO.TextWriter,Fantomas.FCS.Text.Position)">
<summary>
 Output a position
</summary>
</member>
<member name="M:Fantomas.FCS.Text.PositionModule.toZ(Fantomas.FCS.Text.Position)">
<summary>
 Convert a position from one-based line counting (used internally in the F# compiler and in F# error messages) to zero-based line counting (used by Visual Studio)
</summary>
</member>
<member name="M:Fantomas.FCS.Text.PositionModule.fromZ(System.Int32,System.Int32)">
<summary>
 Convert a position from zero-based line counting (used by Visual Studio) to one-based line counting (used internally in the F# compiler and in F# error messages) 
</summary>
</member>
<member name="M:Fantomas.FCS.Text.PositionModule.posGeq(Fantomas.FCS.Text.Position,Fantomas.FCS.Text.Position)">
<summary>
 Compare positions for greater-than-or-equal-to
</summary>
</member>
<member name="M:Fantomas.FCS.Text.PositionModule.posEq(Fantomas.FCS.Text.Position,Fantomas.FCS.Text.Position)">
<summary>
 Compare positions for equality
</summary>
</member>
<member name="M:Fantomas.FCS.Text.PositionModule.posGt(Fantomas.FCS.Text.Position,Fantomas.FCS.Text.Position)">
<summary>
 Compare positions for greater-than
</summary>
</member>
<member name="M:Fantomas.FCS.Text.PositionModule.posLt(Fantomas.FCS.Text.Position,Fantomas.FCS.Text.Position)">
<summary>
 Compare positions for less-than
</summary>
</member>
<member name="M:Fantomas.FCS.Text.PositionModule.mkPos(System.Int32,System.Int32)">
<summary>
 Create a position for the given line and column
</summary>
</member>
<member name="M:Fantomas.FCS.Text.SourceText.ofString(System.String)">
<summary>
 Creates an ISourceText object from the given string
</summary>
</member>
<member name="T:Fantomas.FCS.Text.SourceText">
<summary>
 Functions related to ISourceText objects
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.Diagnostics">
<summary>
 Diagnostics from the AbsIL toolkit. You can reset the diagnostics
 stream to point elsewhere, or turn it
 off altogether by setting it to &apos;None&apos;.  The logging channel initially
 points to stderr.  All functions call flush() automatically.

 REVIEW: review if we should just switch to System.Diagnostics
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILPropertyRef">
<summary>
 A utility type provided for completeness
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILEventRef">
<summary>
 A utility type provided for completeness
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILEnumInfo">
<summary>
 Decompose a type definition according to its kind.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILLocalsAllocator">
<summary>
 Helpers for codegen: scopes for allocating new temporary variables.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILGlobals.IsPossiblePrimaryAssemblyRef(Fantomas.FCS.AbstractIL.IL.ILAssemblyRef)">
<summary>
 Is the given assembly possibly a primary assembly?
 In practice, a primary assembly is an assembly that contains the System.Object type definition
 and has no referenced assemblies.
 However, we must consider assemblies that forward the System.Object type definition
 to be possible primary assemblies.
 Therefore, this will return true if the given assembly is the real primary assembly or an assembly that forwards
 the System.Object type definition.
 Assembly equivalency ignores the version here.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILGlobals">
<summary>
 A table of common references to items in primary assembly (System.Runtime or mscorlib).
 If a particular version of System.Runtime.dll has been loaded then you should
 reference items from it via an ILGlobals for that specific version built using mkILGlobals.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILModuleDef.NativeResources">
<summary>
 e.g. win86 resources, as the exact contents of a .res or .obj file. Must be unlinked manually.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILModuleDef">
<summary>
 One module in the &quot;current&quot; assembly, either a main-module or
 an auxiliary module.  The main module will have a manifest.

 An assembly is built by joining together a &quot;main&quot; module plus
 several auxiliary modules.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILNativeResource.Out">
<summary>
 Represents a native resource to be written in an output file
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILNativeResource.In">
<summary>
 Represents a native resource to be read from the PE file
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILAssemblyManifest.EntrypointElsewhere">
<summary>
 Records whether the entrypoint resides in another module.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILAssemblyManifest.ExportedTypes">
<summary>
 Records the types implemented by this assembly in auxiliary
 modules.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILAssemblyManifest.PublicKey">
<summary>
 This is the public key used to sign this
 assembly (the signature itself is stored elsewhere: see the
 binary format, and may not have been written if delay signing
 is used).  (member Name, member PublicKey) forms the full
 public name of the assembly.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILAssemblyManifest.AuxModuleHashAlgorithm">
<summary>
 This is the ID of the algorithm used for the hashes of auxiliary
 files in the assembly.   These hashes are stored in the
 &lt;c&gt;ILModuleRef.Hash&lt;/c&gt; fields of this assembly. These are not
 cryptographic hashes: they are simple file hashes. The algorithm
 is normally &lt;c&gt;0x00008004&lt;/c&gt; indicating the SHA1 hash algorithm.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILAssemblyManifest">
<summary>
 The main module of an assembly is a module plus some manifest information.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILResources">
<summary>
 Table of resources in a module.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILResource.GetBytes">
<summary>
 Read the bytes from a resource local to an assembly. Will fail for non-local resources.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILResource">
<summary>
 &quot;Manifest ILResources&quot; are chunks of resource data, being one of:
   - the data section of the current module (byte[] of resource given directly).
   - in an external file in this assembly (offset given in the ILResourceLocation field).
   - as a resources in another assembly of the same name.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILResourceLocation.Assembly">
<summary>
 Represents a manifest resource in a different assembly
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILResourceLocation.File">
<summary>
 Represents a manifest resource in an associated file
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILResourceLocation.Local">
<summary>
 Represents a manifest resource that can be read or written to a PE file
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILExportedTypeOrForwarder.Name">
<summary>
 [Namespace.]Name
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILExportedTypeOrForwarder">
<summary>
 these are only found in the ILExportedTypesAndForwarders table in the manifest
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILNestedExportedType">
<summary>
 &quot;Classes Elsewhere&quot; - classes in auxiliary modules.

 Manifests include declarations for all the classes in an
 assembly, regardless of which module they are in.

 The &quot;.class extern&quot; construct describes so-called exported types --
 these are public classes defined in the auxiliary modules of this assembly,
 i.e. modules other than the manifest-carrying module.

 For example, if you have a two-module
 assembly (A.DLL and B.DLL), and the manifest resides in the A.DLL,
 then in the manifest all the public classes declared in B.DLL should
 be defined as exported types, i.e., as &quot;.class extern&quot;. The public classes
 defined in A.DLL should not be defined as &quot;.class extern&quot; -- they are
 already available in the manifest-carrying module. The union of all
 public classes defined in the manifest-carrying module and all
 exported types defined there is the set of all classes exposed by
 this assembly. Thus, by analysing the metadata of the manifest-carrying
 module of an assembly, you can identify all the classes exposed by
 this assembly, and where to find them.

 Nested classes found in external modules should also be located in
 this table, suitably nested inside another &quot;ILExportedTypeOrForwarder&quot;
 definition.
 these are only found in the &quot;Nested&quot; field of ILExportedTypeOrForwarder objects
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILPreTypeDef.GetTypeDef">
<summary>
 Realise the actual full typedef
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILPreTypeDef">
<summary>
 Represents a prefix of information for ILTypeDef.

 The information is enough to perform name resolution for the F# compiler, probe attributes
 for ExtensionAttribute  etc.  This is key to the on-demand exploration of .NET metadata.
 This information has to be &quot;Goldilocks&quot; - not too much, not too little, just right.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeDef.IsComInterop">
<summary>
 Class or interface generated for COM interop.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeDef.HasSecurity">
<summary>
 Some classes are marked &quot;HasSecurity&quot; even if there are no permissions attached,
 e.g. if they use SuppressUnmanagedCodeSecurityAttribute
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILTypeDef.With(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Reflection.TypeAttributes},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILTypeDefLayout},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILType}},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodDefs},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILTypeDefs},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILFieldDefs},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodImplDefs},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILEventDefs},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILPropertyDefs},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILTypeDefAdditionalFlags},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILAttributesStored},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILSecurityDecls},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Fantomas.FCS.AbstractIL.IL.ILAttributesStored,System.Int32}}}})">
<summary>
 Functional update
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILTypeDef.#ctor(System.String,System.Reflection.TypeAttributes,Fantomas.FCS.AbstractIL.IL.ILTypeDefLayout,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Fantomas.FCS.AbstractIL.IL.ILAttributesStored,System.Int32}}},Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILMethodDefs,Fantomas.FCS.AbstractIL.IL.ILTypeDefs,Fantomas.FCS.AbstractIL.IL.ILFieldDefs,Fantomas.FCS.AbstractIL.IL.ILMethodImplDefs,Fantomas.FCS.AbstractIL.IL.ILEventDefs,Fantomas.FCS.AbstractIL.IL.ILPropertyDefs,Fantomas.FCS.AbstractIL.IL.ILTypeDefAdditionalFlags,Fantomas.FCS.AbstractIL.IL.ILSecurityDecls,Fantomas.FCS.AbstractIL.IL.ILAttributesStored)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILTypeDef.#ctor(System.String,System.Reflection.TypeAttributes,Fantomas.FCS.AbstractIL.IL.ILTypeDefLayout,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{Fantomas.FCS.AbstractIL.IL.ILAttributesStored,System.Int32}}},Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILMethodDefs,Fantomas.FCS.AbstractIL.IL.ILTypeDefs,Fantomas.FCS.AbstractIL.IL.ILFieldDefs,Fantomas.FCS.AbstractIL.IL.ILMethodImplDefs,Fantomas.FCS.AbstractIL.IL.ILEventDefs,Fantomas.FCS.AbstractIL.IL.ILPropertyDefs,Fantomas.FCS.AbstractIL.IL.ILTypeDefAdditionalFlags,Fantomas.FCS.AbstractIL.IL.ILSecurityDeclsStored,Fantomas.FCS.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value, using delayed reading via a metadata index, for ilread.fs
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILTypeDef">
<summary>
 Represents IL Type Definitions.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILTypeDefs.FindByName(System.String)">
<summary>
 Calls to &lt;c&gt;FindByName&lt;/c&gt; will result in all the ILPreTypeDefs being read.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILTypeDefs.ExistsByName(System.String)">
<summary>
 Calls to &lt;c&gt;ExistsByName&lt;/c&gt; will result in all the ILPreTypeDefs being read.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILTypeDefs.AsArrayOfPreTypeDefs">
<summary>
 Get some information about the type defs, but do not force the read of the type defs themselves.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILTypeDefs">
<summary>
 Tables of named type definitions.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILTypeDefKind">
<summary>
 A categorization of type definitions into &quot;kinds&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILTypeDefAccess">
<summary>
 Type Access.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILDefaultPInvokeEncoding">
<summary>
 Default Unicode encoding for P/Invoke  within a type.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILTypeInit">
<summary>
 Indicate the initialization semantics of a type.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILTypeDefLayout">
<summary>
 Type Layout information.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMethodImplDef">
<summary>
 Method Impls
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILPropertyDefs">
<summary>
 Table of properties in an IL type definition.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILPropertyDef.With(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Reflection.PropertyAttributes},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef}},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILThisConvention},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILType},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILFieldInit}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType}},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILAttributes})">
<summary>
 Functional update of the value
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILPropertyDef.#ctor(System.String,System.Reflection.PropertyAttributes,Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Fantomas.FCS.AbstractIL.IL.ILThisConvention,Fantomas.FCS.AbstractIL.IL.ILType,Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILFieldInit},Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILAttributes)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILPropertyDef.#ctor(System.String,System.Reflection.PropertyAttributes,Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Fantomas.FCS.AbstractIL.IL.ILThisConvention,Fantomas.FCS.AbstractIL.IL.ILType,Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILFieldInit},Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value, using delayed reading via a metadata index, for ilread.fs
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILPropertyDef">
<summary>
 Property definitions
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILEventDefs">
<summary>
 Table of those events in a type definition.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILEventDef.With(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILType}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Reflection.EventAttributes},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILMethodRef}},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILAttributes})">
<summary>
 Functional update of the value
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILEventDef.#ctor(Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILType},System.String,System.Reflection.EventAttributes,Fantomas.FCS.AbstractIL.IL.ILMethodRef,Fantomas.FCS.AbstractIL.IL.ILMethodRef,Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Fantomas.FCS.AbstractIL.IL.ILAttributes)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILEventDef.#ctor(Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILType},System.String,System.Reflection.EventAttributes,Fantomas.FCS.AbstractIL.IL.ILMethodRef,Fantomas.FCS.AbstractIL.IL.ILMethodRef,Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILMethodRef},Fantomas.FCS.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value, using delayed reading via a metadata index, for ilread.fs
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILEventDef">
<summary>
 Event definitions.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILFieldDefs">
<summary>
 Tables of fields.  Logically equivalent to a list of fields but the table is kept in
 a form to allow efficient looking up fields by name.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILFieldDef.Offset">
<summary>
 The explicit offset in bytes when explicit layout is used.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILFieldDef.With(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILType},Microsoft.FSharp.Core.FSharpOption{System.Reflection.FieldAttributes},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{System.Byte[]}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILFieldInit}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{System.Int32}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILNativeType}},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILAttributes})">
<summary>
 Functional update of the value
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILFieldDef.#ctor(System.String,Fantomas.FCS.AbstractIL.IL.ILType,System.Reflection.FieldAttributes,Microsoft.FSharp.Core.FSharpOption{System.Byte[]},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILFieldInit},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILNativeType},Fantomas.FCS.AbstractIL.IL.ILAttributes)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILFieldDef.#ctor(System.String,Fantomas.FCS.AbstractIL.IL.ILType,System.Reflection.FieldAttributes,Microsoft.FSharp.Core.FSharpOption{System.Byte[]},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILFieldInit},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILNativeType},Fantomas.FCS.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value using delayed reading via a metadata index
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILFieldDef">
<summary>
 Field definitions.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMethodDefs">
<summary>
 Tables of methods.  Logically equivalent to a list of methods but
 the table is kept in a form optimized for looking up methods by
 name and arity.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILMethodDef.IsVirtual">
<summary>
 Indicates an instance methods that is virtual or abstract or implements an interface slot.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILMethodDef.IsUnmanagedExport">
<summary>
 The method is exported to unmanaged code using COM interop.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILMethodDef.IsStatic">
<summary>
 Indicates a static method.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILMethodDef.IsNonVirtualInstance">
<summary>
 Indicates this is an instance methods that is not virtual.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILMethodDef.IsMustRun">
<summary>
 SafeHandle finalizer must be run.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILMethodDef.IsConstructor">
<summary>
 Indicates a .ctor method.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILMethodDef.IsClassInitializer">
<summary>
 Indicates a .cctor method.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILMethodDef.HasSecurity">
<summary>
 Some methods are marked &quot;HasSecurity&quot; even if there are no permissions attached, e.g. if they use SuppressUnmanagedCodeSecurityAttribute
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILMethodDef.With(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Reflection.MethodAttributes},Microsoft.FSharp.Core.FSharpOption{System.Reflection.MethodImplAttributes},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILCallingConv},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILParameter}},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILReturn},Microsoft.FSharp.Core.FSharpOption{Internal.Utilities.Library.InterruptibleLazy{Fantomas.FCS.AbstractIL.IL.MethodBody}},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILSecurityDecls},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef}},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILAttributes})">
<summary>
 Functional update of the value
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILMethodDef.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,Fantomas.FCS.AbstractIL.IL.ILCallingConv,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILParameter},Fantomas.FCS.AbstractIL.IL.ILReturn,Internal.Utilities.Library.InterruptibleLazy{Fantomas.FCS.AbstractIL.IL.MethodBody},System.Boolean,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef},Fantomas.FCS.AbstractIL.IL.ILSecurityDecls,Fantomas.FCS.AbstractIL.IL.ILAttributes)">
<summary>
 Functional creation of a value, immediate
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILMethodDef.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,Fantomas.FCS.AbstractIL.IL.ILCallingConv,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILParameter},Fantomas.FCS.AbstractIL.IL.ILReturn,Internal.Utilities.Library.InterruptibleLazy{Fantomas.FCS.AbstractIL.IL.MethodBody},System.Boolean,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef},Fantomas.FCS.AbstractIL.IL.ILSecurityDeclsStored,Fantomas.FCS.AbstractIL.IL.ILAttributesStored,System.Int32)">
<summary>
 Functional creation of a value, with delayed reading of some elements via a metadata index
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMethodDef">
<summary>
 IL Method definitions.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef.MetadataIndex">
<summary>
 Do not use this
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef.CustomAttrsStored">
<summary>
 Do not use this
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef.HasAllowsRefStruct">
<summary>
 Indicates the type parameter allows ref struct, i.e. an anti constraint.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef.HasDefaultConstructorConstraint">
<summary>
 Indicates the type argument must have a public nullary constructor.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef.HasNotNullableValueTypeConstraint">
<summary>
 Indicates the type argument must be a value type, but not Nullable.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef.HasReferenceTypeConstraint">
<summary>
 Indicates the type argument must be a reference type.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef.Variance">
<summary>
 Variance of type parameters, only applicable to generic parameters for generic interfaces and delegates.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef.Constraints">
<summary>
 At most one is the parent type, the others are interface types.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef">
<summary>
 Generic parameters.  Formal generic parameter declarations may include the bounds, if any, on the generic parameter.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILOverridesSpec">
<summary>
 Represents a reference to a method declaration in a superclass or interface.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.PInvokeCallingConvention">
<summary>
 PInvoke attributes.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILSecurityDeclsStored">
<summary>
 Represents the efficiency-oriented storage of ILSecurityDecls in another item.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILSecurityDecls">
<summary>
 Abstract type equivalent to ILSecurityDecl list - use helpers
 below to construct/destruct these.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILReturn">
<summary>
 Method return values.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILParameter.Marshal">
<summary>
 Marshalling map for parameters. COM Interop only.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILParameter">
<summary>
 Method parameters and return values.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILAttributesStored.Given">
<summary>
 Already computed
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILAttributesStored.Reader">
<summary>
 Computed by ilread.fs based on metadata index
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILAttributesStored">
<summary>
 Represents the efficiency-oriented storage of ILAttributes in another item.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILAttribute.Decoded">
<summary>
 Attribute with args in decoded form.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILAttribute.Encoded">
<summary>
 Attribute with args encoded to a binary blob according to ECMA-335 II.21 and II.23.3.
 &apos;decodeILAttribData&apos; is used to parse the byte[] blob to ILAttribElem&apos;s as best as possible.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILAttribute.Method">
<summary>
 Attribute instance constructor.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILAttribute.Elements">
<summary>
 Decoded arguments. May be empty in encoded attribute form.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILAttribute">
<summary>
 Custom attribute.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILAttributeNamedArg">
<summary>
 Named args: values and flags indicating if they are fields or properties.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILAttribElem.String">
<summary>
 Represents a custom attribute parameter of type &apos;string&apos;. These may be null, in which case they are encoded in a special
 way as indicated by Ecma-335 Partition II.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMemberAccess.Family">
<summary>
 Family - Indicates that the method is accessible only to members of this class and its derived classes. (protected)
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMemberAccess.FamilyOrAssembly">
<summary>
 FamilyOrAssembly - Indicates that the method is accessible to derived classes anywhere, as well as to any class _in the assembly_. (protected internal)
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMemberAccess.FamilyAndAssembly">
<summary>
 FamilyAndAssembly - Indicates that the method is accessible to members of this type and its derived types that are in _this assembly only_. (private protected)
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMemberAccess.Assembly">
<summary>
 Assembly - Indicates that the method is accessible to any class of this assembly. (internal)
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMemberAccess">
<summary>
 Member Access
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMethodBody">
<summary>
 IL method bodies
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILDebugImports">
<summary>
 Defines a set of opened namespace, type relevant to a code location.

 Emitted to the PortablePDB format.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILDebugImport.ImportNamespace">
<summary>
 Represents an &apos;open XYZ&apos; opening a namespace
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILDebugImport.ImportType">
<summary>
 Represents an &apos;open type XYZ&apos; opening a type
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILDebugImport">
<summary>
 Defines an opened namespace, type relevant to a code location.

 Emitted to the PortablePDB format. Note the format supports additional variations on
 imported things that are not yet emitted in F#.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILLocal">
<summary>
 Local variables
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILNativeType.Array">
<summary>
  optional idx of parameter giving size plus optional additive i.e. num elems
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILNativeType">
<summary>
 Native Types, for marshalling to the native C interface.
 These are taken directly from the ILASM syntax.
 Most of these are listed in the CLI ECMA-335 Spec (Partition II, 7.4).
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILFieldInit">
<summary>
 Field Init
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILLocalDebugMapping">
<summary>
 Indicates that a particular local variable has a particular source
 language name within a given set of ranges. This does not effect local
 variable numbering, which is global over the whole method.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILInstr">
<summary>
 The instruction set.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILCodeLabel">
<summary>
 ILCode labels.  In structured code each code label refers to a basic block somewhere in the code of the method.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILFieldSpec">
<summary>
 Field specs.  The data given for a ldfld, stfld etc. instruction.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILMethodSpec.Create(Fantomas.FCS.AbstractIL.IL.ILType,Fantomas.FCS.AbstractIL.IL.ILMethodRef,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType})">
<summary>
 Functional creation
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMethodSpec">
<summary>
 The information at the callsite of a method
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILFieldRef">
<summary>
 Formal identities of fields.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILMethodRef.Create(Fantomas.FCS.AbstractIL.IL.ILTypeRef,Fantomas.FCS.AbstractIL.IL.ILCallingConv,System.String,System.Int32,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Functional creation
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILMethodRef">
<summary>
 Formal identities of methods.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILGenericArgs">
<summary>
 Actual generic parameters are  always types.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILType.Modified.Item3">
<summary>
 The type being modified.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILType.Modified.Item2">
<summary>
 The class of the custom modifier.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILType.Modified.Item1">
<summary>
 True if modifier is &quot;required&quot;.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILType.Modified">
<summary>
 Custom modifiers.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILType.TypeVar">
<summary>
 Reference a generic arg.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILType.FunctionPointer">
<summary>
 ILCode pointers.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILType.Byref">
<summary>
 Managed pointers.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILType.Ptr">
<summary>
 Unmanaged pointers.  Nb. the type is used by tools and for binding only, not by the verifier.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILType.Boxed">
<summary>
 Reference types.  Also may be used for parents of members even if for members in value types.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILType.Value">
<summary>
 Unboxed types, including builtin types.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILType.Array">
<summary>
 Array types
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILType.Void">
<summary>
 Used only in return and pointer types.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeSpec.TypeRef">
<summary>
 Which type is being referred to?
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeSpec.Scope">
<summary>
 Where is the type, i.e. is it in this module, in another module in this assembly or in another assembly?
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeSpec.Name">
<summary>
 The name of the type. This also contains the namespace if Enclosing is empty.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeSpec.GenericArgs">
<summary>
 The type instantiation if the type is generic, otherwise empty
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeSpec.FullName">
<summary>
 The name of the type in the assembly using the &apos;.&apos; notation for nested types.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeSpec.Enclosing">
<summary>
 The list of enclosing type names for a nested type. If non-nil then the first of these also contains the namespace.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILTypeSpec.Create(Fantomas.FCS.AbstractIL.IL.ILTypeRef,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType})">
<summary>
 Create an ILTypeSpec.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILTypeSpec">
<summary>
 Type specs and types.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeRef.Scope">
<summary>
 Where is the type, i.e. is it in this module, in another module in this assembly or in another assembly?
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeRef.Name">
<summary>
 The name of the type. This also contains the namespace if Enclosing is empty.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeRef.FullName">
<summary>
 The name of the type in the assembly using the &apos;.&apos; notation for nested types.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeRef.Enclosing">
<summary>
 The list of enclosing type names for a nested type. If non-nil then the first of these also contains the namespace.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILTypeRef.BasicQualifiedName">
<summary>
 The name of the type in the assembly using the &apos;+&apos; notation for nested types.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.ILTypeRef.Create(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{System.String},System.String)">
<summary>
 Create a ILTypeRef.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILTypeRef">
<summary>
 Type refs, i.e. references to types in some .NET assembly
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILArrayShape.SingleDimensional">
<summary>
 Bounds for a single dimensional, zero based array
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILArrayBounds">
<summary>
 Lower-bound/size pairs
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILArrayBound">
<summary>
 Array shapes. For most purposes the rank is the only thing that matters.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILThisConvention.Static">
<summary>
 no &apos;this&apos; pointer is passed
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILThisConvention.InstanceExplicit">
<summary>
 accepts an explicit &apos;this&apos; pointer
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILThisConvention.Instance">
<summary>
 accepts an implicit &apos;this&apos; pointer
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILScopeRef.PrimaryAssembly">
<summary>
 A reference to a type in the primary assembly
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILScopeRef.Assembly">
<summary>
 A reference to a type in another assembly
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILScopeRef.Module">
<summary>
 A reference to a type in a module in the same assembly
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILScopeRef.Local">
<summary>
 A reference to the type in the current module
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILAssemblyRef.Retargetable">
<summary>
 CLI says this indicates if the assembly can be retargeted (at runtime) to be from a different publisher.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ILAssemblyRef.QualifiedName">
<summary>
 The fully qualified name of the assembly reference, e.g. mscorlib, Version=1.0.3705 etc.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILSourceDocument">
<summary>
 Debug info.  Values of type &quot;source&quot; can be attached at sequence
 points and some other locations.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.ILGuid">
<summary>
 Represents guids
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.PrimaryAssembly.IsPossiblePrimaryAssembly(System.String)">
<summary>
 Checks if an assembly resolution may represent a primary assembly that actually contains the
 definition of System.Object.  Note that the chosen target primary assembly may not actually be the one
 that contains the definition of System.Object - it is just the one we are choosing to emit for.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL.PrimaryAssembly">
<summary>
 Represents the target primary assembly
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.computeILRefs(Fantomas.FCS.AbstractIL.IL.ILGlobals,Fantomas.FCS.AbstractIL.IL.ILModuleDef)">
<summary>
 Find the full set of assemblies referenced by a module.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.parseILVersion(System.String)">
<summary>
 Get a version number from a CLR version string, e.g. 1.0.3705.0
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.sha1HashBytes(System.Byte[])">
<summary>
 Get a public key token from a public key.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.isILObjectTy(Fantomas.FCS.AbstractIL.IL.ILGlobals,Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Discriminating different important built-in types.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.stripILModifiedFromTy(Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Strips ILType.Modified from the ILType.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.ecmaPublicKey">
<summary>
 This is a &apos;vendor neutral&apos; way of referencing mscorlib.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.instILType(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Instantiate type variables that occur within types and other items.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.instILTypeAux(System.Int32,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Instantiate type variables that occur within types and other items.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.unscopeILType(Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Unscoping. Clears every scope information, use for looking up IL method references only.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.rescopeILFieldRef(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Fantomas.FCS.AbstractIL.IL.ILFieldRef)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.rescopeILMethodRef(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Fantomas.FCS.AbstractIL.IL.ILMethodRef)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.rescopeILType(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.rescopeILTypeSpec(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Fantomas.FCS.AbstractIL.IL.ILTypeSpec)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.rescopeILTypeRef(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Fantomas.FCS.AbstractIL.IL.ILTypeRef)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.rescopeILScopeRef(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Fantomas.FCS.AbstractIL.IL.ILScopeRef)">
<summary>
 Rescoping. The first argument indicates how to reference the original scope from
 the new scope.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkRefForNestedILTypeDef(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILTypeDef},Fantomas.FCS.AbstractIL.IL.ILTypeDef)">
<summary>
 Generate references to existing type definitions, method definitions
 etc.  Useful for generating references, e.g. to a  class we&apos;re processing
 Also used to reference type definitions that we&apos;ve generated.  [ILScopeRef]
 is normally ILScopeRef.Local, unless we&apos;ve generated the ILTypeDef in
 an auxiliary module or are generating multiple assemblies at
 once.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILSimpleModule(System.String,System.String,System.Boolean,System.Tuple{System.Int32,System.Int32},System.Boolean,Fantomas.FCS.AbstractIL.IL.ILTypeDefs,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},System.Int32,Fantomas.FCS.AbstractIL.IL.ILExportedTypesAndForwarders,System.String)">
<summary>
 Making modules.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILTypeDefsComputed(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Fantomas.FCS.AbstractIL.IL.ILPreTypeDef[]})">
<summary>
 Create table of types which is loaded/computed on-demand, and whose individual
 elements are also loaded/computed on-demand. Any call to tdefs.AsList will
 result in the laziness being forced.  Operations can examine the
 custom attributes and name of each type in order to decide whether
 to proceed with examining the other details of the type.

 Note that individual type definitions may contain further delays
 in their method, field and other tables.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILCustomAttrs(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILAttribute})">
<summary>
 Making tables of custom attributes, etc.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILTypeForGlobalFunctions(Fantomas.FCS.AbstractIL.IL.ILScopeRef)">
<summary>
 The toplevel &quot;class&quot; for a module or assembly.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkCtorMethSpecForDelegate(Fantomas.FCS.AbstractIL.IL.ILGlobals,Fantomas.FCS.AbstractIL.IL.ILType,System.Boolean)">
<summary>
 Given a delegate type definition which lies in a particular scope,
 make a reference to its constructor.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILStorageCtor(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILInstr},Fantomas.FCS.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,Fantomas.FCS.AbstractIL.IL.ILType}},Fantomas.FCS.AbstractIL.IL.ILMemberAccess,Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILDebugPoint},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILDebugImports})">
<summary>
 Derived functions for making some simple constructors
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.prependInstrsToClassCtor(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILInstr},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILDebugPoint},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILDebugImports},Fantomas.FCS.AbstractIL.IL.ILTypeDef)">
<summary>
 Injecting initialization code into a class.
 Add some code to the end of the .cctor for a type.  Create a .cctor
 if one doesn&apos;t exist already.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.appendInstrsToCode(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILInstr},Fantomas.FCS.AbstractIL.IL.ILCode)">
<summary>
 Injecting code into existing code blocks.  A branch will
 be added from the given instructions to the (unique) entry of
 the code, and the first instruction will be the new entry
 of the method.  The instructions should be non-branching.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkRawDataValueTypeDef(Fantomas.FCS.AbstractIL.IL.ILType,System.String,System.Int32,System.UInt16)">
<summary>
 Make a type definition for a value type used to point to raw data.
 These are useful when generating array initialization code
 according to the
   ldtoken    field valuetype &apos;&lt;PrivateImplementationDetails&gt;&apos;/&apos;$$struct0x6000127-1&apos; &apos;&lt;PrivateImplementationDetails&gt;&apos;::&apos;$$method0x6000127-1&apos;
   call       void System.Runtime.CompilerServices.RuntimeHelpers::InitializeArray(class System.Array,valuetype System.RuntimeFieldHandle)
 idiom.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILGenericClass(System.String,Fantomas.FCS.AbstractIL.IL.ILTypeDefAccess,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef},Fantomas.FCS.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILMethodDefs,Fantomas.FCS.AbstractIL.IL.ILFieldDefs,Fantomas.FCS.AbstractIL.IL.ILTypeDefs,Fantomas.FCS.AbstractIL.IL.ILPropertyDefs,Fantomas.FCS.AbstractIL.IL.ILEventDefs,Fantomas.FCS.AbstractIL.IL.ILAttributes,Fantomas.FCS.AbstractIL.IL.ILTypeInit)">
<summary>
 Make a type definition.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILInstanceField(System.String,Fantomas.FCS.AbstractIL.IL.ILType,Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILFieldInit},Fantomas.FCS.AbstractIL.IL.ILMemberAccess)">
<summary>
 Make field definitions.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILMethodBody(System.Boolean,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILLocal},System.Int32,Fantomas.FCS.AbstractIL.IL.ILCode,Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILDebugPoint},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.AbstractIL.IL.ILDebugImports})">
<summary>
 Make method definitions.
</summary>
</member>
<member name="P:Fantomas.FCS.AbstractIL.IL.mkILEmptyGenericParams">
<summary>
 Make a formal generic parameters.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILParam(Microsoft.FSharp.Core.FSharpOption{System.String},Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Derived functions for making return, parameter and local variable
 objects for use in method definitions.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkNormalCall(Fantomas.FCS.AbstractIL.IL.ILMethodSpec)">
<summary>
 Derived functions for making some common patterns of instructions.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.nonBranchingInstrsToCode(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILInstr})">
<summary>
 Make some code that is a straight line sequence of instructions.
 The function will add a &quot;return&quot; if the last instruction is not an exiting instruction.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.generateCodeLabel">
<summary>
 Making code.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILCustomAttribMethRef(Fantomas.FCS.AbstractIL.IL.ILMethodSpec,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILAttribElem},Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,Fantomas.FCS.AbstractIL.IL.ILType,System.Boolean,Fantomas.FCS.AbstractIL.IL.ILAttribElem}})">
<summary>
 Make custom attributes.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILFormalBoxedTy(Fantomas.FCS.AbstractIL.IL.ILTypeRef,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILGenericParameterDef})">
<summary>
 Make generalized versions of possibly-generic types, e.g. Given the ILTypeDef for List, return the type &quot;List&lt;T&gt;&quot;.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILFieldRef(Fantomas.FCS.AbstractIL.IL.ILTypeRef,System.String,Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Construct references to fields.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILCtorMethSpecForTy(Fantomas.FCS.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType})">
<summary>
 Construct references to constructors.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILNonGenericStaticMethSpecInTy(Fantomas.FCS.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Construct references to static, non-generic methods.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILStaticMethSpecInTy(Fantomas.FCS.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType})">
<summary>
 Construct references to static methods.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILNonGenericInstanceMethSpecInTy(Fantomas.FCS.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Construct references to instance methods.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILInstanceMethSpecInTy(Fantomas.FCS.AbstractIL.IL.ILType,System.String,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILType,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType})">
<summary>
 Construct references to instance methods.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILNonGenericMethSpecInTy(Fantomas.FCS.AbstractIL.IL.ILType,Fantomas.FCS.AbstractIL.IL.ILCallingConv,System.String,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Construct references to methods on a given type .
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILMethRef(Fantomas.FCS.AbstractIL.IL.ILTypeRef,Fantomas.FCS.AbstractIL.IL.ILCallingConv,System.String,System.Int32,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILType},Fantomas.FCS.AbstractIL.IL.ILType)">
<summary>
 Make method references and specs.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILTy(Fantomas.FCS.AbstractIL.IL.ILBoxity,Fantomas.FCS.AbstractIL.IL.ILTypeSpec)">
<summary>
 Make types.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILNonGenericTySpec(Fantomas.FCS.AbstractIL.IL.ILTypeRef)">
<summary>
 Make type specs.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILNestedTyRef(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{System.String},System.String)">
<summary>
 Make type refs.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkSimpleAssemblyRef(System.String)">
<summary>
 Generate simple references to assemblies and modules.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.decodeILAttribData(Fantomas.FCS.AbstractIL.IL.ILAttribute)">
<summary>
 Not all custom attribute data can be decoded without binding types.  In particular
 enums must be bound in order to discover the size of the underlying integer.
 The following assumes enums have size int32.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.destTypeDefsWithGlobalFunctionsFirst(Fantomas.FCS.AbstractIL.IL.ILGlobals,Fantomas.FCS.AbstractIL.IL.ILTypeDefs)">
<summary>
 When writing a binary the fake &quot;toplevel&quot; type definition (called &lt;Module&gt;)
 must come first. This function puts it first, and creates it in the returned
 list as an empty typedef if it doesn&apos;t already exist.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.mkILGlobals(Fantomas.FCS.AbstractIL.IL.ILScopeRef,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.AbstractIL.IL.ILAssemblyRef},Fantomas.FCS.AbstractIL.IL.ILScopeRef)">
<summary>
 Build the table of commonly used references given functions to find types in system assemblies

   primaryScopeRef is the primary assembly we are emitting
   equivPrimaryAssemblyRefs are ones regarded as equivalent
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.splitTypeNameRight(System.String)">
 <c>splitTypeNameRight</c> is like <c>splitILTypeName</c> except the
 namespace is kept as a whole string, rather than split at dots.
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.splitILTypeName(System.String)">
<summary>
 The &lt;c&gt;splitILTypeName&lt;/c&gt; utility helps you split a string representing
 a type name into the leading namespace elements (if any), the
 names of any nested types and the type name itself.  This function
 memoizes and interns the splitting of the namespace portion of
 the type name.
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.IL.resolveILMethodRef(Fantomas.FCS.AbstractIL.IL.ILTypeDef,Fantomas.FCS.AbstractIL.IL.ILMethodRef)">
<summary>
 Find the method definition corresponding to the given property or
 event operation. These are always in the same class as the property
 or event. This is useful especially if your code is not using the Ilbind
 API to bind references.
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.IL">
<summary>
 The &quot;unlinked&quot; view of .NET metadata and code.  Central to the Abstract IL library
</summary>
</member>
<member name="T:Fantomas.FCS.AbstractIL.AsciiConstants">
<summary>
 Various constants and utilities used when parsing the ILASM format for IL
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.AsciiParser.token_to_string(Fantomas.FCS.AbstractIL.AsciiParser.token)">
<summary>
 This function gets the name of a token as a string
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.AsciiParser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.AsciiParser.tokenTagToTokenId(System.Int32)">
<summary>
 This function maps integer indexes to symbolic token ids
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.AsciiParser.tagOfToken(Fantomas.FCS.AbstractIL.AsciiParser.token)">
<summary>
 This function maps tokens to integer indexes
</summary>
</member>
<member name="M:Fantomas.FCS.AbstractIL.AsciiLexer.token(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule token
</summary>
</member>
<member name="M:Fantomas.FCS.UnicodeLexing.StreamReaderAsLexbuf(System.Boolean,Fantomas.FCS.Features.LanguageVersion,Microsoft.FSharp.Core.FSharpOption{System.Boolean},System.IO.StreamReader)">
<summary>
 Will not dispose of the stream reader.
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.IXmlDocumentationInfoLoader.TryLoad(System.String)">
<summary>
 Try to get the XmlDocumentationInfo for a file
</summary>
</member>
<member name="T:Fantomas.FCS.Xml.IXmlDocumentationInfoLoader">
<summary>
 Represents a capability to access XmlDoc files
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDocumentationInfo.TryGetXmlDocBySig(System.String)">
<summary>
 Look up an item in the XmlDoc file
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDocumentationInfo.TryCreateFromFile(System.String)">
<summary>
 Create an XmlDocumentationInfo from a file
</summary>
</member>
<member name="T:Fantomas.FCS.Xml.XmlDocumentationInfo">
<summary>
 Represents access to an XmlDoc file
</summary>
</member>
<member name="P:Fantomas.FCS.Xml.PreXmlDoc.Range">
<summary>
 Get the overall range of the PreXmlDoc
</summary>
</member>
<member name="P:Fantomas.FCS.Xml.PreXmlDoc.IsEmpty">
<summary>
 Indicates if the PreXmlDoc is non-empty
</summary>
</member>
<member name="P:Fantomas.FCS.Xml.PreXmlDoc.Empty">
<summary>
 Get the empty PreXmlDoc
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.PreXmlDoc.ToXmlDoc(System.Boolean,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Process and check the PreXmlDoc, checking with respect to the given parameter names
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.PreXmlDoc.Merge(Fantomas.FCS.Xml.PreXmlDoc,Fantomas.FCS.Xml.PreXmlDoc)">
<summary>
 Merge two PreXmlDoc
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.PreXmlDoc.MarkAsInvalid">
<summary>
 Mark the PreXmlDoc as invalid
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.PreXmlDoc.Create(System.String[],Fantomas.FCS.Text.Range)">
<summary>
 Create a PreXmlDoc from a collection of unprocessed lines
</summary>
</member>
<member name="T:Fantomas.FCS.Xml.PreXmlDoc">
<summary>
 Represents the XmlDoc fragments as collected from the lexer during parsing
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDocCollector.LinesBefore(Fantomas.FCS.Text.Position)">
<summary>
 Get the documentation lines before the given point
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDocCollector.HasComments(Fantomas.FCS.Text.Position)">
<summary>
 Indicates it the given point has XmlDoc comments
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDocCollector.CheckInvalidXmlDocPositions">
<summary>
 Check if XmlDoc comments are at invalid positions, and if so report them
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDocCollector.AddXmlDocLine(System.String,Fantomas.FCS.Text.Range)">
<summary>
 Add a line of XmlDoc text
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDocCollector.AddGrabPointDelayed(Fantomas.FCS.Text.Position)">
<summary>
 Indicate the next XmlDoc will act as a point where prior XmlDoc are collected
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDocCollector.AddGrabPoint(Fantomas.FCS.Text.Position)">
<summary>
 Add a point where prior XmlDoc are collected
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDocCollector.#ctor">
<summary>
 Create a fresh XmlDocCollector
</summary>
</member>
<member name="T:Fantomas.FCS.Xml.XmlDocCollector">
<summary>
 Used to collect XML documentation during lexing and parsing.
</summary>
</member>
<member name="P:Fantomas.FCS.Xml.XmlDoc.UnprocessedLines">
<summary>
 Get the lines before insertion of implicit summary tags and encoding
</summary>
</member>
<member name="P:Fantomas.FCS.Xml.XmlDoc.Range">
<summary>
 Indicates the overall original source range of the XmlDoc
</summary>
</member>
<member name="P:Fantomas.FCS.Xml.XmlDoc.NonEmpty">
<summary>
 Indicates if the XmlDoc is non-empty
</summary>
</member>
<member name="P:Fantomas.FCS.Xml.XmlDoc.IsEmpty">
<summary>
 Indicates if the XmlDoc is empty
</summary>
</member>
<member name="P:Fantomas.FCS.Xml.XmlDoc.Empty">
<summary>
 Get the empty XmlDoc
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDoc.Merge(Fantomas.FCS.Xml.XmlDoc,Fantomas.FCS.Xml.XmlDoc)">
<summary>
 Merge two XML documentation
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDoc.GetXmlText">
<summary>
 Get the elaborated XML documentation as XML text
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDoc.GetElaboratedXmlLines">
<summary>
 Get the lines after insertion of implicit summary tags and encoding
</summary>
</member>
<member name="M:Fantomas.FCS.Xml.XmlDoc.Check(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Check the XML documentation
</summary>
</member>
<member name="T:Fantomas.FCS.Xml.XmlDoc">
<summary>
 Represents collected XmlDoc lines
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeConstraintWhereTyparNotSupportsNullTrivia.NotRange">
<summary>
 The syntax range of `not`
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeConstraintWhereTyparNotSupportsNullTrivia.ColonRange">
<summary>
 The syntax range of `:`
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTypeConstraintWhereTyparNotSupportsNullTrivia">
<summary>
 Represents additional information for SynTypeConstraint.WhereTyparNotSupportsNull
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynMeasureConstantTrivia">
<summary>
 Represents additional information for SynConst.Measure
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTyparDeclTrivia.AmpersandRanges">
<summary>
 The syntax ranges of the `&amp;` tokens
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTyparDeclTrivia">
<summary>
 Represents additional information for SynTyparDecl
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberSigMemberTrivia.GetSetKeywords">
<summary>
 The syntax range of &apos;get, set&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynMemberSigMemberTrivia">
<summary>
 Represents additional information for SynMemberSig.Member
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynBindingReturnInfoTrivia.ColonRange">
<summary>
 The syntax range of the `:` token
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynBindingReturnInfoTrivia">
<summary>
 Represents additional information for SynBindingReturnInfo
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeWithNullTrivia.BarRange">
<summary>
 The syntax range of the `|` token
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTypeWithNullTrivia">
<summary>
 Represents additional information for SynType.WithNull
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeOrTrivia.OrKeyword">
<summary>
 The syntax range of the `or` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTypeOrTrivia">
<summary>
 Represents additional information for SynType.Or
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynFieldTrivia.MutableKeyword">
<summary>
 The syntax range of the `mutable` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynFieldTrivia.LeadingKeyword">
<summary>
 Used leading keyword of SynField
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynFieldTrivia">
<summary>
 Represents additional information for SynField
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberDefnAbstractSlotTrivia.GetSetKeywords">
<summary>
 The syntax range of &apos;get, set&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynMemberDefnAbstractSlotTrivia">
<summary>
  Represents additional information for SynMemberDefn.AbstractSlot
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia.GetSetKeywords">
<summary>
 The syntax range of &apos;get, set&apos;
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia.LeadingKeyword">
<summary>
 Used leading keyword of AutoProperty
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia">
<summary>
 Represents additional information for SynMemberDefn.AutoProperty
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.GetSetKeywords">
<summary>
 Represents additional information for `get, set` syntax
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynArgPatsNamePatPairsTrivia.ParenRange">
<summary>
 The syntax range from the beginning of the `(` token till the end of the `)` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynArgPatsNamePatPairsTrivia">
<summary>
 Represents additional information for SynArgPats.NamePatPairs
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberDefnImplicitCtorTrivia.AsKeyword">
<summary>
 The syntax range of the `as` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynMemberDefnImplicitCtorTrivia">
<summary>
 Represents additional information for SynMemberDefn.ImplicitCtor
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberGetSetTrivia.SetKeyword">
<summary>
 The syntax range of the `set` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberGetSetTrivia.AndKeyword">
<summary>
 The syntax range of the `and` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberGetSetTrivia.GetKeyword">
<summary>
 The syntax range of the `get` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberGetSetTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMemberGetSetTrivia.InlineKeyword">
<summary>
 The syntax range of the `inline` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynMemberGetSetTrivia">
<summary>
 Represents additional information for SynMemberDefn.GetSetMember
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeFunTrivia.ArrowRange">
<summary>
 The syntax range of the `-&gt;` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTypeFunTrivia">
<summary>
 Represents additional information for SynType.Fun
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynValSigTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynValSigTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynValSigTrivia.InlineKeyword">
<summary>
 The syntax range of the `inline` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynValSigTrivia.LeadingKeyword">
<summary>
 Used leading keyword of SynValSig
 In most cases this will be `val`,
 but in case of `SynMemberDefn.AutoProperty` or `SynMemberDefn.AbstractSlot` it could be something else.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynValSigTrivia">
<summary>
 Represents additional information for SynValSig
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynModuleOrNamespaceSigTrivia.LeadingKeyword">
<summary>
 The syntax range of the `module` or `namespace` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynModuleOrNamespaceSigTrivia">
<summary>
 Represents additional information for SynModuleOrNamespaceSig
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynModuleOrNamespaceTrivia.LeadingKeyword">
<summary>
 The syntax range of the `module` or `namespace` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynModuleOrNamespaceTrivia">
<summary>
 Represents additional information for SynModuleOrNamespace
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynModuleOrNamespaceLeadingKeyword">
<summary>
 Represents the leading keyword in a SynModuleOrNamespace or SynModuleOrNamespaceSig
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynModuleSigDeclNestedModuleTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynModuleSigDeclNestedModuleTrivia.ModuleKeyword">
<summary>
 The syntax range of the `module` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynModuleSigDeclNestedModuleTrivia">
<summary>
 Represents additional information for SynModuleSigDecl.NestedModule
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynModuleDeclNestedModuleTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynModuleDeclNestedModuleTrivia.ModuleKeyword">
<summary>
 The syntax range of the `module` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynModuleDeclNestedModuleTrivia">
<summary>
 Represents additional information for SynModuleDecl.NestedModule
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprAndBangTrivia.InKeyword">
<summary>
 The syntax range of the `in` keyword.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprAndBangTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprAndBangTrivia.AndBangKeyword">
<summary>
 The syntax range of the `and!` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprAndBangTrivia">
<summary>
 Represents additional information for SynExprAndBang
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynBindingTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynBindingTrivia.InlineKeyword">
<summary>
 The syntax range of the `inline` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynBindingTrivia.LeadingKeyword">
<summary>
 Used leading keyword of SynBinding
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynBindingTrivia">
<summary>
 Represents additional information for SynBinding
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynLeadingKeyword">
<summary>
 Represents the leading keyword in a SynBinding or SynValSig
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeDefnSigTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeDefnSigTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeDefnSigTrivia.LeadingKeyword">
<summary>
 The syntax range of the `type` or `and` keyword.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTypeDefnSigTrivia">
<summary>
 Represents additional information for SynTypeDefnSig
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeDefnTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeDefnTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynTypeDefnTrivia.LeadingKeyword">
<summary>
 The syntax range of the `type` or `and` keyword.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTypeDefnTrivia">
<summary>
 Represents additional information for SynTypeDefn
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTypeDefnLeadingKeyword.Synthetic">
<summary>
 Produced during type checking, should not be used in actual parsed trees.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTypeDefnLeadingKeyword.StaticType">
<summary>
 Can happen in SynMemberDefn.NestedType or SynMemberSig.NestedType
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynTypeDefnLeadingKeyword">
<summary>
 Represents the leading keyword in a SynTypeDefn or SynTypeDefnSig
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynPatListConsTrivia.ColonColonRange">
<summary>
 The syntax range of the `::` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynPatListConsTrivia">
<summary>
 Represents additional information for SynPat.Cons
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynPatOrTrivia.BarRange">
<summary>
 The syntax range of the `|` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynPatOrTrivia">
<summary>
 Represents additional information for SynPat.Or
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynUnionCaseTrivia.BarRange">
<summary>
 The syntax range of the `|` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynUnionCaseTrivia">
<summary>
 Represents additional information for SynUnionCase
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynEnumCaseTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynEnumCaseTrivia.BarRange">
<summary>
 The syntax range of the `|` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynEnumCaseTrivia">
<summary>
 Represents additional information for
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMatchClauseTrivia.BarRange">
<summary>
 The syntax range of the `|` token.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynMatchClauseTrivia.ArrowRange">
<summary>
 The syntax range of the `-&gt;` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynMatchClauseTrivia">
<summary>
 Represents additional information for SynMatchClause
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprSequentialTrivia.SeparatorRange">
<summary>
 The syntax range of the `;` token.
 Could also be the `then` keyword.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprSequentialTrivia">
<summary>
 Represents additional information for SynExpr.Sequential
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprAnonRecdTrivia.OpeningBraceRange">
<summary>
 The syntax range of the `{|` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprAnonRecdTrivia">
<summary>
 Represents additional information for SynExpr.AnonRecd
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprMatchBangTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprMatchBangTrivia.MatchBangKeyword">
<summary>
 The syntax range of the `match!` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprMatchBangTrivia">
<summary>
 Represents additional information for SynExpr.MatchBang
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprMatchTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprMatchTrivia.MatchKeyword">
<summary>
 The syntax range of the `match` keyword
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprMatchTrivia">
<summary>
 Represents additional information for SynExpr.Match
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprLetOrUseBangTrivia.EqualsRange">
<summary>
 The syntax range of the `=` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprLetOrUseBangTrivia">
<summary>
 Represents additional information for SynExpr.LetOrUseBang
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprLetOrUseTrivia.InKeyword">
<summary>
 The syntax range of the `in` keyword.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprLetOrUseTrivia">
<summary>
 Represents additional information for SynExpr.LetOrUse
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprDotLambdaTrivia">
<summary>
 Represents additional information for SynExpr.DotLambda
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprLambdaTrivia.ArrowRange">
<summary>
 The syntax range of the `-&gt;` token.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprLambdaTrivia">
<summary>
 Represents additional information for SynExpr.Lambda
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprIfThenElseTrivia.IfToThenRange">
<summary>
 The syntax range from the beginning of the `if` keyword till the end of the `then` keyword.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprIfThenElseTrivia.ElseKeyword">
<summary>
 The syntax range of the `else` keyword.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprIfThenElseTrivia.ThenKeyword">
<summary>
 The syntax range of the `then` keyword.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprIfThenElseTrivia.IsElif">
<summary>
 Indicates if the `elif` keyword was used
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprIfThenElseTrivia.IfKeyword">
<summary>
 The syntax range of the `if` keyword.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprIfThenElseTrivia">
<summary>
 Represents additional information for SynExpr.IfThenElse
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprTryFinallyTrivia.FinallyKeyword">
<summary>
 The syntax range of the `finally` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprTryFinallyTrivia.TryKeyword">
<summary>
 The syntax range of the `try` keyword.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprTryFinallyTrivia">
<summary>
 Represents additional information for SynExpr.TryFinally
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprTryWithTrivia.WithToEndRange">
<summary>
 The syntax range from the beginning of the `with` keyword till the end of the TryWith expression.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprTryWithTrivia.WithKeyword">
<summary>
 The syntax range of the `with` keyword
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprTryWithTrivia.TryToWithRange">
<summary>
 The syntax range from the beginning of the `try` keyword till the end of the `with` keyword.
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.SynExprTryWithTrivia.TryKeyword">
<summary>
 The syntax range of the `try` keyword.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.SynExprTryWithTrivia">
<summary>
 Represents additional information for SynExpr.TryWith
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.ParsedSigFileInputTrivia.CodeComments">
<summary>
 Represent code comments found in the source file
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.ParsedSigFileInputTrivia.ConditionalDirectives">
<summary>
 Preprocessor directives of type #if, #else or #endif
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.ParsedSigFileInputTrivia">
<summary>
 Represents additional information for ParsedSigFileInputTrivia
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.ParsedImplFileInputTrivia.CodeComments">
<summary>
 Represent code comments found in the source file
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTrivia.ParsedImplFileInputTrivia.ConditionalDirectives">
<summary>
 Preprocessor directives of type #if, #else or #endif
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.ParsedImplFileInputTrivia">
<summary>
 Represents additional information for ParsedImplFileInput
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.IdentTrivia.HasParenthesis">
<summary>
 The ident had parenthesis
 Example: let (|Odd|Even|) = ...
 The active pattern ident will be &quot;|Odd|Even|&quot;, while originally there were parenthesis.
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.IdentTrivia.OriginalNotationWithParen">
<summary>
 The ident originally had a different notation and parenthesis
 Example: let (&gt;=&gt;) a b = ...
 The operator ident will be compiled into &quot;op_GreaterEqualsGreater&quot;, while the original notation was &quot;&gt;=&gt;&quot; and had parenthesis
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTrivia.IdentTrivia.OriginalNotation">
<summary>
 The ident originally had a different notation.
 Example: a + b
 The operator ident will be compiled into &quot;op_Addition&quot;, while the original notation was &quot;+&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedInput.SigFile">
<summary>
 A parsed signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedInput.ImplFile">
<summary>
 A parsed implementation file
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.ParsedInput.ScopedPragmas">
<summary>
 Gets the #nowarn and other scoped pragmas
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.ParsedInput.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.ParsedInput.QualifiedName">
<summary>
 Gets the qualified name used to help match signature and implementation files
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.ParsedInput.Identifiers">
<summary>
 Gets a set of all identifiers used in this parsed input. Only populated if captureIdentifiersWhenParsing option was used.
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.ParsedInput.FileName">
<summary>
 Gets the file name for the parsed input
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedInput">
<summary>
 Represents the syntax tree for a parsed implementation or signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedSigFileInput">
<summary>
 Represents the full syntax tree, file name and other parsing information for a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedImplFileInput">
<summary>
 Represents the full syntax tree, file name and other parsing information for an implementation file
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.QualifiedNameOfFile.Text">
<summary>
 The name of the file
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.QualifiedNameOfFile.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.QualifiedNameOfFile.Id">
<summary>
 The identifier for the name of the file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.QualifiedNameOfFile">
<summary>
 Represents a qualifying name for anonymous module specifications and implementations,
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ScopedPragma.WarningOff">
<summary>
 A pragma to turn a warning off
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ScopedPragma">
<summary>
 Represents a scoped pragma
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedSigFile">
<summary>
 Represents a parsed signature file made up of fragments
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedImplFile">
<summary>
 Represents a parsed implementation file made up of fragments
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedScriptInteraction">
<summary>
 Represents a parsed syntax tree for an F# Interactive interaction
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedSigFileFragment.NamespaceFragment">
<summary>
 A signature file namespace fragment
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedSigFileFragment.NamedModule">
<summary>
 A signature file which is a module, &apos;module N&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedSigFileFragment.AnonModule">
<summary>
 A signature file which is an anonymous module, e.g. the signature file for the final file in an application
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedSigFileFragment">
<summary>
 Represents the syntax tree for the contents of a parsed signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedImplFileFragment.NamespaceFragment">
<summary>
 An implementation file fragment which declares a namespace fragment
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedImplFileFragment.NamedModule">
<summary>
 An implementation file is a named module definition, &apos;module N&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedImplFileFragment.AnonModule">
<summary>
 An implementation file which is an anonymous module definition, e.g. a script
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedImplFileFragment">
<summary>
 Represents the syntax tree for the contents of a parsed implementation file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedHashDirective">
<summary>
 Represents a parsed hash directive
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.ParsedHashDirectiveArgument.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParsedHashDirectiveArgument">
<summary>
 Represents a parsed hash directive argument
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynModuleOrNamespaceSig.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleOrNamespaceSig">
<summary>
 Represents the definition of a module or namespace in a signature file
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynModuleOrNamespace.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleOrNamespace">
<summary>
 Represents the definition of a module or namespace
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleOrNamespaceKind.GlobalNamespace">
<summary>
 A namespace is declared &apos;global&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleOrNamespaceKind.DeclaredNamespace">
<summary>
 A namespace is explicitly declared
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleOrNamespaceKind.AnonModule">
<summary>
 A module is anonymously named, e.g. a script
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleOrNamespaceKind.NamedModule">
<summary>
 A module is explicitly named &apos;module N&apos;
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynModuleOrNamespaceKind.IsModule">
<summary>
 Indicates if this is a module definition
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleOrNamespaceKind">
<summary>
 Represents the kind of a module or namespace definition
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleSigDecl.NamespaceFragment">
<summary>
 A namespace fragment within a namespace in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleSigDecl.HashDirective">
<summary>
 A hash directive within a module or namespace in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleSigDecl.Open">
<summary>
 An &apos;open&apos; definition within a module or namespace in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleSigDecl.Exception">
<summary>
 An exception definition within a module or namespace in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleSigDecl.Types">
<summary>
 A set of one or more type definitions within a module or namespace in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleSigDecl.Val">
<summary>
 A &apos;val&apos; definition within a module or namespace in a signature file, corresponding
 to a &apos;let&apos; definition in the implementation
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleSigDecl.NestedModule">
<summary>
 A nested module definition within a module or namespace in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleSigDecl.ModuleAbbrev">
<summary>
 A module abbreviation definition within a module or namespace in a signature file
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynModuleSigDecl.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleSigDecl">
<summary>
 Represents a definition within a module or namespace in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExceptionSig">
<summary>
 Represents the right hand side of an exception definition in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynOpenDeclTarget.Type">
<summary>
 A &apos;open type&apos; declaration
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynOpenDeclTarget.ModuleOrNamespace">
<summary>
 A &apos;open&apos; declaration
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynOpenDeclTarget.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynOpenDeclTarget">
<summary>
 Represents the target of the open declaration
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.NamespaceFragment">
<summary>
 A namespace fragment within a module
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.HashDirective">
<summary>
 A hash directive within a module
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.Attributes">
<summary>
 An attribute definition within a module, for assembly and .NET module attributes
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.Open">
<summary>
 An &apos;open&apos; definition within a module
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.Exception">
<summary>
 An &apos;exception&apos; definition within a module
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.Types">
<summary>
 One or more &apos;type&apos; definitions within a module
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.Expr">
<summary>
 An &apos;expr&apos; within a module.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.Let">
<summary>
 A &apos;let&apos; definition within a module
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.NestedModule">
<summary>
 A nested module definition &apos;module X = ...&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl.ModuleAbbrev">
<summary>
 A module abbreviation definition &apos;module X = A.B.C&apos;
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynModuleDecl.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynModuleDecl">
<summary>
 Represents a definition within a module
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.AutoProperty">
<summary>
 An auto-property definition, F# syntax: &apos;member val X = expr&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.NestedType">
<summary>
 A nested type definition, a feature that is not implemented
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.ValField">
<summary>
 A &apos;val&apos; definition within a class
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.Inherit">
<summary>
 An &apos;inherit&apos; definition within a class
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.Interface">
<summary>
 An interface implementation definition within a class
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.AbstractSlot">
<summary>
 An abstract slot definition within a class or interface
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.LetBindings">
<summary>
 A &apos;let&apos; definition within a class
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.ImplicitInherit">
<summary>
 An implicit inherit definition, &apos;inherit &lt;typ&gt;(args...) as base&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.ImplicitCtor">
<summary>
 An implicit constructor definition
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.GetSetMember">
<summary>
 A &apos;member&apos; definition with get/set accessors within a type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.Member">
<summary>
 A &apos;member&apos; definition within a type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn.Open">
<summary>
 An &apos;open&apos; definition within a type
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMemberDefn.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberDefn">
<summary>
 Represents a definition element within a type definition, e.g. &apos;member ... &apos;
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynTypeDefn.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefn">
<summary>
 Represents a type or exception declaration &apos;type C = ... &apos; plus
 any additional member definitions for the type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnRepr.Exception">
<summary>
 An exception definition
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnRepr.Simple">
<summary>
 A simple type definition (record, union, abbreviation)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnRepr.ObjectModel">
<summary>
 An object model type definition (class or interface)
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynTypeDefnRepr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnRepr">
<summary>
 Represents the right hand side of a type or exception declaration &apos;type C = ... &apos; plus
 any additional member definitions for the type
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynExceptionDefn.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExceptionDefn">
<summary>
 Represents the right hand side of an exception declaration &apos;exception E = ... &apos; plus
 any member definitions for the exception
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynExceptionDefnRepr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExceptionDefnRepr">
<summary>
 Represents the right hand side of an exception declaration &apos;exception E = ... &apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynReturnInfo">
<summary>
 Represents the syntactic elements associated with the &quot;return&quot; of a function or method.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynValTyparDecls">
<summary>
 Represents the names and other metadata for the type parameters for a member or function
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynArgInfo">
<summary>
 Represents the argument names and other metadata for a parameter for a member or function
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynValInfo.SynValInfo">
<summary>
 SynValInfo(curriedArgInfos, returnInfo)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynValInfo">
<summary>
 The argument names and other metadata for a member or function
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynValSig">
<summary>
 Represents the syntax tree for a &apos;val&apos; definition in an abstract slot or a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynValSigAccess">
<summary>
 Represents one or two access modifier(s) in a property signature
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynComponentInfo.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynComponentInfo">
<summary>
 Represents the syntax tree associated with the name of a type definition or module
 in signature or implementation.

 This includes the name, attributes, type parameters, constraints, documentation and accessibility
 for a type definition or module. For modules, entries such as the type parameters are
 always empty.
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynField.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynField">
<summary>
 Represents the syntax tree for a field declaration in a record or class
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSig.SynTypeDefnSig">
<summary>
 The information for a type definition in a signature
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynTypeDefnSig.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSig">
<summary>
 Represents the syntax tree for a type definition in a signature
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSigRepr.Simple">
<summary>
 Indicates the right right-hand-side is a record, union or other simple type.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSigRepr.ObjectModel">
<summary>
 Indicates the right right-hand-side is a class, struct, interface or other object-model type
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynTypeDefnSigRepr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSigRepr">
<summary>
 Represents the syntax tree for the right-hand-side of a type definition in a signature.
 Note: in practice, using a discriminated union to make a distinction between
 &quot;simple&quot; types and &quot;object oriented&quot; types is not particularly useful.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynUnionCaseKind.FullType">
<summary>
 Full type spec given by &apos;UnionCase: ty1 * tyN -&gt; rty&apos;. Only used in FSharp.Core, otherwise a warning.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynUnionCaseKind.Fields">
<summary>
 Normal style declaration
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynUnionCaseKind">
<summary>
 Represents the syntax tree for the right-hand-side of union definition, excluding members,
 in either a signature or implementation.
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynUnionCase.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynUnionCase">
<summary>
 Represents the syntax tree for one case in a union definition.
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynEnumCase.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynEnumCase">
<summary>
 Represents the syntax tree for one case in an enum definition.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr.Exception">
<summary>
 An exception definition, &quot;exception E = ...&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr.None">
<summary>
 An abstract definition, &quot;type X&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr.TypeAbbrev">
<summary>
 A type abbreviation, &quot;type X = A.B.C&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr.LibraryOnlyILAssembly">
<summary>
 A type defined by using an IL assembly representation. Only used in FSharp.Core.

 F# syntax: &quot;type X = (# &quot;...&quot;#)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr.General">
<summary>
 An object oriented type definition. This is not a parse-tree form, but represents the core
 type representation which the type checker splits out from the &quot;ObjectModel&quot; cases of type definitions.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr.Record">
<summary>
 A record type definition, type X = { A: int; B: int }
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr.Enum">
<summary>
 An enum type definition, type X = A = 1 | B = 2
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr.Union">
<summary>
 A union type definition, type X = A | B
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnSimpleRepr">
<summary>
 Represents the syntax tree for the core of a simple type definition, in either signature
 or implementation.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeDefnKind">
<summary>
 Represents the kind of a type definition whether explicit or inferred
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberSig.NestedType">
<summary>
 A nested type definition in a signature file (an unimplemented feature)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberSig.ValField">
<summary>
 A &apos;val&apos; definition in a type in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberSig.Inherit">
<summary>
 An &apos;inherit&apos; definition in a type in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberSig.Interface">
<summary>
 An interface definition in a type in a signature file
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberSig.Member">
<summary>
 A member definition in a type in a signature file
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMemberSig.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberSig">
<summary>
 Represents the syntax tree for a member signature (used in signature files, abstract member declarations
 and member constraints)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberKind.PropertyGetSet">
<summary>
 An artificial member kind used prior to the point where a
 get/set property is split into two distinct members.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberKind.PropertySet">
<summary>
 The member kind is property setter
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberKind.PropertyGet">
<summary>
 The member kind is property getter
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberKind.Member">
<summary>
 The member kind is not yet determined
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberKind.Constructor">
<summary>
 The member is a object model constructor
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberKind.ClassConstructor">
<summary>
 The member is a class initializer
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberKind">
<summary>
 Note the member kind is actually computed partially by a syntax tree transformation in tc.fs
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMemberFlags.MemberKind">
<summary>
 The kind of the member
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMemberFlags.GetterOrSetterIsCompilerGenerated">
<summary>
 The member was generated by the compiler
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMemberFlags.IsFinal">
<summary>
 The member is &apos;final&apos;
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMemberFlags.IsOverrideOrExplicitImpl">
<summary>
 The member is an &apos;override&apos; or explicit interface implementation
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMemberFlags.IsDispatchSlot">
<summary>
 The member is a dispatch slot
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMemberFlags.IsInstance">
<summary>
 The member is an instance member (non-static)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMemberFlags">
<summary>
 Represents the flags for a &apos;member&apos; declaration
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynBindingReturnInfo">
<summary>
 Represents the return information in a binding for a &apos;let&apos; or &apos;member&apos; declaration
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynBinding">
<summary>
 Represents a binding for a &apos;let&apos; or &apos;member&apos; declaration
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynValData">
<summary>
 Represents extra information about the declaration of a value
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynAttributeList.Range">
<summary>
 The syntax range of the list of attributes
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynAttributeList.Attributes">
<summary>
 The list of attributes
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynAttributeList">
<summary>
 List of attributes enclosed in [&lt; ... &gt;].
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynAttribute.Range">
<summary>
 The syntax range of the attribute
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynAttribute.AppliesToGetterAndSetter">
<summary>
 Is this attribute being applied to a property getter or setter?
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynAttribute.Target">
<summary>
 Target specifier, e.g. &quot;assembly&quot;, &quot;module&quot;, etc.
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynAttribute.ArgExpr">
<summary>
 The argument of the attribute, perhaps a tuple
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynAttribute.TypeName">
<summary>
 The name of the type for the attribute
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynAttribute">
<summary>
 Represents an attribute
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMatchClause.RangeOfGuardAndRhs">
<summary>
 Gets the syntax range of part of this construct
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynMatchClause.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMatchClause">
<summary>
 Represents a clause in a &apos;match&apos; expression
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynInterfaceImpl">
<summary>
 Represents a set of bindings that implement an interface
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.FromParseError">
<summary>
 A pattern arising from a parse error
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.InstanceMember">
<summary>
 Used internally in the type checker
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.QuoteExpr">
<summary>
 &amp;lt;@ expr @&amp;gt;, used for active pattern arguments
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.IsInst">
<summary>
 A type test pattern &apos;:? type &apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.OptionalVal">
<summary>
 &apos;?id&apos; -- for optional argument names
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Null">
<summary>
 The &apos;null&apos; pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Record">
<summary>
 A record pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.ArrayOrList">
<summary>
 An array or a list as a pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Paren">
<summary>
 A parenthesized pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Tuple">
<summary>
 A tuple pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.LongIdent">
<summary>
 A long identifier pattern possibly with argument patterns
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.As">
<summary>
 A conjunctive pattern &apos;pat1 as pat2&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Ands">
<summary>
 A conjunctive pattern &apos;pat1 &amp; pat2&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.ListCons">
<summary>
 A conjunctive pattern &apos;pat1 :: pat2&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Or">
<summary>
 A disjunctive pattern &apos;pat1 | pat2&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Attrib">
<summary>
 An attributed pattern, used in argument or declaration position
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Typed">
<summary>
 A typed pattern &apos;pat : type&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Named">
<summary>
 A name pattern &apos;ident&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Wild">
<summary>
 A wildcard &apos;_&apos; in a pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat.Const">
<summary>
 A constant in a pattern
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynPat.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynPat">
<summary>
 Represents a syntax tree for an F# pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynArgPats">
<summary>
 Represents a syntax tree for arguments patterns
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynSimplePats">
<summary>
 Represents a simple set of variable bindings a, (a, b) or (a: Type, b: Type) at a lambda,
 function definition or other binding point, after the elimination of pattern matching
 from the construct, e.g. after changing a &quot;function pat1 -&gt; rule1 | ...&quot; to a
 &quot;fun v -&gt; match v with ...&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynStaticOptimizationConstraint.WhenTyparIsStruct">
<summary>
 A static optimization conditional that activates for a struct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynStaticOptimizationConstraint.WhenTyparTyconEqualsTycon">
<summary>
 A static optimization conditional that activates for a particular type instantiation
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynStaticOptimizationConstraint">
<summary>
 Represents a syntax tree for a static optimization constraint in the F# core library
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynSimplePatAlternativeIdInfo.Decided">
<summary>
 We have decided to use an alternative name in the pattern and related expression
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynSimplePatAlternativeIdInfo.Undecided">
<summary>
 We have not decided to use an alternative name in the pattern and related expression
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynSimplePatAlternativeIdInfo">
<summary>
 Represents the alternative identifier for a simple pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynSimplePat.Attrib">
<summary>
 An attributed simple pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynSimplePat.Typed">
<summary>
 A type annotated simple pattern
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynSimplePat.Id">
<summary>
 Indicates a simple pattern variable.

 altNameRefCell:
   Normally &apos;None&apos; except for some compiler-generated variables in desugaring pattern matching.
   Pattern processing sets this reference for hidden variable introduced
   by desugaring pattern matching in arguments. The info indicates an
   alternative (compiler generated) identifier to be used because the
   name of the identifier is already bound.

 isCompilerGenerated: true if a compiler generated name
 isThisVal: true if &apos;this&apos; variable in member
 isOptional: true if a &apos;?&apos; is in front of the name
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynSimplePat">
<summary>
 Represents a syntax tree for simple F# patterns
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynExprAndBang.Trivia">
<summary>
 Gets the trivia associated with this construct
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynExprAndBang.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Dynamic">
<summary>
 F# syntax: f?x
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.DebugPoint">
<summary>
 Debug points arising from computation expressions
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.InterpolatedString">
<summary>
 F# syntax: interpolated string, e.g. &quot;abc{x}&quot; or &quot;abc{x,3}&quot; or &quot;abc{x:N4}&quot;
 Note the string ranges include the quotes, verbatim markers, dollar sign and braces
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Fixed">
<summary>
 &apos;use x = fixed expr&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.DiscardAfterMissingQualificationAfterDot">
<summary>
 Inserted for error recovery when there is &quot;expr.&quot; and missing tokens or error recovery after the dot
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.FromParseError">
<summary>
 Inserted for error recovery
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.ArbitraryAfterError">
<summary>
 Inserted for error recovery
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.LibraryOnlyUnionCaseFieldSet">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.LibraryOnlyUnionCaseFieldGet">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.LibraryOnlyStaticOptimization">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.LibraryOnlyILAssembly">
<summary>
 Only used in FSharp.Core
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.WhileBang">
<summary>
 F# syntax: &apos;while! ... do ...&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.DoBang">
<summary>
 F# syntax: do! expr
 Computation expressions only
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.MatchBang">
<summary>
 F# syntax: match! expr with pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.LetOrUseBang">
<summary>
 F# syntax: let! pat = expr in expr
 F# syntax: use! pat = expr in expr
 F# syntax: let! pat = expr and! ... and! ... and! pat = expr in expr
 Computation expressions only
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.YieldOrReturnFrom">
<summary>
 F# syntax: yield! expr
 F# syntax: return! expr
 Computation expressions only
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.YieldOrReturn">
<summary>
 F# syntax: yield expr
 F# syntax: return expr
 Computation expressions only
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.SequentialOrImplicitYield">
<summary>
 Used internally during type checking for translating computation expressions.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.ImplicitZero">
<summary>
 Used in parser error recovery and internally during type checking for translating computation expressions.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.JoinIn">
<summary>
 F# syntax: ... in ...
 Computation expressions only, based on JOIN_IN token from lex filter
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.TraitCall">
<summary>
 F# syntax: ((type1 or ... or typeN): (member-dig) expr)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.AddressOf">
<summary>
 F# syntax: &amp;expr, &amp;&amp;expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Null">
<summary>
 F# syntax: null
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.InferredDowncast">
<summary>
 F# syntax: downcast expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.InferredUpcast">
<summary>
 F# syntax: upcast expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Downcast">
<summary>
 F# syntax: expr :?&gt; type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Upcast">
<summary>
 F# syntax: expr :&gt; type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.TypeTest">
<summary>
 F# syntax: expr :? type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.DotNamedIndexedPropertySet">
<summary>
 F# syntax: expr.Items (e1) &lt;- e2, rarely used named-property-setter notation, e.g. (stringExpr).Chars(3) &lt;- &apos;a&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.NamedIndexedPropertySet">
<summary>
 F# syntax: Type.Items(e1) &lt;- e2, rarely used named-property-setter notation, e.g. Foo.Bar.Chars(3) &lt;- &apos;a&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.DotIndexedSet">
<summary>
 F# syntax: expr.[expr, ..., expr] &lt;- expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.DotIndexedGet">
<summary>
 F# syntax: expr.[expr, ..., expr]
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Set">
<summary>
 F# syntax: expr &lt;- expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.DotSet">
<summary>
 F# syntax: expr.ident...ident &lt;- expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.DotLambda">
<summary>
 F# syntax: _.ident.ident
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.DotGet">
<summary>
 F# syntax: expr.ident.ident
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.LongIdentSet">
<summary>
 F# syntax: ident.ident...ident &lt;- expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.LongIdent">
<summary>
 F# syntax: ident.ident...ident

 isOptional: true if preceded by a &apos;?&apos; for an optional named parameter
 altNameRefCell: Normally &apos;None&apos; except for some compiler-generated
 variables in desugaring pattern matching. See SynSimplePat.Id
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Ident">
<summary>
 F# syntax: ident
 Optimized representation for SynExpr.LongIdent (false, [id], id.idRange)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Typar">
<summary>
 F# syntax: &apos;T (for &apos;T.ident).
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.IfThenElse">
<summary>
 F# syntax: if expr then expr
 F# syntax: if expr then expr else expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Sequential">
<summary>
 F# syntax: expr; expr

  isTrueSeq: false indicates &quot;let v = a in b; v&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Lazy">
<summary>
 F# syntax: lazy expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.TryFinally">
<summary>
 F# syntax: try expr finally expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.TryWith">
<summary>
 F# syntax: try expr with pat -&gt; expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.LetOrUse">
<summary>
 F# syntax: let pat = expr in expr
 F# syntax: let f pat1 .. patN = expr in expr
 F# syntax: let rec f pat1 .. patN = expr in expr
 F# syntax: use pat = expr in expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.TypeApp">
<summary>
 F# syntax: expr&lt;type1, ..., typeN&gt;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.App">
<summary>
 F# syntax: f x

 flag: indicates if the application is syntactically atomic, e.g. f.[1] is atomic, but &apos;f x&apos; is not
 isInfix is true for the first app of an infix operator, e.g. 1+2
 becomes App(App(+, 1), 2), where the inner node is marked isInfix
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Assert">
<summary>
 F# syntax: assert expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Do">
<summary>
 F# syntax: do expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Match">
<summary>
 F# syntax: match expr with pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.MatchLambda">
<summary>
 F# syntax: function pat1 -&gt; expr | ... | patN -&gt; exprN
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Lambda">
<summary>
 First bool indicates if lambda originates from a method. Patterns here are always &quot;simple&quot;
 Second bool indicates if this is a &quot;later&quot; part of an iterated sequence of lambdas
 parsedData keeps original parsed patterns and expression,
 prior to transforming to &quot;simple&quot; patterns and iterated lambdas

 F# syntax: fun pat -&gt; expr
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.ComputationExpr">
<summary>
 F# syntax: { expr }
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.IndexFromEnd">
<summary>
 F# syntax: ^expr, used for from-end-of-collection indexing and ^T.Operation
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.IndexRange">
<summary>
 F# syntax: expr..
 F# syntax: ..expr
 F# syntax: expr..expr
 F# syntax: *
 A two-element range indexer argument a..b, a.., ..b. Also used to represent
 a range in a list, array or sequence expression.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.ArrayOrListComputed">
<summary>
 F# syntax: [ expr ], [| expr |]
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.ForEach">
<summary>
 F# syntax: &apos;for ... in ... do ...&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.For">
<summary>
 F# syntax: &apos;for i = ... to ... do ...&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.While">
<summary>
 F# syntax: &apos;while ... do ...&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.ObjExpr">
<summary>
 F# syntax: { new ... with ... }
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.New">
<summary>
 F# syntax: new C(...)
 The flag is true if known to be &apos;family&apos; (&apos;protected&apos;) scope
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Record">
<summary>
 F# syntax: { f1=e1; ...; fn=en }
 inherit includes location of separator (for tooling)
 copyOpt contains range of the following WITH part (for tooling)
 every field includes range of separator after the field (for tooling)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.ArrayOrList">
<summary>
 F# syntax: [ e1; ...; en ], [| e1; ...; en |]
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.AnonRecd">
<summary>
 F# syntax: {| id1=e1; ...; idN=eN |}
 F# syntax: struct {| id1=e1; ...; idN=eN |}
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Tuple">
<summary>
 F# syntax: e1, ..., eN
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Typed">
<summary>
 F# syntax: expr: type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Const">
<summary>
 F# syntax: 1, 1.3, () etc.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Quote">
<summary>
 F# syntax: &lt;@ expr @&gt;, &lt;@@ expr @@&gt;

 Quote(operator, isRaw, quotedSynExpr, isFromQueryExpression, m)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr.Paren">
<summary>
 F# syntax: (expr)

 Parenthesized expressions. Kept in AST to distinguish A.M((x, y))
 from A.M(x, y), among other things.
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynExpr.RangeOfFirstPortion">
<summary>
 Attempt to get the range of the first token or initial portion only - this
 is ad-hoc, just a cheap way to improve a certain &apos;query custom operation&apos; error range
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynExpr.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynExpr.IsArbExprAndThusAlreadyReportedError">
<summary>
 Indicates if this expression arises from error recovery
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynExpr">
<summary>
 Represents a syntax tree for F# expressions
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.Intersection">
<summary>
 F# syntax: x: #I1 &amp; #I2
 F# syntax: x: &apos;t &amp; #I1 &amp; #I2
 Shorthand for x: &apos;t when &apos;t :&gt; I1 and &apos;t :&gt; I2
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.FromParseError">
<summary>
 A type arising from a parse error
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.Or">
<summary>
 F# syntax: ^a or ^b, used in trait calls
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.SignatureParameter">
<summary>
 F# syntax: a: b, used in signatures and type annotations
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.StaticConstantNamed">
<summary>
 F# syntax: ident=1 etc., used in static parameters to type providers
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.StaticConstantExpr">
<summary>
 F# syntax: const expr, used in static parameters to type providers
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.StaticConstantNull">
<summary>
 F# syntax: null, used in parameters to type providers
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.StaticConstant">
<summary>
 F# syntax: 1, &quot;abc&quot; etc, used in parameters to type providers
 For the dimensionless units i.e. 1, and static parameters to provided types
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.MeasurePower">
<summary>
 F# syntax: for units of measure e.g. m^3, kg^1/2
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.HashConstraint">
<summary>
 F# syntax: #type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.WithGlobalConstraints">
<summary>
 F# syntax: typ with constraints
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.Anon">
<summary>
 F# syntax: _
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.Var">
<summary>
 F# syntax: &apos;Var
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.Fun">
<summary>
 F# syntax: type -&gt; type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.Array">
<summary>
 F# syntax: type[]
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.AnonRecd">
<summary>
 F# syntax: {| id: type; ...; id: type |}
 F# syntax: struct {| id: type; ...; id: type |}
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.Tuple">
<summary>
 F# syntax: type * ... * type
 F# syntax: struct (type * ... * type)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.LongIdentApp">
<summary>
 F# syntax: type.A.B.C&lt;type, ..., type&gt;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.App">
<summary>
 F# syntax: type&lt;type, ..., type&gt; or type type or (type, ..., type) type
   isPostfix: indicates a postfix type application e.g. &quot;int list&quot; or &quot;(int, string) dict&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType.LongIdent">
<summary>
 F# syntax: A.B.C
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynType.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynType">
<summary>
 Represents a syntax tree for F# types
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTyparDecls">
<summary>
 List of type parameter declarations with optional type constraints,
 enclosed in `&lt; ... &gt;` (postfix) or `( ... )` (prefix), or a single prefix parameter.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereSelfConstrained">
<summary>
 F# syntax is SomeThing&lt;&apos;T&gt;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparIsDelegate">
<summary>
 F# syntax is &apos;typar: delegate&lt;&apos;Args, unit&gt;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparIsEnum">
<summary>
 F# syntax is &apos;typar: enum&lt;&apos;UnderlyingType&gt;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparSupportsMember">
<summary>
 F# syntax is ^T: (static member MemberName: ^T * int -&gt; ^T)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparSubtypeOfType">
<summary>
 F# syntax is &apos;typar :&gt; type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparDefaultsToType">
<summary>
 F# syntax is default ^T: type
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparIsEquatable">
<summary>
 F# syntax is &apos;typar: equality
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparIsComparable">
<summary>
 F# syntax is &apos;typar: comparison
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparNotSupportsNull">
<summary>
 F# syntax is &apos;typar : null
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparSupportsNull">
<summary>
 F# syntax is &apos;typar: null
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparIsUnmanaged">
<summary>
 F# syntax is &apos;typar: unmanaged
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparIsReferenceType">
<summary>
 F# syntax: is &apos;typar: not struct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint.WhereTyparIsValueType">
<summary>
 F# syntax: is &apos;typar: struct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypeConstraint">
<summary>
 The unchecked abstract syntax tree of F# type constraints
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTyparDecl">
<summary>
 Represents the explicit declaration of a type parameter
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynBindingKind.Do">
<summary>
 A &apos;do&apos; binding in a module. Must have type &apos;unit&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynBindingKind.Normal">
<summary>
 A normal &apos;let&apos; binding in a module
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynBindingKind.StandaloneExpression">
<summary>
 A standalone expression in a module
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynBindingKind">
<summary>
 The kind associated with a binding - &quot;let&quot;, &quot;do&quot; or a standalone expression
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ExprAtomicFlag">
<summary>
 Indicates if an expression is an atomic expression.

 An atomic expression has no whitespace unless enclosed in parentheses, e.g.
 1, &quot;3&quot;, ident, ident.[expr] and (expr). If an atomic expression has type T,
 then the largest expression ending at the same range as the atomic expression
 also has type T.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.RecordFieldName">
<summary>
 Represents a record field name plus a flag indicating if given record field name is syntactically
 correct and can be used in name resolution.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.BlockSeparator">
<summary>
 Represents the location of the separator block + optional position
 of the semicolon (used for tooling support)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SeqExprOnly.SeqExprOnly">
<summary>
 Indicates if a for loop is &apos;for x in e1 -&gt; e2&apos;, only valid in sequence expressions
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SeqExprOnly">
<summary>
 Indicates if a for loop is &apos;for x in e1 -&gt; e2&apos;, only valid in sequence expressions
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtBinding">
<summary>
 Represents whether a debug point should be present for a &apos;let&apos; binding,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtWhile">
<summary>
 Represents whether a debug point should be present for the &apos;while&apos; in a &apos;while...&apos; loop,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtInOrTo">
<summary>
 Represents whether a debug point should be present for the &apos;in&apos; or &apos;to&apos; of a &apos;for...&apos; loop,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtFor">
<summary>
 Represents whether a debug point should be present for the &apos;for&apos; in a &apos;for...&apos; loop,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtFinally">
<summary>
 Represents whether a debug point should be present for the &apos;finally&apos; in a &apos;try .. finally&apos;,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtWith">
<summary>
 Represents whether a debug point should be present for the &apos;with&apos; in a &apos;try .. with&apos;,
 that is whether the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtTry">
<summary>
 Represents whether a debug point should be present for a &apos;try&apos;, that is whether
 the construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtSequential">
<summary>
 Represents whether a debug point should be suppressed for either the
 first or second part of a sequential execution, that is whether the
 construct corresponds to a debug point in the original source.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtLeafExpr">
<summary>
 Represents a debug point at a leaf expression (e.g. an application or constant).
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.DebugPointAtTarget">
<summary>
 Represents whether a debug point should be present for the target
 of a decision tree, that is whether the construct corresponds to a debug
 point in the original source.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynAccess.Private">
<summary>
 A construct marked or assumed &apos;private&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynAccess.Internal">
<summary>
 A construct marked or assumed &apos;internal&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynAccess.Public">
<summary>
 A construct marked or assumed &apos;public&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynAccess">
<summary>
 Represents an accessibility modifier in F# syntax
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynRationalConst">
<summary>
 Represents an unchecked syntax tree of F# unit of measure exponents.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure.Paren">
<summary>
 A parenthesized measure
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure.Var">
<summary>
 A variable unit of measure
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure.Anon">
<summary>
 An anonymous (inferred) unit of measure
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure.One">
<summary>
 The &apos;1&apos; unit of measure
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure.Power">
<summary>
 A power of a unit of measure, e.g. &apos;kg ^ 2&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure.Divide">
<summary>
 A division of two units of measure, e.g. &apos;kg / m&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure.Seq">
<summary>
 A sequence of several units of measure, e.g. &apos;kg m m&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure.Product">
<summary>
 A product of two units of measure, e.g. &apos;kg * m&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure.Named">
<summary>
 A named unit of measure
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynMeasure">
<summary>
 Represents an unchecked syntax tree of F# unit of measure annotations.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.SourceIdentifier">
<summary>
 Source Line, File, and Path Identifiers
 Containing both the original value as the evaluated value.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Measure">
<summary>
 Old comment: &quot;we never iterate, so the const here is not another SynConst.Measure&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.UInt16s">
<summary>
 Used internally in the typechecker once an array of unit16 constants
 is detected, to allow more efficient processing of large arrays of uint16 constants.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Bytes">
<summary>
 F# syntax: verbatim or regular byte string, e.g. &quot;abc&quot;B.

 Also used internally in the typechecker once an array of unit16 constants
 is detected, to allow more efficient processing of large arrays of uint16 constants.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.String">
<summary>
 F# syntax: verbatim or regular string, e.g. &quot;abc&quot;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.UserNum">
<summary>
 UserNum(value, suffix)

 F# syntax: 1Q, 1Z, 1R, 1N, 1G
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Decimal">
<summary>
 F# syntax: 23.4M
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Char">
<summary>
 F# syntax: &apos;a&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Double">
<summary>
 F# syntax: 1.30, 1.40e10 etc.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Single">
<summary>
 F# syntax: 1.30f, 1.40e10f etc.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.UIntPtr">
<summary>
 F# syntax: 13un
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.IntPtr">
<summary>
 F# syntax: 13n
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.UInt64">
<summary>
 F# syntax: 13UL
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Int64">
<summary>
 F# syntax: 13L
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.UInt32">
<summary>
 F# syntax: 13u, 0x4000u, 0o0777u
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Int32">
<summary>
 F# syntax: 13, 0x4000, 0o0777
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.UInt16">
<summary>
 F# syntax: 13us, 0x4000us, 0o0777us, 0b0111101us
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Int16">
<summary>
 F# syntax: 13s, 0x4000s, 0o0777s, 0b0111101s
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Byte">
<summary>
 F# syntax: 13uy, 0x40uy, 0oFFuy, 0b0111101uy
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.SByte">
<summary>
 F# syntax: 13y, 0xFFy, 0o077y, 0b0111101y
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Bool">
<summary>
 F# syntax: true, false
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst.Unit">
<summary>
 F# syntax: ()
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.SynConst.Range(Fantomas.FCS.Text.Range)">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynConst">
<summary>
 The unchecked abstract syntax tree of constants in F# types and expressions.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynByteStringKind">
<summary>
 Indicate if the byte string had a special format
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynStringKind">
<summary>
 Indicate if the string had a special format
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynTypar.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynTypar">
<summary>
 Represents a syntactic type parameter
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.TyparStaticReq.HeadType">
<summary>
 The construct is a statically inferred type inference variable &apos;^T&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.TyparStaticReq.None">
<summary>
 The construct is a normal type inference variable
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.TyparStaticReq">
<summary>
 Represents whether a type parameter has a static requirement or not (^T or &apos;T)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParserDetail.ErrorRecovery">
<summary>
 The construct arises from error recovery
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParserDetail.Ok">
<summary>
 The construct arises normally
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.ParserDetail">
<summary>
 Indicates if the construct arises from error recovery
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynLongIdent.Trivia">
<summary>
 Get the trivia of the idents
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynLongIdent.ThereIsAnExtraDotAtTheEnd">
<summary>
 Indicates if the construct ends in &apos;.&apos; due to error recovery
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynLongIdent.RangeWithoutAnyExtraDot">
<summary>
 Gets the syntax range for part of this construct
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynLongIdent.Range">
<summary>
 Gets the syntax range of this construct
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynLongIdent.LongIdent">
<summary>
 Get the long ident for this construct
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynLongIdent.IdentsWithTrivia">
<summary>
 Get the idents with potential trivia attached
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.SynLongIdent.Dots">
<summary>
 Get the dot ranges
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynLongIdent">
<summary>
 Represents a long identifier with possible &apos;.&apos; at end.

 Typically dotRanges.Length = lid.Length-1, but they may be same if (incomplete) code ends in a dot, e.g. &quot;Foo.Bar.&quot;
 The dots mostly matter for parsing, and are typically ignored by the typechecker, but
 if dotRanges.Length = lid.Length, then the parser must have reported an error, so the typechecker is allowed
 more freedom about typechecking these expressions.
 LongIdent can be empty list - it is used to denote that name of some AST element is absent (i.e. empty type name in inherit)
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.LongIdent">
<summary>
 Represents a long identifier e.g. &apos;A.B.C&apos;
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.SynIdent">
<summary>
 Represents an identifier with potentially additional trivia information.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.Ident">
<summary>
 Represents an identifier in F# code
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.PrettyNaming.keywordsWithDescription">
<summary>
 Keywords paired with their descriptions. Used in completion and quick info.
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.PrettyNaming.suffixForTupleElementAssignmentTarget">
<summary>
 Indicates a ValRef generated to facilitate tuple eliminations
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.PrettyNaming.suffixForVariablesThatMayNotBeEliminated">
<summary>
 Mark some variables (the ones we introduce via abstractBigTargets) as don&apos;t-eliminate
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.PrettyNaming.FsiDynamicModulePrefix">
<summary>
 The prefix of the names used for the fake namespace path added to all dynamic code entries in FSI.EXE
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.PrettyNaming.mkExceptionFieldName">
<summary>
 Reuses generated exception field name objects for common field numbers
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.PrettyNaming.mkUnionCaseFieldName">
<summary>
 Reuses generated union case field name objects for common field numbers
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.ComputeMangledNameWithoutDefaultArgValues``1(System.String,``0[],System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}[])">
<summary>
 Mangle the static parameters for a provided type or method
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.MangleProvidedTypeName(System.String,System.Tuple{System.String,System.String}[])">
<summary>
 Mangle the static parameters for a provided type or method
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.ChopPropertyName(System.String)">
<summary>
 Try to chop &quot;get_&quot; or &quot;set_&quot; from a string.
 If the string does not start with &quot;get_&quot; or &quot;set_&quot;, this function raises an exception.
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.TryChopPropertyName(System.String)">
<summary>
 Try to chop &quot;get_&quot; or &quot;set_&quot; from a string
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.IsLongIdentifierPartCharacter(System.Char)">
<summary>
 Is this character a part of a long identifier?
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.IsIdentifierPartCharacter(System.Char)">
<summary>
 The characters that are allowed to be in an identifier.
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.IsIdentifierFirstCharacter(System.Char)">
<summary>
 The characters that are allowed to be the first character of an identifier.
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.ConvertValLogicalNameToDisplayLayout(System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.String,Fantomas.FCS.Text.Layout},System.String)">
<summary>
 Like ConvertValLogicalNameToDisplayName but produces a tagged layout
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.ConvertLogicalNameToDisplayLayout(Microsoft.FSharp.Core.FSharpFunc{System.String,Fantomas.FCS.Text.Layout},System.String)">
<summary>
 Like ConvertLogicalNameToDisplayName but produces a tagged layout
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.ConvertValLogicalNameToDisplayName(System.Boolean,System.String)">
<summary>
 Take a core display name for a value (e.g. op_Addition or PropertyName) and convert it to display text
     Foo                   --&gt; Foo
     +                     --&gt; ``+``
     op_Addition           --&gt; (+)
     op_Multiply           --&gt; ( * )
     op_DereferencePercent --&gt; (!%)
     A-B                   --&gt; ``A-B``
     |A|_|                 --&gt; (|A|_|)
     let                   --&gt; ``let``
     type                  --&gt; ``type``
     params                --&gt; ``params``
     base                  --&gt; base
     or                    --&gt; or
     mod                   --&gt; mod
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.ConvertValLogicalNameToDisplayNameCore(System.String)">
<summary>
 Converts the logical name for and operator back into the core of a display name. For example:
     Foo                   --&gt; Foo
     +                     --&gt; +
     op_Addition           --&gt; +
     op_DereferencePercent --&gt; !%
     A-B                   --&gt; A-B
     |A|_|                 --&gt; |A|_|
     base                  --&gt; base        regardless of IsBaseVal
 Used on names of all kinds

 TODO: We should assess uses of this function.

 In any cases it is used it probably indicates that text is being
 generated which:
    1. does not contain double-backticks for non-identifiers
    2. does not put parentheses around operators or active pattern names

 If the text is immediately in quotes, this is generally ok, e.g.

         error FS0038: &apos;+&apos; is bound twice in this pattern
         error FS0038: &apos;|A|_|&apos; is bound twice in this pattern
         error FS0038: &apos;a a&apos; is bound twice in this pattern

 If not, the it is likely this should be replaced by ConvertValLogicalNameToDisplayName.
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.ConvertLogicalNameToDisplayName(System.String)">
<summary>
 Take a core display name (e.g. &quot;List&quot; or &quot;Strange module name&quot;) and convert it to display text
 by adding backticks if necessary.
     Foo                   --&gt; Foo
     +                     --&gt; ``+``
     A-B                   --&gt; ``A-B``
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.CompileOpName(System.String)">
<summary>
 Converts the core of an operator name into a logical name. For example,
    +  --&gt; op_Addition
    !%  --&gt; op_DereferencePercent
 Only used on actual operator names
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.IsLogicalOpName(System.String)">
<summary>
 Is the name a logical operator name, including unary, binary and ternary operators
    op_UnaryPlus         - yes
    op_Addition          - yes
    op_Range             - yes (?)
    op_RangeStep         - yes (?)
    op_DynamicAssignment - yes
    op_Quack             - no
    +                    - no
    ABC                  - no
    ABC DEF              - no
    base                 - no
    |A|_|                - no
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.NormalizeIdentifierBackticks(System.String)">
<summary>
 Adds double backticks if necessary to make a valid identifier, e.g.
     op_Addition  --&gt;  op_Addition
     +            --&gt;  ``+``    (this is not op_Addition)
     |&gt;&gt;          --&gt;  ``|&gt;&gt;``  (this is not an op_)
     A-B          --&gt;  ``A-B``
     AB           --&gt;  AB
     |A|_|        --&gt;  |A|_|    this is an active pattern name, needs parens not backticks
 Removes double backticks if not necessary to make a valid identifier, e.g.
     ``A``        --&gt; A
     ``A-B``      --&gt; ``A-B``
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.IsActivePatternName(System.String)">
<summary>
 Determines if the specified name is a valid name for an active pattern.
     |A|_|        --&gt; true
     |A|B|        --&gt; true
     |A|          --&gt; true
     |            --&gt; false
     ||           --&gt; false
     op_Addition  --&gt; false

 TBD: needs unit testing
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.IsIdentifierName(System.String)">
<summary>
 Is the name a valid F# identifier, primarily used internally in PrettyNaming.fs for determining if an
 identifier needs backticks.

 In general do not use this routine. It is only used in one quick fix, for determining if it is valid
 to add &quot;_&quot; in front of an identifier.

     A            --&gt; true
     A&apos;           --&gt; true
     _A           --&gt; true
     A0           --&gt; true
     |A|B|        --&gt; false
     op_Addition  --&gt; true
     +            --&gt; false
     let          --&gt; false
     base         --&gt; false

 TBD: needs unit testing
</summary>
</member>
<member name="M:Fantomas.FCS.Syntax.PrettyNaming.IsOperatorDisplayName(System.String)">
<summary>
 Returns `true` if given string is an operator display name, e.g.
    ( |&gt;&gt; )
    |&gt;&gt;
    ..
</summary>
</member>
<member name="P:Fantomas.FCS.Syntax.PrettyNaming.opNamePrefix">
<summary>
 Prefix for compiled (mangled) operator names.
</summary>
</member>
<member name="T:Fantomas.FCS.Syntax.PrettyNaming">
<summary>
 Some general F# utilities for mangling / unmangling / manipulating names.
 Anything to do with special names of identifiers and other lexical rules
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.addEmptyMatchClause(Fantomas.FCS.Text.Range,Fantomas.FCS.Text.Range,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Syntax.SynMatchClause})">
<summary>
 Adds SynPat.Or pattern for unfinished empty clause above
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.|Get_OrSet_Ident|_|(Fantomas.FCS.Syntax.Ident)">
<summary>
 Generated get_XYZ or set_XYZ ident text
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.|SynPipeRight3|_|(Fantomas.FCS.Syntax.SynExpr)">
<summary>
 &apos;e1 |||&gt; e2&apos;
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.|SynPipeRight2|_|(Fantomas.FCS.Syntax.SynExpr)">
<summary>
 &apos;e1 ||&gt; e2&apos;
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.|SynPipeRight|_|(Fantomas.FCS.Syntax.SynExpr)">
<summary>
 &apos;e1 |&gt; e2&apos;
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.|SynOrElse|_|(Fantomas.FCS.Syntax.SynExpr)">
<summary>
 &apos;e1 || e2&apos;
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.|SynAndAlso|_|(Fantomas.FCS.Syntax.SynExpr)">
<summary>
 &apos;e1 &amp;&amp; e2&apos;
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.PushCurriedPatternsToExpr(Fantomas.FCS.SyntaxTreeOps.SynArgNameGenerator,Fantomas.FCS.Text.Range,System.Boolean,Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Syntax.SynPat},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.Text.Range},Fantomas.FCS.Syntax.SynExpr)">
<summary>
 &quot;fun (UnionCase x) (UnionCase y) -&gt; body&quot;
       ==&gt;
   &quot;fun tmp1 tmp2 -&gt;
        let (UnionCase x) = tmp1 in
        let (UnionCase y) = tmp2 in
        body&quot;
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SimplePatOfPat(Fantomas.FCS.SyntaxTreeOps.SynArgNameGenerator,Fantomas.FCS.Syntax.SynPat)">
<summary>
 Push non-simple parts of a patten match over onto the r.h.s. of a lambda.
 Return a simple pattern and a function to build a match on the r.h.s. if the pattern is complex
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.|SynPatForNullaryArgs|_|(Fantomas.FCS.Syntax.SynPat)">
<summary>
 Recognize the &apos;()&apos; in &apos;new()&apos;
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.IsControlFlowExpression(Fantomas.FCS.Syntax.SynExpr)">
<summary>
 This affects placement of debug points
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.|LongOrSingleIdent|_|(Fantomas.FCS.Syntax.SynExpr)">
<summary>
 Match a long identifier, including the case for single identifiers which gets a more optimized node in the syntax tree.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.InferSynValData(Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.Syntax.SynMemberFlags},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.Syntax.SynPat},Microsoft.FSharp.Core.FSharpOption{Fantomas.FCS.Syntax.SynReturnInfo},Fantomas.FCS.Syntax.SynExpr)">
<summary>
 Infer the syntactic information for a &apos;let&apos; or &apos;member&apos; definition, based on the argument pattern,
 any declared return information (e.g. .NET attributes on the return element), and the r.h.s. expression
 in the case of &apos;let&apos; definitions.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.AdjustMemberArgs``1(Fantomas.FCS.Syntax.SynMemberKind,Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
<summary>
 Transform a property declared using &apos;[static] member P = expr&apos; to a method taking a &quot;unit&quot; argument.
 This is similar to IncorporateEmptyTupledArgForPropertyGetter, but applies to member definitions
 rather than member signatures.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.AdjustArgsForUnitElimination(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Syntax.SynArgInfo}})">
<summary>
 Make sure only a solitary unit argument has unit elimination
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.InferSynArgInfoFromPat(Fantomas.FCS.Syntax.SynPat)">
<summary>
 Infer the syntactic argument info for one or more arguments a pattern.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.InferSynArgInfoFromSimplePats(Fantomas.FCS.Syntax.SynSimplePats)">
<summary>
 Infer the syntactic argument info for one or more arguments one or more simple patterns.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.InferSynArgInfoFromSimplePat(Microsoft.FSharp.Collections.FSharpList{Fantomas.FCS.Syntax.SynAttributeList},Fantomas.FCS.Syntax.SynSimplePat)">
<summary>
 Infer the syntactic argument info for a single argument from a simple pattern.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.AttribsOfArgData(Fantomas.FCS.Syntax.SynArgInfo)">
<summary>
 Get the argument attributes from the syntactic information for an argument.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.AritiesOfArgs(Fantomas.FCS.Syntax.SynValInfo)">
<summary>
 Get the argument counts for each curried argument group. Used in some adhoc places in tc.fs.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.IncorporateSetterArg(Fantomas.FCS.Syntax.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the value argument for a property setter. This is
 used for the implicit value argument in property setter signature specifications.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.IncorporateSelfArg(Fantomas.FCS.Syntax.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the &apos;this&apos; argument. This is
 used for the implicit &apos;this&apos; argument in member signature specifications.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.IncorporateEmptyTupledArgForPropertyGetter(Fantomas.FCS.Syntax.SynValInfo)">
<summary>
 Add a parameter entry to the syntactic value information to represent the &apos;()&apos; argument to a property getter. This is
 used for the implicit &apos;()&apos; argument in property getter signature specifications.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.HasOptionalArgs(Fantomas.FCS.Syntax.SynValInfo)">
<summary>
 Check if there are any optional arguments in the syntactic argument information. Used when adjusting the
 types of optional arguments for function and member signatures.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.IsOptionalArg(Fantomas.FCS.Syntax.SynArgInfo)">
<summary>
 Check if one particular argument is an optional argument. Used when adjusting the
 types of optional arguments for function and member signatures.
</summary>
</member>
<member name="M:Fantomas.FCS.SyntaxTreeOps.SynInfo.HasNoArgs(Fantomas.FCS.Syntax.SynValInfo)">
<summary>
 Determine if a syntactic information represents a member without arguments (which is implicitly a property getter)
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTreeOps.SynInfo.selfMetadata">
<summary>
 The &apos;argument&apos; information for the &apos;this&apos;/&apos;self&apos; parameter in the cases where it is not given explicitly
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTreeOps.SynInfo.unnamedRetVal">
<summary>
 The &apos;argument&apos; information for a return value where no attributes are given for the return value (the normal case)
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTreeOps.SynInfo.unitArgData">
<summary>
 The argument information for a &apos;()&apos; argument
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTreeOps.SynInfo.unnamedTopArg">
<summary>
 The argument information for a curried argument without a name
</summary>
</member>
<member name="P:Fantomas.FCS.SyntaxTreeOps.SynInfo.unnamedTopArg1">
<summary>
 The argument information for an argument without a name
</summary>
</member>
<member name="T:Fantomas.FCS.SyntaxTreeOps.SynInfo">
<summary>
 Operations related to the syntactic analysis of arguments of value, function and member definitions and signatures.
</summary>
</member>
<member name="M:Fantomas.FCS.ParseHelpers.adjustHatPrefixToTyparLookup(Fantomas.FCS.Text.Range,Fantomas.FCS.Syntax.SynExpr)">
<summary>
 Incorporate a &apos;^&apos; for an qualified access to a generic type parameter
</summary>
</member>
<member name="T:Fantomas.FCS.ParseHelpers.SyntaxError">
<summary>
 The error raised by the parse_error_rich function, which is called by the parser engine
 when a syntax error occurs. The first object is the ParseErrorContext which contains a dump of
 information about the grammar at the point where the error occurred, e.g. what tokens
 are valid to shift next at that point in the grammar. This information is processed in CompileOps.fs.
</summary>
</member>
<member name="M:Fantomas.FCS.PPParser.token_to_string(Fantomas.FCS.PPParser.token)">
<summary>
 This function gets the name of a token as a string
</summary>
</member>
<member name="M:Fantomas.FCS.PPParser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="M:Fantomas.FCS.PPParser.tokenTagToTokenId(System.Int32)">
<summary>
 This function maps integer indexes to symbolic token ids
</summary>
</member>
<member name="M:Fantomas.FCS.PPParser.tagOfToken(Fantomas.FCS.PPParser.token)">
<summary>
 This function maps tokens to integer indexes
</summary>
</member>
<member name="M:Fantomas.FCS.Parser.token_to_string(Fantomas.FCS.Parser.token)">
<summary>
 This function gets the name of a token as a string
</summary>
</member>
<member name="M:Fantomas.FCS.Parser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="M:Fantomas.FCS.Parser.tokenTagToTokenId(System.Int32)">
<summary>
 This function maps integer indexes to symbolic token ids
</summary>
</member>
<member name="M:Fantomas.FCS.Parser.tagOfToken(Fantomas.FCS.Parser.token)">
<summary>
 This function maps tokens to integer indexes
</summary>
</member>
<member name="T:Fantomas.FCS.Lexhelp.BlockCommentArgs">
<summary>
 Used in lex.fsl to represent the state of a block comment
</summary>
</member>
<member name="T:Fantomas.FCS.Lexhelp.SingleLineCommentArgs">
<summary>
 Used in lex.fsl to represent the state of a single line comment
</summary>
</member>
<member name="T:Fantomas.FCS.Lexhelp.LexerStringArgs">
<summary>
 Used in lex.fsl to represent the state of a string literal
</summary>
</member>
<member name="T:Fantomas.FCS.Lexhelp.LexArgs">
<summary>
 The context applicable to all lexing functions (tokens, strings etc.)
</summary>
</member>
<member name="T:Fantomas.FCS.Lexhelp.IndentationAwareSyntaxStatus">
<summary>
 Lexer args: status of #light processing.  Mutated when a #light
 directive is processed. This alters the behaviour of the lexfilter.
</summary>
</member>
<member name="P:Fantomas.FCS.Lexhelp.StringCapacity">
<summary>
 Arbitrary value
</summary>
</member>
<member name="M:Fantomas.FCS.PPLexer.rest(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule rest
</summary>
</member>
<member name="M:Fantomas.FCS.PPLexer.tokenstream(Fantomas.FCS.Lexhelp.LexArgs,Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Rule tokenstream
</summary>
</member>
<member name="M:Fantomas.FCS.Lexer.fail``1(Fantomas.FCS.Lexhelp.LexArgs,Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Int32,System.String,``0)">
<summary>
 Throw a lexing error with a message
</summary>
</member>
<member name="M:Fantomas.FCS.Lexer.lexemeTrimLeft(Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Int32)">
<summary>
 Trim n chars from the left of lexbuf, return string
</summary>
</member>
<member name="M:Fantomas.FCS.Lexer.lexemeTrimRight(Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Int32)">
<summary>
 Trim n chars from the right of lexbuf, return string
</summary>
</member>
<member name="M:Fantomas.FCS.Lexer.lexemeTrimBoth(Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Int32,System.Int32)">
<summary>
 Trim n chars from both sides of lexbuf, return string
</summary>
</member>
<member name="M:Fantomas.FCS.Lexer.lexeme(Internal.Utilities.Text.Lexing.LexBuffer{System.Char})">
<summary>
 Get string from lexbuf
</summary>
</member>
<member name="P:Fantomas.FCS.Lexer.Ranges.isInt64BadMax">
<summary>
 Whether valid as signed int64 when a minus sign is prepended, compares as string against &quot;9223372036854775808&quot;.
</summary>
</member>
<member name="P:Fantomas.FCS.Lexer.Ranges.isInt32BadMax">
<summary>
 Whether valid as signed int32 when a minus sign is prepended, compares as string against &quot;2147483648&quot;.
</summary>
</member>
<member name="M:Fantomas.FCS.Lexer.Ranges.isInt16BadMax(System.Int32)">
<summary>
 Whether valid as signed int16 when a minus sign is prepended, compares true to 0x8000
</summary>
</member>
<member name="M:Fantomas.FCS.Lexer.Ranges.isInt8BadMax(System.Int32)">
<summary>
 Whether valid as signed int8 when a minus sign is prepended, compares true to 0x80
</summary>
</member>
<member name="P:Fantomas.FCS.LexFilter.LexFilter.LexBuffer">
<summary>
 The LexBuffer associated with the filter
</summary>
</member>
<member name="M:Fantomas.FCS.LexFilter.LexFilter.GetToken">
<summary>
 Get the next token
</summary>
</member>
<member name="M:Fantomas.FCS.LexFilter.LexFilter.#ctor(Fantomas.FCS.Lexhelp.IndentationAwareSyntaxStatus,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{Internal.Utilities.Text.Lexing.LexBuffer{System.Char},Fantomas.FCS.Parser.token},Internal.Utilities.Text.Lexing.LexBuffer{System.Char},System.Boolean)">
<summary>
 Create a lex filter
</summary>
</member>
<member name="T:Fantomas.FCS.LexFilter.LexFilter">
<summary>
 A stateful filter over the token stream that adjusts it for indentation-aware syntax rules
 Process the token stream prior to parsing. Implements the offside rule and other lexical transformations.
</summary>
</member>
<member name="M:Fantomas.FCS.LexFilter.|TyparsCloseOp|_|(System.String)">
<summary>
 Match the close of &apos;&gt;&apos; of a set of type parameters.
 This is done for tokens such as &apos;&gt;&gt;&apos; by smashing the token
</summary>
</member>
<member name="T:Fantomas.FCS.LexFilter">
<summary>
 LexFilter - process the token stream prior to parsing.
 Implements the offside rule and a couple of other lexical transformations.
</summary>
</member>
</members>
</doc>
